{"task": "search", "input": "search code:\nApply *func* to every item of *iterable* by dictionary unpacking\n\nChoices:\n0: def doublestarmap(func, iterable):     for item in iterable:         yield func(**item)\n1: def solution(family_length: int = 8) -> int:     numbers_checked = set()      # Filter primes with less than 3 replaceable digits     primes = {         x for x in set(prime_sieve(1_000_000)) if len(str(x)) - len(set(str(x))) >= 3     }      for prime in primes:         if prime in numbers_checked:             continue          replacements = digit_replacements(prime)          for family in replacements:             numbers_checked.update(family)             primes_in_family = primes.intersection(family)              if len(primes_in_family) != family_length:                 continue              return min(primes_in_family)      return -1\n2: def rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:     if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):         raise Exception(\"Invalid upper or lower bound!\")     if high < low:         return -1     if sequence[low] == target:         return low     if sequence[high] == target:         return high     return rec_linear_search(sequence, low + 1, high - 1, target)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:\n    \"\"\"\n    Find the sum of n terms in an arithmetic progression.\n\n    >>> sum_of_series(1, 1, 10)\n    55.0\n    >>> sum_of_series(1, 10, 100)\n    49600.0\n    \"\"\"\n    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\n    # formula for sum of series\n    return total", "output": "def sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:\n    \"\"\"\n    Find the sum of n terms in an arithmetic progression.\n\n    >>> sum_of_series(1, 1, 10)\n    55.0\n    >>> sum_of_series(1, 10, 100)\n    49600.0\n    \"\"\"\n    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\n    # formula for sum of series\n    return total"}
{"task": "summary", "input": "summarize code:\ndef _partition(data: list, pivot) -> tuple:\n    less, equal, greater = [], [], []\n    for element in data:\n        if element < pivot:\n            less.append(element)\n        elif element > pivot:\n            greater.append(element)\n        else:\n            equal.append(element)\n    return less, equal, greater", "output": "Three way partition the data into smaller, equal and greater lists,"}
{"task": "detection", "input": "classify code:\ndef mel_to_freq(mels: float) -> float:\n    \"\"\"\n    Convert a frequency in the mel scale to Hertz.\n\n    Args:\n        mels: The frequency in mel scale.\n\n    Returns:\n        The frequency in Hertz.\n\n    Examples:\n    >>> round(mel_to_freq(999.99), 2)\n    1000.01\n    \"\"\"\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef mel_to_freq(mels: float) -> float:\n    \"\"\"\n    Convert a frequency in the mel scale to Hertz.\n\n    Args:\n        mels: The frequency in mel scale.\n\n    Returns:\n        The frequency in Hertz.\n\n    Examples:\n    >>> round(mel_to_freq(999.99), 2)\n    1000.01\n    \"\"\"\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)", "output": "def mel_to_freq(mels: float) -> float:\n    \"\"\"\n    Convert a frequency in the mel scale to Hertz.\n\n    Args:\n        mels: The frequency in mel scale.\n\n    Returns:\n        The frequency in Hertz.\n\n    Examples:\n    >>> round(mel_to_freq(999.99), 2)\n    1000.01\n    \"\"\"\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)"}
{"task": "detection", "input": "classify code:\ndef simple_fibonacci(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    fn_1 = f1\n    fn_2 = f2\n    n -= 2\n\n    while n > 0:\n        fn_1, fn_2 = fn_1 + fn_2, fn_1\n        n -= 1\n\n    return fn_1", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef audio_frames(\n    audio: np.ndarray,\n    sample_rate: int,\n    hop_length: int = 20,\n    ftt_size: int = 1024,\n) -> np.ndarray:\n\n    hop_size = np.round(sample_rate * hop_length / 1000).astype(int)\n\n    # Pad the audio signal to handle edge cases\n    audio = np.pad(audio, int(ftt_size / 2), mode=\"reflect\")\n\n    # Calculate the number of frames\n    frame_count = int((len(audio) - ftt_size) / hop_size) + 1\n\n    # Initialize an array to store the frames\n    frames = np.zeros((frame_count, ftt_size))\n\n    # Split the audio signal into frames\n    for n in range(frame_count):\n        frames[n] = audio[n * hop_size : n * hop_size + ftt_size]\n\n    return frames", "output": "Split an audio signal into overlapping frames."}
{"task": "search", "input": "search code:\nPure implementation of the bogosort algorithm in Python\n\nChoices:\n0: def bogo_sort(collection):      def is_sorted(collection):         for i in range(len(collection) - 1):             if collection[i] > collection[i + 1]:                 return False         return True      while not is_sorted(collection):         random.shuffle(collection)     return collection\n1: def hexagonal_num(n: int) -> int:     return n * (2 * n - 1)\n2: def exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:     return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> sentence = \"I love Python\"\n    >>> reverse_words(sentence) == \" \".join(sentence.split()[::-1])\n    True\n    >>> reverse_words(sentence)\n    'Python love I'\n    \"\"\"\n    return \" \".join(reversed(input_str.split(\" \")))", "output": "def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])"}
{"task": "summary", "input": "summarize code:\ndef harshad_numbers_in_base(limit: int, base: int) -> list[str]:\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    if limit < 0:\n        return []\n\n    numbers = [\n        int_to_base(i, base)\n        for i in range(1, limit)\n        if i % int(sum_of_digits(i, base), base) == 0\n    ]\n\n    return numbers", "output": "Finds all Harshad numbers smaller than num in base 'base'."}
{"task": "detection", "input": "classify code:\ndef shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )", "output": "CORRECT"}
{"task": "search", "input": "search code:\nConvert an Octal number to Binary.\n\nChoices:\n0: def octal_to_binary(octal_number: str) -> str:     if not octal_number:         raise ValueError(\"Empty string was passed to the function\")      binary_number = \"\"     octal_digits = \"01234567\"     for digit in octal_number:         if digit not in octal_digits:             raise ValueError(\"Non-octal value was passed to the function\")          binary_digit = \"\"         value = int(digit)         for _ in range(3):             binary_digit = str(value % 2) + binary_digit             value //= 2         binary_number += binary_digit      return binary_number\n1: def solution(min_block_length: int = 50) -> int:      fill_count_functions = [1] * min_block_length      for n in count(min_block_length):         fill_count_functions.append(1)          for block_length in range(min_block_length, n + 1):             for block_start in range(n - block_length):                 fill_count_functions[n] += fill_count_functions[                     n - block_start - block_length - 1                 ]              fill_count_functions[n] += 1          if fill_count_functions[n] > 1_000_000:             break      return n\n2: def encrypt(input_string: str, key: int) -> str:     temp_grid: list[list[str]] = [[] for _ in range(key)]     lowest = key - 1      if key <= 0:         raise ValueError(\"Height of grid can't be 0 or negative\")     if key == 1 or len(input_string) <= key:         return input_string      for position, character in enumerate(input_string):         num = position % (lowest * 2)  # puts it in bounds         num = min(num, lowest * 2 - num)  # creates zigzag pattern         temp_grid[num].append(character)     grid = [\"\".join(row) for row in temp_grid]     output_string = \"\".join(grid)      return output_string", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef combination_sum_iv(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)", "output": "def combination_sum_iv(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)"}
{"task": "summary", "input": "summarize code:\ndef pigeon_sort(array: list[int]) -> list[int]:\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "Implementation of pigeon hole sort algorithm"}
{"task": "detection", "input": "classify code:\ndef is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True", "output": "CORRECT"}
{"task": "search", "input": "search code:\nGenerates the next generation for a given state of Conway's Game of Life.\n\nChoices:\n0: def random_derangement(iterable):     seq = tuple(iterable)     if len(seq) < 2:         if len(seq) == 0:             return ()         raise IndexError('No derangments to choose from')     perm = list(range(len(seq)))     start = tuple(perm)     while True:         shuffle(perm)         if not any(map(is_, start, perm)):             return itemgetter(*perm)(seq)\n1: def intersection(function: Callable[[float], float], x0: float, x1: float) -> float:     x_n: float = x0     x_n1: float = x1     while True:         if x_n == x_n1 or function(x_n1) == function(x_n):             raise ZeroDivisionError(\"float division by zero, could not find root\")         x_n2: float = x_n1 - (             function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))         )         if abs(x_n2 - x_n1) < 10**-5:             return x_n2         x_n = x_n1         x_n1 = x_n2\n2: def new_generation(cells: list[list[int]]) -> list[list[int]]:     next_generation = []     for i in range(len(cells)):         next_generation_row = []         for j in range(len(cells[i])):             # Get the number of live neighbours             neighbour_count = 0             if i > 0 and j > 0:                 neighbour_count += cells[i - 1][j - 1]             if i > 0:                 neighbour_count += cells[i - 1][j]             if i > 0 and j < len(cells[i]) - 1:                 neighbour_count += cells[i - 1][j + 1]             if j > 0:                 neighbour_count += cells[i][j - 1]             if j < len(cells[i]) - 1:                 neighbour_count += cells[i][j + 1]             if i < len(cells) - 1 and j > 0:                 neighbour_count += cells[i + 1][j - 1]             if i < len(cells) - 1:                 neighbour_count += cells[i + 1][j]             if i < len(cells) - 1 and j < len(cells[i]) - 1:                 neighbour_count += cells[i + 1][j + 1]              # Rules of the game of life (excerpt from Wikipedia):             # 1. Any live cell with two or three live neighbours survives.             # 2. Any dead cell with three live neighbours becomes a live cell.             # 3. All other live cells die in the next generation.             #    Similarly, all other dead cells stay dead.             alive = cells[i][j] == 1             if (alive and 2 <= neighbour_count <= 3) or (                 not alive and neighbour_count == 3             ):                 next_generation_row.append(1)             else:                 next_generation_row.append(0)          next_generation.append(next_generation_row)     return next_generation", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef recur_fibo(n):\n    if n <= 1:\n        return n\n    else:\n        (recur_fibo(n - 1) + recur_fibo(n - 2))", "output": "def recur_fibo(n):\n    \"\"\"\n    >>> [recur_fibo(i) for i in range(12)]\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n    \"\"\"\n    return n if n <= 1 else recur_fibo(n-1) + recur_fibo(n-2)"}
{"task": "summary", "input": "summarize code:\ndef read_file_binary(file_path: str) -> str:\n    result = \"\"\n    try:\n        with open(file_path, \"rb\") as binary_file:\n            data = binary_file.read()\n        for dat in data:\n            curr_byte = f\"{dat:08b}\"\n            result += curr_byte\n        return result\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()", "output": "Reads given file as bytes and returns them as a long string"}
{"task": "detection", "input": "classify code:\ndef spiral_traversal(matrix: list[list]) -> list[int]:\n    \"\"\"\n    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n    Example:\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    Algorithm:\n        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n                output of [step 2])\n        Step 2. Now perform matrix's Transpose operation (Change rows to column\n                and vice versa) and reverse the resultant matrix.\n        Step 3. Pass the output of [2nd step], to same recursive function till\n                base case hits.\n    Dry Run:\n    Stage 1.\n    [1, 2, 3, 4] +   spiral_traversal([\n        [8, 12], [7, 11], [6, 10], [5, 9]]\n     ])\n    Stage 2.\n    [1, 2, 3, 4, 8, 12] + spiral_traversal([\n        [11, 10, 9], [7, 6, 5]\n    ])\n    Stage 3.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 4.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 5.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\n    Stage 6.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])\n    \"\"\"\n    if matrix:\n        return list(matrix.pop(0)) + spiral_traversal(\n            [list(row) for row in zip(*matrix)][::-1]\n        )\n    else:\n        return []", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns âˆ‘ r_max for 3 <= a <= n as explained above\n\nChoices:\n0: def solution(n: int = 1000) -> int:     return sum(2 * a * ((a - 1) // 2) for a in range(3, n + 1))\n1: def largest_pow_of_two_le_num(number: int) -> int:     if isinstance(number, float):         raise TypeError(\"Input value must be a 'int' type\")     if number <= 0:         return 0     res = 1     while (res << 1) <= number:         res <<= 1     return res\n2: def calculate_waitingtime(     arrival_time: list[int], burst_time: list[int], no_of_processes: int ) -> list[int]:     remaining_time = [0] * no_of_processes     waiting_time = [0] * no_of_processes     # Copy the burst time into remaining_time[]     for i in range(no_of_processes):         remaining_time[i] = burst_time[i]      complete = 0     increment_time = 0     minm = 999999999     short = 0     check = False      # Process until all processes are completed     while complete != no_of_processes:         for j in range(no_of_processes):             if (                 arrival_time[j] <= increment_time                 and remaining_time[j] > 0                 and remaining_time[j] < minm             ):                 minm = remaining_time[j]                 short = j                 check = True          if not check:             increment_time += 1             continue         remaining_time[short] -= 1          minm = remaining_time[short]         if minm == 0:             minm = 999999999          if remaining_time[short] == 0:             complete += 1             check = False              # Find finish time of current process             finish_time = increment_time + 1              # Calculate waiting time             finar = finish_time - arrival_time[short]             waiting_time[short] = finar - burst_time[short]              waiting_time[short] = max(waiting_time[short], 0)          # Increment time         increment_time += 1     return waiting_time", "output": "0"}
{"task": "detection", "input": "classify code:\ndef calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef tabu_search(\n    first_solution, distance_of_first_solution, dict_of_neighbours, iters, size\n):\n    count = 1\n    solution = first_solution\n    tabu_list = []\n    best_cost = distance_of_first_solution\n    best_solution_ever = solution\n\n    while count <= iters:\n        neighborhood = find_neighborhood(solution, dict_of_neighbours)\n        index_of_best_solution = 0\n        best_solution = neighborhood[index_of_best_solution]\n        best_cost_index = len(best_solution) - 1\n\n        found = False\n        while not found:\n            i = 0\n            while i < len(best_solution):\n                if best_solution[i] != solution[i]:\n                    first_exchange_node = best_solution[i]\n                    second_exchange_node = solution[i]\n                    break\n                i = i + 1\n\n            if [first_exchange_node, second_exchange_node] not in tabu_list and [\n                second_exchange_node,\n                first_exchange_node,\n            ] not in tabu_list:\n                tabu_list.append([first_exchange_node, second_exchange_node])\n                found = True\n                solution = best_solution[:-1]\n                cost = neighborhood[index_of_best_solution][best_cost_index]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_solution_ever = solution\n            else:\n                index_of_best_solution = index_of_best_solution + 1\n                best_solution = neighborhood[index_of_best_solution]\n\n        if len(tabu_list) >= size:\n            tabu_list.pop(0)\n\n        count = count + 1\n\n    return best_solution_ever, best_cost", "output": "Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in"}
{"task": "repair", "input": "fix bug:\ndef decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)", "output": "def decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)"}
{"task": "search", "input": "search code:\nGet the bit at the given position\n\nChoices:\n0: def get_bit(number: int, position: int) -> int:     return int((number & (1 << position)) != 0)\n1: def intersection(function: Callable[[float], float], x0: float, x1: float) -> float:     x_n: float = x0     x_n1: float = x1     while True:         if x_n == x_n1 or function(x_n1) == function(x_n):             raise ZeroDivisionError(\"float division by zero, could not find root\")         x_n2: float = x_n1 - (             function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))         )         if abs(x_n2 - x_n1) < 10**-5:             return x_n2         x_n = x_n1         x_n1 = x_n2\n2: def freq_to_mel(freq: float) -> float:     # Use the formula to convert frequency to the mel scale     return 2595.0 * np.log10(1.0 + freq / 700.0)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef calc_derivative(f: RealFunc, x: float, delta_x: float = 1e-3) -> float:\n    return (f(x + delta_x / 2) - f(x - delta_x / 2)) / delta_x", "output": "Approximate the derivative of a function f(x) at a point x using the finite"}
{"task": "detection", "input": "classify code:\ndef equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef vector_product(point1: Tuple[int, int], point2: Tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]", "output": "def vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]"}
{"task": "search", "input": "search code:\nPrint exception up to 'limit' stack trace entries from 'tb' to 'file'.\n\nChoices:\n0: def euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:     return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)\n1: def print_exception(etype, value, tb, limit=None, file=None):      if file is None:         file = sys.stderr     if tb:         tbi = TracebackInfo.from_traceback(tb, limit)         print(str(tbi), end='', file=file)      for line in format_exception_only(etype, value):         print(line, end='', file=file)\n2: def loops(n):     return repeat(None, n)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef sigmoid_derivative(value: np.ndarray) -> np.ndarray:\n    return (value) * (1 - (value))", "output": "Provides the derivative value of the sigmoid function."}
{"task": "search", "input": "search code:\nThis functions takes an integer number as input.\n\nChoices:\n0: def liouville_lambda(number: int) -> int:     if not isinstance(number, int):         msg = f\"Input value of [number={number}] must be an integer\"         raise TypeError(msg)     if number < 1:         raise ValueError(\"Input must be a positive integer\")     return -1 if len(prime_factors(number)) % 2 else 1\n1: def insert_node(head: Node | None, data: int) -> Node:     new_node = Node(data)     # If the linked list is empty, the new_node becomes the head     if head is None:         return new_node      temp_node = head     while temp_node.next_node:         temp_node = temp_node.next_node      temp_node.next_node = new_node     return head\n2: def solution(n: int = 10000) -> int:     total = sum(         i         for i in range(1, n)         if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i     )     return total", "output": "0"}
{"task": "detection", "input": "classify code:\ndef _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\n    Args:\n        total_elements (int): The total number of elements.\n        elements_to_choose (int): The number of elements to choose.\n\n    Returns:\n        int: The binomial coefficient C(total_elements, elements_to_choose).\n\n    Examples:\n    >>> _binomial_coefficient(5, 2)\n    10\n    >>> _binomial_coefficient(6, 3)\n    20\n    \"\"\"\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef jaro_winkler(str1: str, str2: str) -> float:\n    \"\"\"\n    Jaro-Winkler distance is a string metric measuring an edit distance between two\n    sequences.\n    Output value is between 0.0 and 1.0.\n\n    >>> jaro_winkler(\"martha\", \"marhta\")\n    0.9611111111111111\n    >>> jaro_winkler(\"CRATE\", \"TRACE\")\n    0.7333333333333334\n    >>> jaro_winkler(\"test\", \"dbdbdbdb\")\n    0.0\n    >>> jaro_winkler(\"test\", \"test\")\n    1.0\n    >>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n    0.6363636363636364\n    >>> jaro_winkler(\"test\", \"\")\n    0.0\n    >>> jaro_winkler(\"hello\", \"world\")\n    0.4666666666666666\n    >>> jaro_winkler(\"hell**o\", \"*world\")\n    0.4365079365079365\n    \"\"\"\n\n    def get_matched_characters(_str1: str, _str2: str) -> str:\n        matched = []\n        limit = min(len(_str1), len(_str2)) // 2\n        for i, char in enumerate(_str1):\n            left = int(max(0, i - limit))\n            right = int(min(i + limit + 1, len(_str2)))\n            if char in _str2[left:right]:\n                matched.append(char)\n                _str2 = (\n                    f\"{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}\"\n                )\n\n        return \"\".join(matched)\n\n    # matching characters\n    matching_1 = get_matched_characters(str1, str2)\n    matching_2 = get_matched_characters(str2, str1)\n    match_count = len(matching_1)\n\n    # transposition\n    transpositions = (\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\n    )\n\n    if not match_count:\n        jaro = 0.0\n    else:\n        jaro = (\n            1\n            / 3\n            * (\n                match_count / len(str1)\n                + match_count / len(str2)\n                + (match_count - transpositions) / match_count\n            )\n        )\n\n    # common prefix up to 4 characters\n    prefix_len = 0\n    for c1, c2 in zip(str1[:4], str2[:4]):\n        if c1 == c2:\n            prefix_len += 1\n        else:\n            break\n\n    return jaro + 0.1 * prefix_len * (1 - jaro)", "output": "def jaro_winkler(str1: str, str2: str) -> float:\n    \"\"\"\n    Jaro-Winkler distance is a string metric measuring an edit distance between two\n    sequences.\n    Output value is between 0.0 and 1.0.\n\n    >>> jaro_winkler(\"martha\", \"marhta\")\n    0.9611111111111111\n    >>> jaro_winkler(\"CRATE\", \"TRACE\")\n    0.7333333333333334\n    >>> jaro_winkler(\"test\", \"dbdbdbdb\")\n    0.0\n    >>> jaro_winkler(\"test\", \"test\")\n    1.0\n    >>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n    0.6363636363636364\n    >>> jaro_winkler(\"test\", \"\")\n    0.0\n    >>> jaro_winkler(\"hello\", \"world\")\n    0.4666666666666666\n    >>> jaro_winkler(\"hell**o\", \"*world\")\n    0.4365079365079365\n    \"\"\"\n\n    def get_matched_characters(_str1: str, _str2: str) -> str:\n        matched = []\n        limit = min(len(_str1), len(_str2)) // 2\n        for i, char in enumerate(_str1):\n            left = int(max(0, i - limit))\n            right = int(min(i + limit + 1, len(_str2)))\n            if char in _str2[left:right]:\n                matched.append(char)\n                _str2 = (\n                    f\"{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}\"\n                )\n\n        return \"\".join(matched)\n\n    # matching characters\n    matching_1 = get_matched_characters(str1, str2)\n    matching_2 = get_matched_characters(str2, str1)\n    match_count = len(matching_1)\n\n    # transposition\n    transpositions = (\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\n    )\n\n    if not match_count:\n        jaro = 0.0\n    else:\n        jaro = (\n            1\n            / 3\n            * (\n                match_count / len(str1)\n                + match_count / len(str2)\n                + (match_count - transpositions) / match_count\n            )\n        )\n\n    # common prefix up to 4 characters\n    prefix_len = 0\n    for c1, c2 in zip(str1[:4], str2[:4]):\n        if c1 == c2:\n            prefix_len += 1\n        else:\n            break\n\n    return jaro + 0.1 * prefix_len * (1 - jaro)"}
{"task": "detection", "input": "classify code:\ndef is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int, right: int\n) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n\n    \"\"\"\n    if right < left:\n        return None\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)", "output": "def binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n    -1\n    \"\"\"\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)"}
{"task": "search", "input": "search code:\nGenerates all possible combinations of k numbers out of 1 ... n using itertools.\n\nChoices:\n0: def combination_lists(n: int, k: int) -> list[list[int]]:     return [list(x) for x in combinations(range(1, n + 1), k)]\n1: def _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):     if max_rev[n] >= 0:         return max_rev[n]     elif n == 0:         return 0     else:         max_revenue = float(\"-inf\")         for i in range(1, n + 1):             max_revenue = max(                 max_revenue,                 prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),             )          max_rev[n] = max_revenue      return max_rev[n]\n2: def benchmark():     from timeit import timeit      setup = \"from __main__ import slow_primes, primes, fast_primes\"     print(timeit(\"slow_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))     print(timeit(\"primes(1_000_000_000_000)\", setup=setup, number=1_000_000))     print(timeit(\"fast_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef create_cipher_map(key: str) -> dict[str, str]:\n    # Create a list of the letters in the alphabet\n    alphabet = [chr(i + 65) for i in range(26)]\n    # Remove duplicate characters from key\n    key = remove_duplicates(key.upper())\n    offset = len(key)\n    # First fill cipher with key characters\n    cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}\n    # Then map remaining characters in alphabet to\n    # the alphabet from the beginning\n    for i in range(len(cipher_alphabet), 26):\n        char = alphabet[i - offset]\n        # Ensure we are not mapping letters to letters previously mapped\n        while char in key:\n            offset -= 1\n            char = alphabet[i - offset]\n        cipher_alphabet[alphabet[i]] = char\n    return cipher_alphabet", "output": "Returns a cipher map given a keyword."}
{"task": "detection", "input": "classify code:\ndef coulombs_law(q1: float, q2: float, radius: float) -> float:\n    \"\"\"\n    Calculate the electrostatic force of attraction or repulsion\n    between two point charges\n\n    >>> coulombs_law(15.5, 20, 15)\n    12382849136.06\n    >>> coulombs_law(1, 15, 5)\n    5392531075.38\n    >>> coulombs_law(20, -50, 15)\n    -39944674632.44\n    >>> coulombs_law(-5, -8, 10)\n    3595020716.92\n    >>> coulombs_law(50, 100, 50)\n    17975103584.6\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nImplements the SquarePlus activation function.\n\nChoices:\n0: def squareplus(vector: np.ndarray, beta: float) -> np.ndarray:     return (vector + np.sqrt(vector**2 + beta)) / 2\n1: def binary_tree_count(node_count: int) -> int:     return catalan_number(node_count) * factorial(node_count)\n2: def solution():     script_dir = os.path.dirname(os.path.realpath(__file__))     words_file_path = os.path.join(script_dir, \"words.txt\")      words = \"\"     with open(words_file_path) as f:         words = f.readline()      words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]     words = [         word         for word in [sum(ord(x) - 64 for x in word) for word in words]         if word in TRIANGULAR_NUMBERS     ]     return len(words)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef validate(*values: float) -> bool:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> validate(2.016, 4.002)\n    True\n    >>> validate(-2.016, 4.002)\n    False\n    >>> validate()\n    False\n    \"\"\"\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result", "output": "def validate(*values: float) -> bool:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> validate(2.016, 4.002)\n    True\n    >>> validate(-2.016, 4.002)\n    False\n    >>> validate()\n    False\n    \"\"\"\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result"}
{"task": "summary", "input": "summarize code:\ndef solution(num_digits: int = 100) -> int:\n    return non_bouncy_upto(num_digits)", "output": "Calculate the number of non-bouncy numbers less than a googol."}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    kmap = [[0, 1], [1, 1]]\n\n    # Manually generate the product of [0, 1] and [0, 1]\n\n    for row in kmap:\n        print(row)\n\n    print(\"Simplified Expression:\")\n    print(simplify_kmap(kmap))", "output": "Main function to create and simplify a K-Map."}
{"task": "detection", "input": "classify code:\ndef bisect_right(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "BUGGY"}
{"task": "search", "input": "search code:\nThis function first produces a bitonic sequence by recursively sorting its two\n\nChoices:\n0: def bitonic_sort(array: list[int], low: int, length: int, direction: int) -> None:     if length > 1:         middle = int(length / 2)         bitonic_sort(array, low, middle, 1)         bitonic_sort(array, low + middle, middle, 0)         bitonic_merge(array, low, length, direction)\n1: def array_equalization(vector: list[int], step_size: int) -> int:     if step_size <= 0:         raise ValueError(\"Step size must be positive and non-zero.\")     if not isinstance(step_size, int):         raise ValueError(\"Step size must be an integer.\")      unique_elements = set(vector)     min_updates = maxsize      for element in unique_elements:         elem_index = 0         updates = 0         while elem_index < len(vector):             if vector[elem_index] != element:                 updates += 1                 elem_index += step_size             else:                 elem_index += 1         min_updates = min(min_updates, updates)      return min_updates\n2: def discrete_cosine_transform(dct_filter_num: int, filter_num: int) -> np.ndarray:     basis = np.empty((dct_filter_num, filter_num))     basis[0, :] = 1.0 / np.sqrt(filter_num)      samples = np.arange(1, 2 * filter_num, 2) * np.pi / (2.0 * filter_num)      for i in range(1, dct_filter_num):         basis[i, :] = np.cos(i * samples) * np.sqrt(2.0 / filter_num)      return basis", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))", "output": "def evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))"}
{"task": "detection", "input": "classify code:\ndef bisect_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "CORRECT"}
{"task": "search", "input": "search code:\nYield lists of items from *iterable*, where each list is delimited by\n\nChoices:\n0: def f(x: float) -> float:     return math.pow(x, 3) - (2 * x) - 5\n1: def split_at(iterable, pred, maxsplit=-1, keep_separator=False):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         if pred(item):             yield buf             if keep_separator:                 yield [item]             if maxsplit == 1:                 yield list(it)                 return             buf = []             maxsplit -= 1         else:             buf.append(item)     yield buf\n2: def find_median(nums: list[int | float]) -> float:     div, mod = divmod(len(nums), 2)     if mod:         return nums[div]     return (nums[div] + nums[(div) - 1]) / 2", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef chunk_ranges(input_size, chunk_size, input_offset=0, overlap_size=0, align=False):\n    input_size = _validate_positive_int(\n        input_size, 'input_size', strictly_positive=False)\n    chunk_size = _validate_positive_int(chunk_size, 'chunk_size')\n    input_offset = _validate_positive_int(\n        input_offset, 'input_offset', strictly_positive=False)\n    overlap_size = _validate_positive_int(\n        overlap_size, 'overlap_size', strictly_positive=False)\n\n    input_stop = input_offset + input_size\n\n    if align:\n        initial_chunk_len = chunk_size - \\\n            input_offset % (chunk_size - overlap_size)\n        if initial_chunk_len != overlap_size:\n            yield (input_offset, min(input_offset + initial_chunk_len, input_stop))\n            if input_offset + initial_chunk_len >= input_stop:\n                return\n            input_offset = input_offset + initial_chunk_len - overlap_size\n\n    for i in range(input_offset, input_stop, chunk_size - overlap_size):\n        yield (i, min(i + chunk_size, input_stop))\n\n        if i + chunk_size >= input_stop:\n            return", "output": "Generates *chunk_size*-sized chunk ranges for an input with length *input_size*."}
{"task": "repair", "input": "fix bug:\ndef calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)"}
{"task": "search", "input": "search code:\nSolves the maximum subarray sum problem using Kadane's algorithm.\n\nChoices:\n0: def norm_squared(vector: ndarray) -> float:     return np.dot(vector, vector)\n1: def max_subarray_sum(     arr: Sequence[float], allow_empty_subarrays: bool = False ) -> float:     if not arr:         return 0      max_sum = 0 if allow_empty_subarrays else float(\"-inf\")     curr_sum = 0.0     for num in arr:         curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)         max_sum = max(max_sum, curr_sum)      return max_sum\n2: def solution(n: int = 1000) -> int:      return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef decimal_to_binary(no_of_variable: int, minterms: List[float]) -> List[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef calculate_waiting_times(burst_times: List[int]) -> List[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r", "output": "def calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r"}
{"task": "summary", "input": "summarize code:\ndef luhn_validation(credit_card_number: str) -> bool:\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0", "output": "Function to luhn algorithm validation for a given credit card number."}
{"task": "repair", "input": "fix bug:\ndef equality(iterable: list) -> bool:\n    \"\"\"\n    Check the equality of ALL elements in an iterable\n    >>> equality([1, 2, 3, 4])\n    False\n    >>> equality([2, 2, 2, 2])\n    True\n    >>> equality([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    return len(set(iterable)) in (0, 1)", "output": "def equality(iterable: list) -> bool:\n    \"\"\"\n    Check the equality of ALL elements in an iterable\n    >>> equality([1, 2, 3, 4])\n    False\n    >>> equality([2, 2, 2, 2])\n    True\n    >>> equality([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    return len(set(iterable)) in (0, 1)"}
{"task": "search", "input": "search code:\nComputes a^b % c iteratively, where a is the base, b is the exponent, and c is the\n\nChoices:\n0: def binary_exp_mod_iterative(base: float, exponent: int, modulus: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")     if modulus <= 0:         raise ValueError(\"Modulus must be a positive integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res = ((res % modulus) * (base % modulus)) % modulus          base *= base         exponent >>= 1      return res\n1: def stalin_sort(sequence: list[int]) -> list[int]:     result = [sequence[0]]     for element in sequence[1:]:         if element >= result[-1]:             result.append(element)      return result\n2: def get_digits(num: int) -> str:     return \"\".join(sorted(str(num**3)))", "output": "0"}
{"task": "detection", "input": "classify code:\ndef ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef mark_ends(iterable):\n    it = iter(iterable)\n    for a in it:\n        first = True\n        for b in it:\n            yield first, False, a\n            a = b\n            first = False\n        yield first, True, a", "output": "Yield 3-tuples of the form ``(is_first, is_last, item)``."}
{"task": "search", "input": "search code:\nReturns the sum of all even fibonacci sequence elements that are lower\n\nChoices:\n0: def factor(n):      # Corner case reduction     if n < 2:         return      # Trial division reduction     for prime in _primes_below_211:         while not n % prime:             yield prime             n //= prime      # Pollard's rho reduction     primes = []     todo = [n] if n > 1 else []     for n in todo:         if n < 211**2 or is_prime(n):             primes.append(n)         else:             fact = _factor_pollard(n)             todo += (fact, n // fact)     yield from sorted(primes)\n1: def solution(n: int = 4000000) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     getcontext().prec = 100     phi = (Decimal(5) ** Decimal(\"0.5\") + 1) / Decimal(2)      index = (math.floor(math.log(n * (phi + 2), phi) - 1) // 3) * 3 + 2     num = Decimal(round(phi ** Decimal(index + 1))) / (phi + 2)     total = num // 2     return int(total)\n2: def armstrong_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False      # Initialization of sum and number of digits.     total = 0     number_of_digits = 0     temp = n     # Calculation of digits of the number     number_of_digits = len(str(n))     # Dividing number into separate digits and find Armstrong number     temp = n     while temp > 0:         rem = temp % 10         total += rem**number_of_digits         temp //= 10     return n == total", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef gnome_sort(unsorted):\n    \"\"\"Pure implementation of the gnome sort algorithm in Python.\"\"\"\n    if len(unsorted) <= 1:\n        return unsorted\n\n    i = 1\n\n    while i < len(unsorted):\n        if unsorted[i - 1] <= unsorted[i]:\n            i += 1\n        else:\n            unsorted[i - 1], unsorted[i] = unsorted[i], unsorted[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1", "output": "def gnome_sort(lst: list) -> list:\n    \"\"\"\n    Pure implementation of the gnome sort algorithm in Python\n\n    Take some mutable ordered collection with heterogeneous comparable items inside as\n    arguments, return the same collection ordered by ascending.\n\n    Examples:\n    >>> gnome_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> gnome_sort([])\n    []\n\n    >>> gnome_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    >>> \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\"))))\n    ' !Gadeimnoprstu'\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n\n    i = 1\n\n    while i < len(lst):\n        if lst[i - 1] <= lst[i]:\n            i += 1\n        else:\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1\n\n    return lst"}
{"task": "summary", "input": "summarize code:\ndef carrier_concentration(\n    electron_conc: float,\n    hole_conc: float,\n    intrinsic_conc: float,\n) -> tuple:\n    if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif electron_conc < 0:\n        raise ValueError(\"Electron concentration cannot be negative in a semiconductor\")\n    elif hole_conc < 0:\n        raise ValueError(\"Hole concentration cannot be negative in a semiconductor\")\n    elif intrinsic_conc < 0:\n        raise ValueError(\n            \"Intrinsic concentration cannot be negative in a semiconductor\"\n        )\n    elif electron_conc == 0:\n        return (\n            \"electron_conc\",\n            intrinsic_conc**2 / hole_conc,\n        )\n    elif hole_conc == 0:\n        return (\n            \"hole_conc\",\n            intrinsic_conc**2 / electron_conc,\n        )\n    elif intrinsic_conc == 0:\n        return (\n            \"intrinsic_conc\",\n            (electron_conc * hole_conc) ** 0.5,\n        )\n    else:\n        return (-1, -1)", "output": "This function can calculate any one of the three -"}
{"task": "detection", "input": "classify code:\ndef excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer", "output": "CORRECT"}
{"task": "search", "input": "search code:\nPrim's Algorithm with min heap.\n\nChoices:\n0: def prim_heap(graph: list, root: Vertex) -> Iterator[tuple]:     for u in graph:         u.key = math.inf         u.pi = None     root.key = 0      h = list(graph)     hq.heapify(h)      while h:         u = hq.heappop(h)         for v in u.neighbors:             if (v in h) and (u.edges[v.id] < v.key):                 v.pi = u                 v.key = u.edges[v.id]                 hq.heapify(h)      for i in range(1, len(graph)):         yield (int(graph[i].id) + 1, int(graph[i].pi.id) + 1)\n1: def _validator(     rotpos: RotorPositionT, rotsel: RotorSelectionT, pb: str ) -> tuple[RotorPositionT, RotorSelectionT, dict[str, str]]:     # Checks if there are 3 unique rotors      if (unique_rotsel := len(set(rotsel))) < 3:         msg = f\"Please use 3 unique rotors (not {unique_rotsel})\"         raise Exception(msg)      # Checks if rotor positions are valid     rotorpos1, rotorpos2, rotorpos3 = rotpos     if not 0 < rotorpos1 <= len(abc):         msg = f\"First rotor position is not within range of 1..26 ({rotorpos1}\"         raise ValueError(msg)     if not 0 < rotorpos2 <= len(abc):         msg = f\"Second rotor position is not within range of 1..26 ({rotorpos2})\"         raise ValueError(msg)     if not 0 < rotorpos3 <= len(abc):         msg = f\"Third rotor position is not within range of 1..26 ({rotorpos3})\"         raise ValueError(msg)      # Validates string and returns dict     pbdict = _plugboard(pb)      return rotpos, rotsel, pbdict\n2: def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:      return len_board * len_board_column * row + column", "output": "0"}
{"task": "detection", "input": "classify code:\ndef is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)"}
{"task": "summary", "input": "summarize code:\ndef or_gate(input_1: int, input_2: int) -> int:\n    return int((input_1, input_2).count(1) != 0)", "output": "Calculate OR of the input values"}
{"task": "repair", "input": "fix bug:\ndef generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result", "output": "def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result"}
{"task": "search", "input": "search code:\nJust recursive print of a tree\n\nChoices:\n0: def inorder(root: Node | None) -> None:     if not root:  # None         return     else:         inorder(root.left)         print(root.value, end=\",\")         inorder(root.right)\n1: def simple_moving_average(     data: Sequence[float], window_size: int ) -> list[float | None]:     if window_size < 1:         raise ValueError(\"Window size must be a positive integer\")      sma: list[float | None] = []      for i in range(len(data)):         if i < window_size - 1:             sma.append(None)  # SMA not available for early data points         else:             window = data[i - window_size + 1 : i + 1]             sma_value = sum(window) / window_size             sma.append(sma_value)     return sma\n2: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")      for value in (262144, 1125899906842624, 1267650600228229401496703205376):         for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):             benchmark_a_function(func, value)         print()", "output": "0"}
{"task": "detection", "input": "classify code:\ndef double_linear_search(array: List[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef fib_iterative(n: int) -> list[int]:\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    if n == 0:\n        return [0]\n    fib = [0, 1]\n    for _ in range(n - 1):\n        fib.append(fib[-1] + fib[-2])\n    return fib", "output": "Calculates the first n (0-indexed) Fibonacci numbers using iteration"}
{"task": "detection", "input": "classify code:\ndef merge_insertion_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef normalization(data: list, ndigits: int = 3) -> list:\n    \"\"\"\n    Return a normalized list of values.\n\n    @params: data, a list of values to normalize\n    @returns: a list of normalized values (rounded to ndigits decimal places)\n    @examples:\n    >>> normalization([2, 7, 10, 20, 30, 50])\n    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\n    >>> normalization([5, 10, 15, 20, 25])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # variables for calculation\n    x_min = min(data)\n    x_max = max(data)\n    # normalize data\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]", "output": "def normalization(data: list, ndigits: int = 3) -> list:\n    \"\"\"\n    Return a normalized list of values.\n\n    @params: data, a list of values to normalize\n    @returns: a list of normalized values (rounded to ndigits decimal places)\n    @examples:\n    >>> normalization([2, 7, 10, 20, 30, 50])\n    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\n    >>> normalization([5, 10, 15, 20, 25])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # variables for calculation\n    x_min = min(data)\n    x_max = max(data)\n    # normalize data\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]"}
{"task": "summary", "input": "summarize code:\ndef naturalsize(value, binary=False, gnu=False, format=\"%.1f\"):\n    if gnu:\n        suffix = suffixes[\"gnu\"]\n    elif binary:\n        suffix = suffixes[\"binary\"]\n    else:\n        suffix = suffixes[\"decimal\"]\n\n    base = 1024 if (gnu or binary) else 1000\n    bytes = float(value)\n    abs_bytes = abs(bytes)\n\n    if abs_bytes == 1 and not gnu:\n        return \"%d Byte\" % bytes\n    elif abs_bytes < base and not gnu:\n        return \"%d Bytes\" % bytes\n    elif abs_bytes < base and gnu:\n        return \"%dB\" % bytes\n\n    for i, s in enumerate(suffix):\n        unit = base ** (i + 2)\n        if abs_bytes < unit and not gnu:\n            return (format + \" %s\") % ((base * bytes / unit), s)\n        elif abs_bytes < unit and gnu:\n            return (format + \"%s\") % ((base * bytes / unit), s)\n    if gnu:\n        return (format + \"%s\") % ((base * bytes / unit), s)\n    return (format + \" %s\") % ((base * bytes / unit), s)", "output": "Format a number of bytes like a human readable filesize (e.g. 10 kB)."}
{"task": "search", "input": "search code:\nExamples:\n\nChoices:\n0: def get_files_url() -> str:     with open(os.environ[\"GITHUB_EVENT_PATH\"]) as file:         event = json.load(file)     return event[\"pull_request\"][\"url\"] + \"/files\"\n1: def print_linked_list(head: Node | None) -> None:     if head is None:         return     while head.next_node is not None:         print(head.data, end=\"->\")         head = head.next_node     print(head.data)\n2: def power(x: int, y: int, mod: int) -> int:      if y == 0:         return 1     temp = power(x, y // 2, mod) % mod     temp = (temp * temp) % mod     if y % 2 == 1:         temp = (temp * x) % mod     return temp", "output": "2"}
{"task": "detection", "input": "classify code:\ndef longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [5, 7]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = array[i:]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same row, column,\n    # left upper diagonal, and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, n)))\n        and all(\n            board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, -1, -1))\n        )\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, n)))\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, -1, -1)))\n    )", "output": "def is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same upper column,\n    # left upper diagonal and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))\n        )\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))\n        )\n    )"}
{"task": "summary", "input": "summarize code:\ndef circle_bottom_arc_integral(point: float) -> float:\n\n    return (\n        (1 - 2 * point) * sqrt(point - point**2) + 2 * point + asin(sqrt(1 - point))\n    ) / 4", "output": "Returns integral of circle bottom arc y = 1 / 2 - sqrt(1 / 4 - (x - 1 / 2) ^ 2)"}
{"task": "search", "input": "search code:\nLoops through each pair of adjacent vectors. Each line between two adjacent\n\nChoices:\n0: def euler_phi(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = n     for x in set(prime_factors(n)):         s *= (x - 1) / x     return int(s)\n1: def suppress_non_maximum(image_shape, gradient_direction, sobel_grad):     destination = np.zeros(image_shape)      for row in range(1, image_shape[0] - 1):         for col in range(1, image_shape[1] - 1):             direction = gradient_direction[row, col]              if (                 0 <= direction < PI / 8                 or 15 * PI / 8 <= direction <= 2 * PI                 or 7 * PI / 8 <= direction <= 9 * PI / 8             ):                 w = sobel_grad[row, col - 1]                 e = sobel_grad[row, col + 1]                 if sobel_grad[row, col] >= w and sobel_grad[row, col] >= e:                     destination[row, col] = sobel_grad[row, col]              elif (                 PI / 8 <= direction < 3 * PI / 8                 or 9 * PI / 8 <= direction < 11 * PI / 8             ):                 sw = sobel_grad[row + 1, col - 1]                 ne = sobel_grad[row - 1, col + 1]                 if sobel_grad[row, col] >= sw and sobel_grad[row, col] >= ne:                     destination[row, col] = sobel_grad[row, col]              elif (                 3 * PI / 8 <= direction < 5 * PI / 8                 or 11 * PI / 8 <= direction < 13 * PI / 8             ):                 n = sobel_grad[row - 1, col]                 s = sobel_grad[row + 1, col]                 if sobel_grad[row, col] >= n and sobel_grad[row, col] >= s:                     destination[row, col] = sobel_grad[row, col]              elif (                 5 * PI / 8 <= direction < 7 * PI / 8                 or 13 * PI / 8 <= direction < 15 * PI / 8             ):                 nw = sobel_grad[row - 1, col - 1]                 se = sobel_grad[row + 1, col + 1]                 if sobel_grad[row, col] >= nw and sobel_grad[row, col] >= se:                     destination[row, col] = sobel_grad[row, col]      return destination\n2: def iteration_step(vectors: list[np.ndarray]) -> list[np.ndarray]:     new_vectors = []     for i, start_vector in enumerate(vectors[:-1]):         end_vector = vectors[i + 1]         new_vectors.append(start_vector)         difference_vector = end_vector - start_vector         new_vectors.append(start_vector + difference_vector / 3)         new_vectors.append(             start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)         )         new_vectors.append(start_vector + difference_vector * 2 / 3)     new_vectors.append(vectors[-1])     return new_vectors", "output": "2"}
{"task": "detection", "input": "classify code:\ndef num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    \"\"\"\n    digits = 0\n    while n > 0:\n        n = n // 10\n        digits += 1\n    return digits", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef eliminate(values, s, d):\n    if d not in values[s]:\n        return values  ## Already eliminated\n    values[s] = values[s].replace(d, \"\")\n    ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.\n    if len(values[s]) == 0:\n        return False  ## Contradiction: removed last value\n    elif len(values[s]) == 1:\n        d2 = values[s]\n        if not all(eliminate(values, s2, d2) for s2 in peers[s]):\n            return False\n    ## (2) If a unit u is reduced to only one place for a value d, then put it there.\n    for u in units[s]:\n        dplaces = [s for s in u if d in values[s]]\n        if len(dplaces) == 0:\n            return False  ## Contradiction: no place for this value\n        # d can only be in one place in unit; assign it there\n        elif len(dplaces) == 1 and not assign(values, dplaces[0], d):\n            return False\n    return values", "output": "Eliminate d from values[s]; propagate when values or places <= 2."}
{"task": "repair", "input": "fix bug:\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)", "output": "def hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)"}
{"task": "search", "input": "search code:\nGet a tuple representing the relative time difference between two\n\nChoices:\n0: def decimal_relative_time(d, other=None, ndigits=0, cardinalize=True):     if other is None:         other = datetime.now(timezone.utc).replace(tzinfo=None)     diff = other - d     diff_seconds = timedelta.total_seconds(diff)     abs_diff = abs(diff)     b_idx = bisect.bisect(_BOUND_DELTAS, abs_diff) - 1     bbound, bunit, bname = _BOUNDS[b_idx]     f_diff = diff_seconds / timedelta.total_seconds(bunit)     rounded_diff = round(f_diff, ndigits)     if cardinalize:         return rounded_diff, _cardinalize_time_unit(bname, abs(rounded_diff))     return rounded_diff, bname\n1: def get_rotation(     img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int ) -> np.ndarray:     matrix = cv2.getAffineTransform(pt1, pt2)     return cv2.warpAffine(img, matrix, (rows, cols))\n2: def equilibrium_index(arr: list[int]) -> int:     total_sum = sum(arr)     left_sum = 0      for i, value in enumerate(arr):         total_sum -= value         if left_sum == total_sum:             return i         left_sum += value      return -1", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef _suitable_minimum_unit(min_unit, suppress):\n    if min_unit in suppress:\n        for unit in Unit:\n            if unit > min_unit and unit not in suppress:\n                return unit\n\n        raise ValueError(\n            \"Minimum unit is suppressed and no suitable replacement was found\"\n        )\n\n    return min_unit", "output": "Return a minimum unit suitable that is not suppressed."}
{"task": "repair", "input": "fix bug:\ndef wiggle_sort(nums):\n    \"\"\"Perform Wiggle Sort.\"\"\"\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]", "output": "def wiggle_sort(nums: list) -> list:\n    \"\"\"\n    Python implementation of wiggle.\n    Example:\n    >>> wiggle_sort([0, 5, 3, 2, 2])\n    [0, 5, 2, 3, 2]\n    >>> wiggle_sort([])\n    []\n    >>> wiggle_sort([-2, -5, -45])\n    [-45, -2, -5]\n    >>> wiggle_sort([-2.1, -5.68, -45.11])\n    [-45.11, -2.1, -5.68]\n    \"\"\"\n    for i, _ in enumerate(nums):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\n    return nums"}
{"task": "search", "input": "search code:\nIf *filename.ext* exists, it will be moved to *filename.1.ext*,\n\nChoices:\n0: def rotate_file(filename, *, keep: int = 5):     if keep < 1:         raise ValueError(f'expected \"keep\" to be >=1, not {keep}')     if not os.path.exists(filename):         return     if not os.path.isfile(filename):         raise ValueError(f'expected {filename} to be a file')      fn_root, fn_ext = os.path.splitext(filename)     kept_names = []     for i in range(1, keep + 1):         if fn_ext:             kept_names.append(f'{fn_root}.{i}{fn_ext}')         else:             kept_names.append(f'{fn_root}.{i}')      fns = [filename] + kept_names     for orig_name, kept_name in reversed(list(zip(fns, fns[1:]))):         if not os.path.exists(orig_name):             continue         os.rename(orig_name, kept_name)      if os.path.exists(kept_names[-1]):         os.remove(kept_names[-1])      return\n1: def get_module_callables(mod, ignore=None):     if isinstance(mod, str):         mod = sys.modules[mod]     types, funcs = {}, {}     for attr_name in dir(mod):         if ignore and ignore(attr_name):             continue         try:             attr = getattr(mod, attr_name)         except Exception:             continue         try:             attr_mod_name = attr.__module__         except AttributeError:             continue         if attr_mod_name != mod.__name__:             continue         if isinstance(attr, type):             types[attr_name] = attr         elif callable(attr):             funcs[attr_name] = attr     return types, funcs\n2: def xnor_gate(input_1: int, input_2: int) -> int:     return 1 if input_1 == input_2 else 0", "output": "0"}
{"task": "detection", "input": "classify code:\ndef left_shift(data):\n    \"\"\"\n    >>> left_shift(\"0123456789\")\n    '1234567890'\n    \"\"\"\n    return data[1:] + data[0]", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []", "output": "def two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []"}
{"task": "detection", "input": "classify code:\ndef calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef chain(number: int) -> bool:\n\n    if CHAINS[number - 1] is not None:\n        return CHAINS[number - 1]  # type: ignore[return-value]\n\n    number_chain = chain(next_number(number))\n    CHAINS[number - 1] = number_chain\n\n    while number < 10000000:\n        CHAINS[number - 1] = number_chain\n        number *= 10\n\n    return number_chain", "output": "The function generates the chain of numbers until the next number is 1 or 89."}
{"task": "search", "input": "search code:\nConvert an IPv4 address to its decimal representation.\n\nChoices:\n0: def ipv4_to_decimal(ipv4_address: str) -> int:      octets = [int(octet) for octet in ipv4_address.split(\".\")]     if len(octets) != 4:         raise ValueError(\"Invalid IPv4 address format\")      decimal_ipv4 = 0     for octet in octets:         if not 0 <= octet <= 255:             raise ValueError(f\"Invalid IPv4 octet {octet}\")  # noqa: EM102         decimal_ipv4 = (decimal_ipv4 << 8) + int(octet)      return decimal_ipv4\n1: def compute_nums(n: int) -> list[int]:     if not isinstance(n, int):         raise ValueError(\"n must be an integer\")     if n <= 0:         raise ValueError(\"n must be >= 0\")      list_nums = []     for num in range(len(odd_composites)):         i = 0         while 2 * i * i <= odd_composites[num]:             rem = odd_composites[num] - 2 * i * i             if is_prime(rem):                 break             i += 1         else:             list_nums.append(odd_composites[num])             if len(list_nums) == n:                 return list_nums      return []\n2: def triangle(     vertex1: tuple[float, float],     vertex2: tuple[float, float],     vertex3: tuple[float, float],     depth: int, ) -> None:     my_pen.up()     my_pen.goto(vertex1[0], vertex1[1])     my_pen.down()     my_pen.goto(vertex2[0], vertex2[1])     my_pen.goto(vertex3[0], vertex3[1])     my_pen.goto(vertex1[0], vertex1[1])      if depth == 0:         return      triangle(vertex1, get_mid(vertex1, vertex2), get_mid(vertex1, vertex3), depth - 1)     triangle(vertex2, get_mid(vertex1, vertex2), get_mid(vertex2, vertex3), depth - 1)     triangle(vertex3, get_mid(vertex3, vertex2), get_mid(vertex1, vertex3), depth - 1)", "output": "0"}
{"task": "search", "input": "search code:\nReturn an iterator over the last *n* items of *iterable*.\n\nChoices:\n0: def solution(n: int = 100) -> int:      sum_cubes = (n * (n + 1) // 2) ** 2     sum_squares = n * (n + 1) * (2 * n + 1) // 6     return sum_cubes - sum_squares\n1: def split(string: str, separator: str = \" \") -> list:      split_words = []      last_index = 0     for index, char in enumerate(string):         if char == separator:             split_words.append(string[last_index:index])             last_index = index + 1         if index + 1 == len(string):             split_words.append(string[last_index : index + 1])     return split_words\n2: def tail(n, iterable):     try:         size = len(iterable)     except TypeError:         return iter(deque(iterable, maxlen=n))     else:         return islice(iterable, max(0, size - n), None)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef surface_area_cube(side_length: Union[int, float]) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * pow(side_length, 2)\r", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5", "output": "def standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5"}
{"task": "summary", "input": "summarize code:\ndef split(src, sep=None, maxsplit=None):\n    return list(split_iter(src, sep, maxsplit))", "output": "Splits an iterable based on a separator. Like :meth:`str.split`,"}
{"task": "repair", "input": "fix bug:\ndef calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "def calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    xmulti = []\n    zmulti = []\n    z = 3\n    x = 5\n    temp = 1\n    while True:\n        result = z * temp\n        if result < n:\n            zmulti.append(result)\n            temp += 1\n        else:\n            temp = 1\n            break\n    while True:\n        result = x * temp\n        if result < n:\n            xmulti.append(result)\n            temp += 1\n        else:\n            break\n    collection = list(set(xmulti + zmulti))\n    return sum(collection)", "output": "Returns the sum of all the multiples of 3 or 5 below n."}
{"task": "search", "input": "search code:\nAttempt to solve a sequence of grids. Report results.\n\nChoices:\n0: def solution(n: int = 100) -> int:      sum_cubes = (n * (n + 1) // 2) ** 2     sum_squares = n * (n + 1) * (2 * n + 1) // 6     return sum_cubes - sum_squares\n1: def main() -> None:     trees = {\"zero\": Node(0), \"seven\": make_tree_seven(), \"nine\": make_tree_nine()}     for name, tree in trees.items():         print(f\"      The {name} tree: {tuple(tree)}\")         # (0,)         # (4, 2, 5, 1, 6, 3, 7)         # (7, 4, 8, 2, 5, 9, 1, 3, 6)         print(f\"Mirror of {name} tree: {tuple(tree.mirror())}\")\n2: def solve_all(grids, name=\"\", showif=0.0):      def time_solve(grid):         start = time.monotonic()         values = solve(grid)         t = time.monotonic() - start         ## Display puzzles that take long enough         if showif is not None and t > showif:             display(grid_values(grid))             if values:                 display(values)             print(f\"({t:.5f} seconds)\\n\")         return (t, solved(values))      times, results = zip(*[time_solve(grid) for grid in grids])     if (n := len(grids)) > 1:         print(             \"Solved %d of %d %s puzzles (avg %.2f secs (%d Hz), max %.2f secs).\"  # noqa: UP031             % (sum(results), n, name, sum(times) / n, n / sum(times), max(times))         )", "output": "2"}
{"task": "detection", "input": "classify code:\ndef minimum_cost_path(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef dp_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Dynamic programming matching algorithm.\n\n    | Time complexity: O(\\|text\\| * \\|pattern\\|)\n    | Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]", "output": "def dp_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Dynamic programming matching algorithm.\n\n    | Time complexity: O(\\|text\\| * \\|pattern\\|)\n    | Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    words_file_path = os.path.join(script_dir, \"words.txt\")\n\n    words = \"\"\n    with open(words_file_path) as f:\n        words = f.readline()\n\n    words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]\n    words = [\n        word\n        for word in [sum(ord(x) - 64 for x in word) for word in words]\n        if word in TRIANGULAR_NUMBERS\n    ]\n    return len(words)", "output": "Finds the amount of triangular words in the words file."}
{"task": "search", "input": "search code:\nReturns the largest palindrome made from the product of two 3-digit\n\nChoices:\n0: def logical_right_shift(number: int, shift_amount: int) -> str:     if number < 0 or shift_amount < 0:         raise ValueError(\"both inputs must be positive integers\")      binary_number = str(bin(number))[2:]     if shift_amount >= len(binary_number):         return \"0b0\"     shifted_binary_number = binary_number[: len(binary_number) - shift_amount]     return \"0b\" + shifted_binary_number\n1: def solution(n: int = 998001) -> int:      # fetches the next number     for number in range(n - 1, 9999, -1):         str_number = str(number)          # checks whether 'str_number' is a palindrome.         if str_number == str_number[::-1]:             divisor = 999              # if 'number' is a product of two 3-digit numbers             # then number is the answer otherwise fetch next number.             while divisor != 99:                 if (number % divisor == 0) and (len(str(number // divisor)) == 3.0):                     return number                 divisor -= 1     raise ValueError(\"That number is larger than our acceptable range.\")\n2: def crossover(parent_1: str, parent_2: str) -> tuple[str, str]:     random_slice = random.randint(0, len(parent_1) - 1)     child_1 = parent_1[:random_slice] + parent_2[random_slice:]     child_2 = parent_2[:random_slice] + parent_1[random_slice:]     return (child_1, child_2)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:\n\n    if len(points) <= 2:\n        # There is no convex hull\n        raise ValueError(\"graham_scan: argument must contain more than 3 points.\")\n    if len(points) == 3:\n        return points\n    # find the lowest and the most left point\n    minidx = 0\n    miny, minx = maxsize, maxsize\n    for i, point in enumerate(points):\n        x = point[0]\n        y = point[1]\n        if y < miny:\n            miny = y\n            minx = x\n            minidx = i\n        if y == miny and x < minx:\n            minx = x\n            minidx = i\n\n    # remove the lowest and the most left point from points for preparing for sort\n    points.pop(minidx)\n\n    sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))\n    # This insert actually costs complexity,\n    # and you should instead add (minx, miny) into stack later.\n    # I'm using insert just for easy understanding.\n    sorted_points.insert(0, (minx, miny))\n\n    stack: deque[tuple[int, int]] = deque()\n    stack.append(sorted_points[0])\n    stack.append(sorted_points[1])\n    stack.append(sorted_points[2])\n    # The first 3 points lines are towards the left because we sort them by their angle\n    # from minx, miny.\n    current_direction = Direction.left\n\n    for i in range(3, len(sorted_points)):\n        while True:\n            starting = stack[-2]\n            via = stack[-1]\n            target = sorted_points[i]\n            next_direction = check_direction(starting, via, target)\n\n            if next_direction == Direction.left:\n                current_direction = Direction.left\n                break\n            if next_direction == Direction.straight:\n                if current_direction == Direction.left:\n                    # We keep current_direction as left.\n                    # Because if the straight line keeps as straight,\n                    # we want to know if this straight line is towards left.\n                    break\n                elif current_direction == Direction.right:\n                    # If the straight line is towards right,\n                    # every previous points on that straight line is not convex hull.\n                    stack.pop()\n            if next_direction == Direction.right:\n                stack.pop()\n        stack.append(sorted_points[i])\n    return list(stack)", "output": "Pure implementation of graham scan algorithm in Python"}
{"task": "search", "input": "search code:\nEliminate all the other values (except d) from values[s] and propagate.\n\nChoices:\n0: def solution(num_terms: int = 60, max_start: int = 1000000) -> int:     return sum(1 for i in range(1, max_start) if chain_length(i) == num_terms)\n1: def norm_squared(vector: ndarray) -> float:     return np.dot(vector, vector)\n2: def assign(values, s, d):     other_values = values[s].replace(d, \"\")     if all(eliminate(values, s, d2) for d2 in other_values):         return values     else:         return False", "output": "2"}
{"task": "detection", "input": "classify code:\ndef recur_fibo(n):\n    if n <= 1:\n        return n\n    else:\n        (recur_fibo(n - 1) + recur_fibo(n - 2))", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef find_negative_index(array: list[int]) -> int:\n    \"\"\"\n    Find the smallest negative index\n\n    >>> find_negative_index([0,0,0,0])\n    4\n    >>> find_negative_index([4,3,2,-1])\n    3\n    >>> find_negative_index([1,0,-1,-10])\n    2\n    >>> find_negative_index([0,0,0,-1])\n    3\n    >>> find_negative_index([11,8,7,-3,-5,-9])\n    3\n    >>> find_negative_index([-1,-1,-2,-3])\n    0\n    >>> find_negative_index([5,1,0])\n    3\n    >>> find_negative_index([-5,-5,-5])\n    0\n    >>> find_negative_index([0])\n    1\n    >>> find_negative_index([])\n    0\n    \"\"\"\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)", "output": "def find_negative_index(array: list[int]) -> int:\n    \"\"\"\n    Find the smallest negative index\n\n    >>> find_negative_index([0,0,0,0])\n    4\n    >>> find_negative_index([4,3,2,-1])\n    3\n    >>> find_negative_index([1,0,-1,-10])\n    2\n    >>> find_negative_index([0,0,0,-1])\n    3\n    >>> find_negative_index([11,8,7,-3,-5,-9])\n    3\n    >>> find_negative_index([-1,-1,-2,-3])\n    0\n    >>> find_negative_index([5,1,0])\n    3\n    >>> find_negative_index([-5,-5,-5])\n    0\n    >>> find_negative_index([0])\n    1\n    >>> find_negative_index([])\n    0\n    \"\"\"\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)"}
{"task": "summary", "input": "summarize code:\ndef solution(ceiling: int = 1_000_000) -> int:\n    primes = prime_sieve(ceiling)\n    length = 0\n    largest = 0\n\n    for i in range(len(primes)):\n        for j in range(i + length, len(primes)):\n            sol = sum(primes[i:j])\n            if sol >= ceiling:\n                break\n\n            if sol in primes:\n                length = j - i\n                largest = sol\n\n    return largest", "output": "Returns the biggest prime, below the celing, that can be written as the sum"}
{"task": "repair", "input": "fix bug:\ndef calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "def calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)"}
{"task": "search", "input": "search code:\nReturns a list of *count* chunks, each with *size* elements,\n\nChoices:\n0: def solution(n: int = 10000) -> int:     total = sum(         i         for i in range(1, n)         if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i     )     return total\n1: def chunked(src, size, count=None, **kw):     chunk_iter = chunked_iter(src, size, **kw)     if count is None:         return list(chunk_iter)     else:         return list(itertools.islice(chunk_iter, count))\n2: def get_all(type_obj, include_subtypes=True):     # TODO: old-style classes     if not isinstance(type_obj, type):         raise TypeError('expected a type, not %r' % type_obj)     try:         type_is_tracked = gc.is_tracked(type_obj)     except AttributeError:         type_is_tracked = False  # Python 2.6 and below don't get the speedup     if type_is_tracked:         to_check = gc.get_referrers(type_obj)     else:         to_check = gc.get_objects()      if include_subtypes:         ret = [x for x in to_check if isinstance(x, type_obj)]     else:         ret = [x for x in to_check if type(x) is type_obj]     return ret", "output": "1"}
{"task": "detection", "input": "classify code:\ndef selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef make_points(a, b, h):\n    x = a + h\n    while x < (b - h):\n        yield x\n        x = x + h", "output": "def make_points(a, b, h):\n    \"\"\"\n    Generates points between 'a' and 'b' with step size 'h', excluding the end points.\n    Args:\n        a (float): Start value\n        b (float): End value\n        h (float): Step size\n    Examples:\n    >>> list(make_points(0, 10, 2.5))\n    [2.5, 5.0, 7.5]\n\n    >>> list(make_points(0, 10, 2))\n    [2, 4, 6, 8]\n\n    >>> list(make_points(1, 21, 5))\n    [6, 11, 16]\n\n    >>> list(make_points(1, 5, 2))\n    [3]\n\n    >>> list(make_points(1, 4, 3))\n    []\n    \"\"\"\n    x = a + h\n    while x <= (b - h):\n        yield x\n        x = x + h"}
{"task": "detection", "input": "classify code:\ndef list_truncated_nums(n: int) -> list[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef can_string_be_rearranged_as_palindrome(input_str: str = \"\") -> bool:\n    if len(input_str) == 0:\n        return True\n    lower_case_input_str = input_str.replace(\" \", \"\").lower()\n    # character_freq_dict: Stores the frequency of every character in the input string\n    character_freq_dict: dict[str, int] = {}\n\n    for character in lower_case_input_str:\n        character_freq_dict[character] = character_freq_dict.get(character, 0) + 1\n    odd_char = 0\n\n    for character_count in character_freq_dict.values():\n        if character_count % 2:\n            odd_char += 1\n    return not odd_char > 1", "output": "A Palindrome is a String that reads the same forward as it does backwards."}
{"task": "search", "input": "search code:\nDivide a number of bytes into x partitions.\n\nChoices:\n0: def solution(length: int = 50) -> int:      ways_number = [1] * (length + 1)      for row_length in range(3, length + 1):         for block_length in range(3, row_length + 1):             for block_start in range(row_length - block_length):                 ways_number[row_length] += ways_number[                     row_length - block_start - block_length - 1                 ]              ways_number[row_length] += 1      return ways_number[length]\n1: def runge_kutta_gills(     func: Callable[[float, float], float],     x_initial: float,     y_initial: float,     step_size: float,     x_final: float, ) -> np.ndarray:     if x_initial >= x_final:         raise ValueError(             \"The final value of x must be greater than initial value of x.\"         )      if step_size <= 0:         raise ValueError(\"Step size must be positive.\")      n = int((x_final - x_initial) / step_size)     y = np.zeros(n + 1)     y[0] = y_initial     for i in range(n):         k1 = step_size * func(x_initial, y[i])         k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)         k3 = step_size * func(             x_initial + step_size / 2,             y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,         )         k4 = step_size * func(             x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3         )          y[i + 1] = y[i] + (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4) / 6         x_initial += step_size     return y\n2: def allocation_num(number_of_bytes: int, partitions: int) -> list[str]:     if partitions <= 0:         raise ValueError(\"partitions must be a positive number!\")     if partitions > number_of_bytes:         raise ValueError(\"partitions can not > number_of_bytes!\")     bytes_per_partition = number_of_bytes // partitions     allocation_list = []     for i in range(partitions):         start_bytes = i * bytes_per_partition + 1         end_bytes = (             number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition         )         allocation_list.append(f\"{start_bytes}-{end_bytes}\")     return allocation_list", "output": "2"}
{"task": "search", "input": "search code:\nCalculates Î² = v/c, the given velocity as a fraction of c\n\nChoices:\n0: def beta(velocity: float) -> float:     if velocity > c:         raise ValueError(\"Speed must not exceed light speed 299,792,458 [m/s]!\")     elif velocity < 1:         # Usually the speed should be much higher than 1 (c order of magnitude)         raise ValueError(\"Speed must be greater than or equal to 1!\")      return velocity / c\n1: def shuffled(seq):     seq = list(seq)     random.shuffle(seq)     return seq\n2: def evaluate_recursive(expression: list[str]):      op = expression.pop(0)     if is_operand(op):         return int(op)      operation = operators[op]      a = evaluate_recursive(expression)     b = evaluate_recursive(expression)     return operation(a, b)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef is_ip_v4_address_valid(ip: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.256.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"255.256.0.256\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.05\")\n    False\n    \"\"\"\n    octets = ip.split(\".\")\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        if not octet.isdigit():\n            return False\n\n        number = int(octet)\n        if len(str(number)) != len(octet):\n            return False\n\n        if not 0 <= number <= 255:\n            return False\n\n    return True", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef spiral_traversal(matrix: list[list]) -> list[int]:\n    \"\"\"\n    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n    Example:\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    Algorithm:\n        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n                output of [step 2])\n        Step 2. Now perform matrix's Transpose operation (Change rows to column\n                and vice versa) and reverse the resultant matrix.\n        Step 3. Pass the output of [2nd step], to same recursive function till\n                base case hits.\n    Dry Run:\n    Stage 1.\n    [1, 2, 3, 4] +   spiral_traversal([\n        [8, 12], [7, 11], [6, 10], [5, 9]]\n     ])\n    Stage 2.\n    [1, 2, 3, 4, 8, 12] + spiral_traversal([\n        [11, 10, 9], [7, 6, 5]\n    ])\n    Stage 3.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 4.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 5.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\n    Stage 6.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])\n    \"\"\"\n    if matrix:\n        return list(matrix.pop(0)) + spiral_traversal(\n            [list(row) for row in zip(*matrix)][::-1]\n        )\n    else:\n        return []", "output": "def spiral_traversal(matrix: list[list]) -> list[int]:\n    \"\"\"\n    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n    Example:\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    Algorithm:\n        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n                output of [step 2])\n        Step 2. Now perform matrix's Transpose operation (Change rows to column\n                and vice versa) and reverse the resultant matrix.\n        Step 3. Pass the output of [2nd step], to same recursive function till\n                base case hits.\n    Dry Run:\n    Stage 1.\n    [1, 2, 3, 4] +   spiral_traversal([\n        [8, 12], [7, 11], [6, 10], [5, 9]]\n     ])\n    Stage 2.\n    [1, 2, 3, 4, 8, 12] + spiral_traversal([\n        [11, 10, 9], [7, 6, 5]\n    ])\n    Stage 3.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 4.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 5.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\n    Stage 6.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])\n    \"\"\"\n    if matrix:\n        return list(matrix.pop(0)) + spiral_traversal(\n            [list(row) for row in zip(*matrix)][::-1]\n        )\n    else:\n        return []"}
{"task": "summary", "input": "summarize code:\ndef unique_everseen(iterable, key=None):\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seenset:\n                seenset_add(k)\n                yield element\n        except TypeError:\n            if k not in seenlist:\n                seenlist_add(k)\n                yield element", "output": "Yield unique elements, preserving order."}
{"task": "repair", "input": "fix bug:\ndef scalar_multiply(matrix: List[list], n: int) -> List[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]", "output": "def scalar_multiply(matrix: list[list], n: int) -> list[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]"}
{"task": "detection", "input": "classify code:\ndef solve(nums: list[int], goal: int, depth: int) -> bool:\n    \"\"\"\n    Checks if nums can have a sum equal to goal, given that length of nums does\n    not exceed depth.\n\n    >>> solve([1], 2, 2)\n    True\n    >>> solve([1], 2, 0)\n    False\n    \"\"\"\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef invert_matrix(matrix: list[list[float]]) -> list[list[float]]:\n    np_matrix = np.array(matrix)\n\n    try:\n        inv_matrix = np.linalg.inv(np_matrix)\n    except np.linalg.LinAlgError:\n        raise ValueError(\"Matrix is not invertible\")\n\n    return inv_matrix.tolist()", "output": "Returns the inverse of a square matrix using NumPy."}
{"task": "search", "input": "search code:\nConvert a Decimal Number to an Octal Number.\n\nChoices:\n0: def decimal_to_octal(num: int) -> str:     octal = 0     counter = 0     while num > 0:         remainder = num % 8         octal = octal + (remainder * math.floor(math.pow(10, counter)))         counter += 1         num = math.floor(num / 8)  # basically /= 8 without remainder if any         # This formatting removes trailing '.0' from `octal`.     return f\"0o{int(octal)}\"\n1: def dpll_algorithm(     clauses: list[Clause], symbols: list[str], model: dict[str, bool | None] ) -> tuple[bool | None, dict[str, bool | None] | None]:     check_clause_all_true = True     for clause in clauses:         clause_check = clause.evaluate(model)         if clause_check is False:             return False, None         elif clause_check is None:             check_clause_all_true = False             continue      if check_clause_all_true:         return True, model      try:         pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)     except RecursionError:         print(\"raises a RecursionError and is\")         return None, {}     p = None     if len(pure_symbols) > 0:         p, value = pure_symbols[0], assignment[pure_symbols[0]]      if p:         tmp_model = model         tmp_model[p] = value         tmp_symbols = list(symbols)         if p in tmp_symbols:             tmp_symbols.remove(p)         return dpll_algorithm(clauses, tmp_symbols, tmp_model)      unit_symbols, assignment = find_unit_clauses(clauses, model)     p = None     if len(unit_symbols) > 0:         p, value = unit_symbols[0], assignment[unit_symbols[0]]     if p:         tmp_model = model         tmp_model[p] = value         tmp_symbols = list(symbols)         if p in tmp_symbols:             tmp_symbols.remove(p)         return dpll_algorithm(clauses, tmp_symbols, tmp_model)     p = symbols[0]     rest = symbols[1:]     tmp1, tmp2 = model, model     tmp1[p], tmp2[p] = True, False      return dpll_algorithm(clauses, rest, tmp1) or dpll_algorithm(clauses, rest, tmp2)\n2: def solution(numerator: int = 1, digit: int = 1000) -> int:     the_digit = 1     longest_list_length = 0      for divide_by_number in range(numerator, digit + 1):         has_been_divided: list[int] = []         now_divide = numerator         for _ in range(1, digit + 1):             if now_divide in has_been_divided:                 if longest_list_length < len(has_been_divided):                     longest_list_length = len(has_been_divided)                     the_digit = divide_by_number             else:                 has_been_divided.append(now_divide)                 now_divide = now_divide * 10 % divide_by_number      return the_digit", "output": "0"}
{"task": "search", "input": "search code:\nCalculate a Lorentz transformation for movement in the x direction given a\n\nChoices:\n0: def transform(velocity: float, event: np.ndarray | None = None) -> np.ndarray:     # Ensure event is not empty     if event is None:         event = np.array([ct, x, y, z])  # Symbolic four vector     else:         event[0] *= c  # x0 is ct (speed of light * time)      return transformation_matrix(velocity) @ event\n1: def solution(pence: int = 200) -> int:     coins = [1, 2, 5, 10, 20, 50, 100, 200]     number_of_ways = [0] * (pence + 1)     number_of_ways[0] = 1  # base case: 1 way to make 0 pence      for coin in coins:         for i in range(coin, pence + 1, 1):             number_of_ways[i] += number_of_ways[i - coin]     return number_of_ways[pence]\n2: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))", "output": "def num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))"}
{"task": "detection", "input": "classify code:\ndef solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef cachedmethod(cache, scoped=True, typed=False, key=None):\n    def cached_method_decorator(func):\n        return CachedMethod(func, cache, scoped=scoped, typed=typed, key=key)\n    return cached_method_decorator", "output": "Similar to :func:`cached`, ``cachedmethod`` is used to cache"}
{"task": "detection", "input": "classify code:\ndef find_longest_chain(chain: list[int], max_num: int) -> int:\n    \"\"\"\n    Finds the smallest element of longest chain\n\n    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n    6\n    \"\"\"\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 10000) -> int:\n    total = sum(\n        i\n        for i in range(1, n)\n        if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i\n    )\n    return total", "output": "Returns the sum of all the amicable numbers under n."}
{"task": "search", "input": "search code:\nReturn a binary tree with 7 nodes that looks like this:\n\nChoices:\n0: def make_tree_seven() -> Node:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     tree.right.left = Node(6)     tree.right.right = Node(7)     return tree\n1: def quote_path_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])     return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t                      for t in text])\n2: def compress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         add_key_to_lexicon(lexicon, curr_string, index, last_match_id)         index += 1         curr_string = \"\"      while curr_string != \"\" and curr_string not in lexicon:         curr_string += \"0\"      if curr_string != \"\":         last_match_id = lexicon[curr_string]         result += last_match_id      return result", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef recursive_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Recursive matching algorithm.\n\n    | Time complexity: O(2^(\\|text\\| + \\|pattern\\|))\n    | Space complexity: Recursion depth is O(\\|text\\| + \\|pattern\\|).\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> recursive_match('abc', 'a.c')\n    True\n    >>> recursive_match('abc', 'af*.c')\n    True\n    >>> recursive_match('abc', 'a.c*')\n    True\n    >>> recursive_match('abc', 'a.c*d')\n    False\n    >>> recursive_match('aa', '.*')\n    True\n    \"\"\"\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False", "output": "def recursive_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Recursive matching algorithm.\n\n    | Time complexity: O(2^(\\|text\\| + \\|pattern\\|))\n    | Space complexity: Recursion depth is O(\\|text\\| + \\|pattern\\|).\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> recursive_match('abc', 'a.c')\n    True\n    >>> recursive_match('abc', 'af*.c')\n    True\n    >>> recursive_match('abc', 'a.c*')\n    True\n    >>> recursive_match('abc', 'a.c*d')\n    False\n    >>> recursive_match('aa', '.*')\n    True\n    \"\"\"\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False"}
{"task": "repair", "input": "fix bug:\ndef calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "def calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]"}
{"task": "detection", "input": "classify code:\ndef get_valid_pos(position: Tuple[int], n: int) -> List[Tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "BUGGY"}
{"task": "search", "input": "search code:\nthis is a recursive function for get all factors of number\n\nChoices:\n0: def largest_square_area_in_matrix_top_down_approch_with_dp(     rows: int, cols: int, mat: list[list[int]] ) -> int:      def update_area_of_max_square_using_dp_array(         row: int, col: int, dp_array: list[list[int]]     ) -> int:         if row >= rows or col >= cols:             return 0         if dp_array[row][col] != -1:             return dp_array[row][col]          right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)         diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)         down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)          if mat[row][col]:             sub_problem_sol = 1 + min([right, diagonal, down])             largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)             dp_array[row][col] = sub_problem_sol             return sub_problem_sol         else:             return 0      largest_square_area = [0]     dp_array = [[-1] * cols for _ in range(rows)]     update_area_of_max_square_using_dp_array(0, 0, dp_array)      return largest_square_area[0]\n1: def always_reversible(iterable):     try:         return reversed(iterable)     except TypeError:         return reversed(list(iterable))\n2: def get_factors(     number: int, factors: Counter | None = None, factor: int = 2 ) -> Counter:      match number:         case int(number) if number == 1:             return Counter({1: 1})         case int(num) if number > 0:             number = num         case _:             raise TypeError(\"number must be integer and greater than zero\")      factors = factors or Counter()      if number == factor:  # break condition         # all numbers are factors of itself         factors[factor] += 1         return factors      if number % factor > 0:         # if it is greater than zero         # so it is not a factor of number and we check next number         return get_factors(number, factors, factor + 1)      factors[factor] += 1     # else we update factors (that is Counter(dict-like) type) and check again     return get_factors(number // factor, factors, factor)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solve(board: list[list[int]], row: int) -> bool:\n    if row >= len(board):\n        solution.append(board)\n        printboard(board)\n        print()\n        return True\n    for i in range(len(board)):\n        if is_safe(board, row, i):\n            board[row][i] = 1\n            solve(board, row + 1)\n            board[row][i] = 0\n    return False", "output": "This function creates a state space tree and calls the safe function until it"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 998001) -> int:\n\n    # fetches the next number\n    for number in range(n - 1, 9999, -1):\n        str_number = str(number)\n\n        # checks whether 'str_number' is a palindrome.\n        if str_number == str_number[::-1]:\n            divisor = 999\n\n            # if 'number' is a product of two 3-digit numbers\n            # then number is the answer otherwise fetch next number.\n            while divisor != 99:\n                if (number % divisor == 0) and (len(str(number // divisor)) == 3.0):\n                    return number\n                divisor -= 1\n    raise ValueError(\"That number is larger than our acceptable range.\")", "output": "Returns the largest palindrome made from the product of two 3-digit"}
{"task": "detection", "input": "classify code:\ndef median(nums):\n    \"\"\"\n    Find median of a list of numbers.\n\n    >>> median([0])\n    0\n    >>> median([4,1,3,2])\n    2.5\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    med = None\n    if len(sorted_list) % 2 == 0:\n        mid_index_1 = len(sorted_list) // 2\n        mid_index_2 = (len(sorted_list) // 2) - 1\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n    else:\n        mid_index = (len(sorted_list) - 1) // 2\n        med = sorted_list[mid_index]\n    return med", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\n    \"\"\"\n    Convert molarity to normality.\n      Volume is taken in litres.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n      >>> molarity_to_normality(2, 3.1, 0.31)\n      20\n      >>> molarity_to_normality(4, 11.4, 5.7)\n      8\n    \"\"\"\n    return round(float(moles / volume) * nfactor)", "output": "def molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\n    \"\"\"\n    Convert molarity to normality.\n      Volume is taken in litres.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n      >>> molarity_to_normality(2, 3.1, 0.31)\n      20\n      >>> molarity_to_normality(4, 11.4, 5.7)\n      8\n    \"\"\"\n    return round(float(moles / volume) * nfactor)"}
{"task": "search", "input": "search code:\nSaves the image of anime character\n\nChoices:\n0: def match_word_pattern(pattern: str, input_string: str) -> bool:      def backtrack(pattern_index: int, str_index: int) -> bool:         if pattern_index == len(pattern) and str_index == len(input_string):             return True         if pattern_index == len(pattern) or str_index == len(input_string):             return False         char = pattern[pattern_index]         if char in pattern_map:             mapped_str = pattern_map[char]             if input_string.startswith(mapped_str, str_index):                 return backtrack(pattern_index + 1, str_index + len(mapped_str))             else:                 return False         for end in range(str_index + 1, len(input_string) + 1):             substr = input_string[str_index:end]             if substr in str_map:                 continue             pattern_map[char] = substr             str_map[substr] = char             if backtrack(pattern_index + 1, end):                 return True             del pattern_map[char]             del str_map[substr]         return False      pattern_map: dict[str, str] = {}     str_map: dict[str, str] = {}     return backtrack(0, 0)\n1: def save_image(image_url: str, image_title: str) -> None:     image = httpx.get(image_url, headers=headers, timeout=10)     with open(image_title, \"wb\") as file:         file.write(image.content)\n2: def standardization(data: list, ndigits: int = 3) -> list:     # variables for calculation     mu = mean(data)     sigma = stdev(data)     # standardize data     return [round((x - mu) / (sigma), ndigits) for x in data]", "output": "1"}
{"task": "search", "input": "search code:\nReturn True if it's possible to search the word suffix\n\nChoices:\n0: def encipher(message: str, cipher_map: dict[str, str]) -> str:     return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())\n1: def encode(plaintext: str, key: str) -> str:      table = generate_table(key)     plaintext = prepare_input(plaintext)     ciphertext = \"\"      for char1, char2 in chunker(plaintext, 2):         row1, col1 = divmod(table.index(char1), 5)         row2, col2 = divmod(table.index(char2), 5)          if row1 == row2:             ciphertext += table[row1 * 5 + (col1 + 1) % 5]             ciphertext += table[row2 * 5 + (col2 + 1) % 5]         elif col1 == col2:             ciphertext += table[((row1 + 1) % 5) * 5 + col1]             ciphertext += table[((row2 + 1) % 5) * 5 + col2]         else:  # rectangle             ciphertext += table[row1 * 5 + col2]             ciphertext += table[row2 * 5 + col1]      return ciphertext\n2: def exits_word(     board: list[list[str]],     word: str,     row: int,     column: int,     word_index: int,     visited_points_set: set[int], ) -> bool:      if board[row][column] != word[word_index]:         return False      if word_index == len(word) - 1:         return True      traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]     len_board = len(board)     len_board_column = len(board[0])     for direction in traverts_directions:         next_i = row + direction[0]         next_j = column + direction[1]         if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):             continue          key = get_point_key(len_board, len_board_column, next_i, next_j)         if key in visited_points_set:             continue          visited_points_set.add(key)         if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):             return True          visited_points_set.remove(key)      return False", "output": "2"}
{"task": "detection", "input": "classify code:\ndef check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - ord(\"a\")] = True\n    return all(flag)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef _calculate(days: int, absent: int, late: int) -> int:\n\n    # if we are absent twice, or late 3 consecutive days,\n    # no further prize strings are possible\n    if late == 3 or absent == 2:\n        return 0\n\n    # if we have no days left, and have not failed any other rules,\n    # we have a prize string\n    if days == 0:\n        return 1\n\n    # No easy solution, so now we need to do the recursive calculation\n\n    # First, check if the combination is already in the cache, and\n    # if yes, return the stored value from there since we already\n    # know the number of possible prize strings from this point on\n    key = (days, absent, late)\n    if key in cache:\n        return cache[key]\n\n    # now we calculate the three possible ways that can unfold from\n    # this point on, depending on our attendance today\n\n    # 1) if we are late (but not absent), the \"absent\" counter stays as\n    # it is, but the \"late\" counter increases by one\n    state_late = _calculate(days - 1, absent, late + 1)\n\n    # 2) if we are absent, the \"absent\" counter increases by 1, and the\n    # \"late\" counter resets to 0\n    state_absent = _calculate(days - 1, absent + 1, 0)\n\n    # 3) if we are on time, this resets the \"late\" counter and keeps the\n    # absent counter\n    state_ontime = _calculate(days - 1, absent, 0)\n\n    prizestrings = state_late + state_absent + state_ontime\n\n    cache[key] = prizestrings\n    return prizestrings", "output": "A small helper function for the recursion, mainly to have"}
{"task": "repair", "input": "fix bug:\ndef merge(left, right):\n    \"\"\"\n    >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0][0] < right[0][0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right", "output": "def merge(left, right):\n    \"\"\"\n    >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0][0] < right[0][0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right"}
{"task": "summary", "input": "summarize code:\ndef level_order(root: Node | None) -> Generator[int]:\n\n    if root is None:\n        return\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        yield node.data\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)", "output": "Returns a list of nodes value from a whole binary tree in Level Order Traverse."}
{"task": "repair", "input": "fix bug:\ndef text_to_bits(text, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_to_bits(\"msg\")\n    '011011010111001101100111'\n    \"\"\"\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \"big\"))[2:]\n    return bits.zfill(8 * ((len(bits) + 7) // 8))", "output": "def text_to_bits(text, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_to_bits(\"msg\")\n    '011011010111001101100111'\n    \"\"\"\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \"big\"))[2:]\n    return bits.zfill(8 * ((len(bits) + 7) // 8))"}
{"task": "search", "input": "search code:\nrotations and the index of the original string at ordered rotations list\n\nChoices:\n0: def invert_matrix(matrix: list[list[float]]) -> list[list[float]]:     np_matrix = np.array(matrix)      try:         inv_matrix = np.linalg.inv(np_matrix)     except np.linalg.LinAlgError:         raise ValueError(\"Matrix is not invertible\")      return inv_matrix.tolist()\n1: def bwt_transform(s: str) -> BWTTransformDict:     if not isinstance(s, str):         raise TypeError(\"The parameter s type must be str.\")     if not s:         raise ValueError(\"The parameter s must not be empty.\")      rotations = all_rotations(s)     rotations.sort()  # sort the list of rotations in alphabetically order     # make a string composed of the last char of each rotation     response: BWTTransformDict = {         \"bwt_string\": \"\".join([word[-1] for word in rotations]),         \"idx_original_string\": rotations.index(s),     }     return response\n2: def unit_basis_vector(dimension: int, pos: int) -> Vector:     # precondition     assert isinstance(dimension, int)     assert isinstance(pos, int)     ans = [0] * dimension     ans[pos] = 1     return Vector(ans)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef linear_search(sequence: list, target: int) -> int:\n    \"\"\"A pure Python implementation of a linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return -1", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef generate_large_matrix() -> list[list[int]]:\n    \"\"\"\n    >>> generate_large_matrix() # doctest: +ELLIPSIS\n    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]\n    \"\"\"\n    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]", "output": "def generate_large_matrix() -> list[list[int]]:\n    \"\"\"\n    >>> generate_large_matrix() # doctest: +ELLIPSIS\n    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]\n    \"\"\"\n    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]"}
{"task": "detection", "input": "classify code:\ndef sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value", "output": "CORRECT"}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def calculate_waiting_times(burst_times: list[int]) -> list[int]:     quantum = 2     rem_burst_times = list(burst_times)     waiting_times = [0] * len(burst_times)     t = 0     while True:         done = True         for i, burst_time in enumerate(burst_times):             if rem_burst_times[i] > 0:                 done = False                 if rem_burst_times[i] > quantum:                     t += quantum                     rem_burst_times[i] -= quantum                 else:                     t += rem_burst_times[i]                     waiting_times[i] = t - burst_time                     rem_burst_times[i] = 0         if done is True:             return waiting_times\n1: def windowed_iter(src, size, fill=_UNSET):     tees = itertools.tee(src, size)     if fill is _UNSET:         try:             for i, t in enumerate(tees):                 for _ in range(i):                     next(t)         except StopIteration:             return zip([])         return zip(*tees)      for i, t in enumerate(tees):         for _ in range(i):             try:                 next(t)             except StopIteration:                 continue     return zip_longest(*tees, fillvalue=fill)\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    # number of letters in zero, one, two, ..., nineteen (0 for zero since it's\n    # never said aloud)\n    ones_counts = [0, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6, 6, 8, 8, 7, 7, 9, 8, 8]\n    # number of letters in twenty, thirty, ..., ninety (0 for numbers less than\n    # 20 due to inconsistency in teens)\n    tens_counts = [0, 0, 6, 6, 5, 5, 5, 7, 6, 6]\n\n    count = 0\n\n    for i in range(1, n + 1):\n        if i < 1000:\n            if i >= 100:\n                # add number of letters for \"n hundred\"\n                count += ones_counts[i // 100] + 7\n\n                if i % 100 != 0:\n                    # add number of letters for \"and\" if number is not multiple\n                    # of 100\n                    count += 3\n\n            if 0 < i % 100 < 20:\n                # add number of letters for one, two, three, ..., nineteen\n                # (could be combined with below if not for inconsistency in\n                # teens)\n                count += ones_counts[i % 100]\n            else:\n                # add number of letters for twenty, twenty one, ..., ninety\n                # nine\n                count += ones_counts[i % 10]\n                count += tens_counts[(i % 100 - i % 10) // 10]\n        else:\n            count += ones_counts[i // 1000] + 8\n    return count", "output": "Returns the number of letters used to write all numbers from 1 to n."}
{"task": "detection", "input": "classify code:\ndef is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n    Note: this doesn't check if P and Q are equal, but that's handled by the use of\n    itertools.combinations in the solution function.\n\n    >>> is_right(0, 1, 2, 0)\n    True\n    >>> is_right(1, 0, 2, 2)\n    False\n    \"\"\"\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFlatten an iterable with multiple levels of nesting (e.g., a list of\n\nChoices:\n0: def collapse(iterable, base_type=None, levels=None):     stack = deque()     # Add our first node group, treat the iterable as a single node     stack.appendleft((0, repeat(iterable, 1)))      while stack:         node_group = stack.popleft()         level, nodes = node_group          # Check if beyond max level         if levels is not None and level > levels:             yield from nodes             continue          for node in nodes:             # Check if done iterating             if isinstance(node, (str, bytes)) or (                 (base_type is not None) and isinstance(node, base_type)             ):                 yield node             # Otherwise try to create child nodes             else:                 try:                     tree = iter(node)                 except TypeError:                     yield node                 else:                     # Save our current location                     stack.appendleft(node_group)                     # Append the new child node                     stack.appendleft((level + 1, tree))                     # Break to process child node                     break\n1: def outer_product(func, xs, ys, *args, **kwargs):     ys = tuple(ys)     return batched(         starmap(lambda x, y: func(x, y, *args, **kwargs), product(xs, ys)),         n=len(ys),     )\n2: def binary_tree_count(node_count: int) -> int:     return catalan_number(node_count) * factorial(node_count)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)"}
{"task": "summary", "input": "summarize code:\ndef read_file_binary(file_path: str) -> str:\n    result = \"\"\n    try:\n        with open(file_path, \"rb\") as binary_file:\n            data = binary_file.read()\n        for dat in data:\n            curr_byte = f\"{dat:08b}\"\n            result += curr_byte\n        return result\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()", "output": "Reads given file as bytes and returns them as a long string"}
{"task": "detection", "input": "classify code:\ndef create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nAn implementation of the Monte Carlo method used to find pi.\n\nChoices:\n0: def distinct_combinations(iterable, r):     if r < 0:         raise ValueError('r must be non-negative')     elif r == 0:         yield ()         return     pool = tuple(iterable)     generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]     current_combo = [None] * r     level = 0     while generators:         try:             cur_idx, p = next(generators[-1])         except StopIteration:             generators.pop()             level -= 1             continue         current_combo[level] = p         if level + 1 == r:             yield tuple(current_combo)         else:             generators.append(                 unique_everseen(                     enumerate(pool[cur_idx + 1 :], cur_idx + 1),                     key=itemgetter(1),                 )             )             level += 1\n1: def pi_estimator(iterations: int) -> None:      # A local function to see if a dot lands in the circle.     def is_in_circle(x: float, y: float) -> bool:         distance_from_centre = sqrt((x**2) + (y**2))         # Our circle has a radius of 1, so a distance         # greater than 1 would land outside the circle.         return distance_from_centre <= 1      # The proportion of guesses that landed in the circle     proportion = mean(         int(is_in_circle(uniform(-1.0, 1.0), uniform(-1.0, 1.0)))         for _ in range(iterations)     )     # The ratio of the area for circle to square is pi/4.     pi_estimate = proportion * 4     print(f\"The estimated value of pi is {pi_estimate}\")     print(f\"The numpy value of pi is {pi}\")     print(f\"The total error is {abs(pi - pi_estimate)}\")\n2: def knapsack_with_example_solution(w: int, wt: list, val: list):     if not (isinstance(wt, (list, tuple)) and isinstance(val, (list, tuple))):         raise ValueError(             \"Both the weights and values vectors must be either lists or tuples\"         )      num_items = len(wt)     if num_items != len(val):         msg = (             \"The number of weights must be the same as the number of values.\\n\"             f\"But got {num_items} weights and {len(val)} values\"         )         raise ValueError(msg)     for i in range(num_items):         if not isinstance(wt[i], int):             msg = (                 \"All weights must be integers but got weight of \"                 f\"type {type(wt[i])} at index {i}\"             )             raise TypeError(msg)      optimal_val, dp_table = knapsack(w, wt, val, num_items)     example_optional_set: set = set()     _construct_solution(dp_table, wt, num_items, w, example_optional_set)      return optimal_val, example_optional_set", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef run_maze(\n    maze: list[list[int]],\n    i: int,\n    j: int,\n    destination_row: int,\n    destination_column: int,\n    solutions: list[list[int]],\n) -> bool:\n    size = len(maze)\n    # Final check point.\n    if i == destination_row and j == destination_column and maze[i][j] == 0:\n        solutions[i][j] = 0\n        return True\n\n    lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds\n    upper_flag = (i < size) and (j < size)  # Check upper bounds\n\n    if lower_flag and upper_flag:\n        # check for already visited and block points.\n        block_flag = (solutions[i][j]) and (not maze[i][j])\n        if block_flag:\n            # check visited\n            solutions[i][j] = 0\n\n            # check for directions\n            if (\n                run_maze(maze, i + 1, j, destination_row, destination_column, solutions)\n                or run_maze(\n                    maze, i, j + 1, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i - 1, j, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i, j - 1, destination_row, destination_column, solutions\n                )\n            ):\n                return True\n\n            solutions[i][j] = 1\n            return False\n    return False", "output": "This method is recursive starting from (i, j) and going in one of four directions:"}
{"task": "repair", "input": "fix bug:\ndef moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to pressure.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_pressure(0.82, 3, 300)\n      90\n      >>> moles_to_pressure(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (volume)))", "output": "def moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to pressure.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_pressure(0.82, 3, 300)\n      90\n      >>> moles_to_pressure(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (volume)))"}
{"task": "search", "input": "search code:\nReturns the maximum height that the object reach\n\nChoices:\n0: def max_tasks(tasks_info: list[tuple[int, int]]) -> list[int]:     tasks = sorted(         (             Task(task_id, deadline, reward)             for task_id, (deadline, reward) in enumerate(tasks_info)         ),         key=attrgetter(\"reward\"),         reverse=True,     )     return [task.task_id for i, task in enumerate(tasks, start=1) if task.deadline >= i]\n1: def max_height(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(angle)     return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)\n2: def kth_number(lst: list[int], k: int) -> int:     # pick a pivot and separate into list based on pivot.     pivot = random_pivot(lst)      # partition based on pivot     # linear time     small = [e for e in lst if e < pivot]     big = [e for e in lst if e > pivot]      # if we get lucky, pivot might be the element we want.     # we can easily see this:     # small (elements smaller than k)     # + pivot (kth element)     # + big (elements larger than k)     if len(small) == k - 1:         return pivot     # pivot is in elements bigger than k     elif len(small) < k - 1:         return kth_number(big, k - len(small) - 1)     # pivot is in elements smaller than k     else:         return kth_number(small, k)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef _extract_monotonic(iterator, indices):\n    'Non-decreasing indices, lazily consumed'\n    num_read = 0\n    for index in indices:\n        advance = index - num_read\n        try:\n            value = next(islice(iterator, advance, None))\n        except ValueError:\n            if advance != -1 or index < 0:\n                raise ValueError(f'Invalid index: {index}') from None\n        except StopIteration:\n            raise IndexError(index) from None\n        else:\n            num_read += advance + 1\n        yield value", "output": "Non-decreasing indices, lazily consumed"}
{"task": "repair", "input": "fix bug:\ndef atbash_slow(sequence: str) -> str:\n    \"\"\"\n    >>> atbash_slow(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash_slow(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    output = \"\"\n    for i in sequence:\n        extract = ord(i)\n        if 65 <= extract <= 90:\n            output += chr(155 - extract)\n        elif 97 <= extract <= 122:\n            output += chr(219 - extract)\n        else:\n            output += i\n    return output", "output": "def atbash_slow(sequence: str) -> str:\n    \"\"\"\n    >>> atbash_slow(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash_slow(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    output = \"\"\n    for i in sequence:\n        extract = ord(i)\n        if 65 <= extract <= 90:\n            output += chr(155 - extract)\n        elif 97 <= extract <= 122:\n            output += chr(219 - extract)\n        else:\n            output += i\n    return output"}
{"task": "detection", "input": "classify code:\ndef median(nums: list) -> int | float:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef count_cycle(iterable, n=None):\n    if n is not None:\n        return product(range(n), iterable)\n    seq = tuple(iterable)\n    if not seq:\n        return iter(())\n    counter = count() if n is None else range(n)\n    return zip(repeat_each(counter, len(seq)), cycle(seq))", "output": "Cycle through the items from *iterable* up to *n* times, yielding"}
{"task": "search", "input": "search code:\nReturn the how many times the predicate is true.\n\nChoices:\n0: def quantify(iterable, pred=bool):     return sum(map(pred, iterable))\n1: def find_repeat(     matrix_g: list[list[str]], row: int, column: int, size: int ) -> set[tuple[int, int]]:      column = size - 1 - column     visited = set()     repeated = set()      if (color := matrix_g[column][row]) != \"-\":          def dfs(row_n: int, column_n: int) -> None:             if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:                 return             if (row_n, column_n) in visited:                 return             visited.add((row_n, column_n))             if matrix_g[row_n][column_n] == color:                 repeated.add((row_n, column_n))                 dfs(row_n - 1, column_n)                 dfs(row_n + 1, column_n)                 dfs(row_n, column_n - 1)                 dfs(row_n, column_n + 1)          dfs(column, row)      return repeated\n2: def harshad_numbers_in_base(limit: int, base: int) -> list[str]:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      if limit < 0:         return []      numbers = [         int_to_base(i, base)         for i in range(1, limit)         if i % int(sum_of_digits(i, base), base) == 0     ]      return numbers", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef cyclic_sort(nums: list[int]) -> list[int]:\n    \"\"\"\n    Sorts the input list of n integers from 1 to n in-place\n    using the Cyclic Sort algorithm.\n\n    :param nums: List of n integers from 1 to n to be sorted.\n    :return: The same list sorted in ascending order.\n\n    Time complexity: O(n), where n is the number of integers in the list.\n\n    Examples:\n    >>> cyclic_sort([])\n    []\n    >>> cyclic_sort([3, 5, 2, 1, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums", "output": "def cyclic_sort(nums: list[int]) -> list[int]:\n    \"\"\"\n    Sorts the input list of n integers from 1 to n in-place\n    using the Cyclic Sort algorithm.\n\n    :param nums: List of n integers from 1 to n to be sorted.\n    :return: The same list sorted in ascending order.\n\n    Time complexity: O(n), where n is the number of integers in the list.\n\n    Examples:\n    >>> cyclic_sort([])\n    []\n    >>> cyclic_sort([3, 5, 2, 1, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums"}
{"task": "search", "input": "search code:\nSemi-intelligently converts an English *word* from singular form to\n\nChoices:\n0: def longest_common_subsequence(x: str, y: str):     # find the length of strings      assert x is not None     assert y is not None      m = len(x)     n = len(y)      # declaring the array for storing the dp values     dp = [[0] * (n + 1) for _ in range(m + 1)]      for i in range(1, m + 1):         for j in range(1, n + 1):             match = 1 if x[i - 1] == y[j - 1] else 0              dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)      seq = \"\"     i, j = m, n     while i > 0 and j > 0:         match = 1 if x[i - 1] == y[j - 1] else 0          if dp[i][j] == dp[i - 1][j - 1] + match:             if match == 1:                 seq = x[i - 1] + seq             i -= 1             j -= 1         elif dp[i][j] == dp[i - 1][j]:             i -= 1         else:             j -= 1      return dp[m][n], seq\n1: def pluralize(word):     orig_word, word = word, word.strip().lower()     if not word or word in _IRR_P2S:         return orig_word     irr_plural = _IRR_S2P.get(word)     if irr_plural:         plural = irr_plural     elif word.endswith('y') and word[-2:-1] not in 'aeiou':         plural = word[:-1] + 'ies'     elif word[-1] == 's' or word.endswith('ch') or word.endswith('sh'):         plural = word if word.endswith('es') else word + 'es'     else:         plural = word + 's'     return _match_case(orig_word, plural)\n2: def horn_schunck(     image0: np.ndarray,     image1: np.ndarray,     num_iter: SupportsIndex,     alpha: float | None = None, ) -> tuple[np.ndarray, np.ndarray]:     if alpha is None:         alpha = 0.1      # Initialize flow     horizontal_flow = np.zeros_like(image0)     vertical_flow = np.zeros_like(image0)      # Prepare kernels for the calculation of the derivatives and the average velocity     kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25     kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25     kernel_t = np.array([[1, 1], [1, 1]]) * 0.25     kernel_laplacian = np.array(         [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]     )      # Iteratively refine the flow     for _ in range(num_iter):         warped_image = warp(image0, horizontal_flow, vertical_flow)         derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)         derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)         derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)          avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)         avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)          # This updates the flow as proposed in the paper (Step 12)         update = (             derivative_x * avg_horizontal_velocity             + derivative_y * avg_vertical_velocity             + derivative_t         )         update = update / (alpha**2 + derivative_x**2 + derivative_y**2)          horizontal_flow = avg_horizontal_velocity - derivative_x * update         vertical_flow = avg_vertical_velocity - derivative_y * update      return horizontal_flow, vertical_flow", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef digit_sum(n: int) -> int:\n    return sum(int(digit) for digit in str(n))", "output": "Returns the sum of the digits of the number."}
{"task": "detection", "input": "classify code:\ndef identity(n: int) -> list[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef get_valid_pos(position: Tuple[int], n: int) -> List[Tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "def get_valid_pos(position: tuple[int], n: int) -> list[tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions"}
{"task": "summary", "input": "summarize code:\ndef _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):\n    if max_rev[n] >= 0:\n        return max_rev[n]\n    elif n == 0:\n        return 0\n    else:\n        max_revenue = float(\"-inf\")\n        for i in range(1, n + 1):\n            max_revenue = max(\n                max_revenue,\n                prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),\n            )\n\n        max_rev[n] = max_revenue\n\n    return max_rev[n]", "output": "Constructs a top-down dynamic programming solution for the rod-cutting problem"}
{"task": "search", "input": "search code:\nPrune candidate itemsets that are not frequent.\n\nChoices:\n0: def prune(itemset: list, candidates: list, length: int) -> list:     itemset_counter = Counter(tuple(item) for item in itemset)     pruned = []     for candidate in candidates:         is_subsequence = True         for item in candidate:             item_tuple = tuple(item)             if (                 item_tuple not in itemset_counter                 or itemset_counter[item_tuple] < length - 1             ):                 is_subsequence = False                 break         if is_subsequence:             pruned.append(candidate)     return pruned\n1: def infer_positional_format_args(fstr):     # TODO: memoize     ret, max_anon = '', 0     # look for {: or {! or {. or {[ or {}     start, end, prev_end = 0, 0, 0     for match in _pos_farg_re.finditer(fstr):         start, end, group = match.start(), match.end(), match.group()         if prev_end < start:             ret += fstr[prev_end:start]         prev_end = end         if group == '{{' or group == '}}':             ret += group             continue         ret += f'{{{max_anon}{group[1:]}'         max_anon += 1     ret += fstr[prev_end:]     return ret\n2: def unique_in_window(iterable, n, key=None):     if n <= 0:         raise ValueError('n must be greater than 0')      window = deque(maxlen=n)     counts = Counter()     use_key = key is not None      for item in iterable:         if len(window) == n:             to_discard = window[0]             if counts[to_discard] == 1:                 del counts[to_discard]             else:                 counts[to_discard] -= 1          k = key(item) if use_key else item         if k not in counts:             yield item         counts[k] += 1         window.append(k)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)"}
{"task": "detection", "input": "classify code:\ndef find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef subdict(d, keep=None, drop=None):\n    if keep is None:\n        keep = d.keys()\n    if drop is None:\n        drop = []\n\n    keys = set(keep) - set(drop)\n\n    return type(d)([(k, v) for k, v in d.items() if k in keys])", "output": "Compute the \"subdictionary\" of a dict, *d*."}
{"task": "search", "input": "search code:\nThis function can calculate the Builtin Voltage of a pn junction diode.\n\nChoices:\n0: def builtin_voltage(     donor_conc: float,  # donor concentration     acceptor_conc: float,  # acceptor concentration     intrinsic_conc: float,  # intrinsic concentration ) -> float:      if donor_conc <= 0:         raise ValueError(\"Donor concentration should be positive\")     elif acceptor_conc <= 0:         raise ValueError(\"Acceptor concentration should be positive\")     elif intrinsic_conc <= 0:         raise ValueError(\"Intrinsic concentration should be positive\")     elif donor_conc <= intrinsic_conc:         raise ValueError(             \"Donor concentration should be greater than intrinsic concentration\"         )     elif acceptor_conc <= intrinsic_conc:         raise ValueError(             \"Acceptor concentration should be greater than intrinsic concentration\"         )     else:         return (             Boltzmann             * T             * log((donor_conc * acceptor_conc) / intrinsic_conc**2)             / physical_constants[\"electron volt\"][0]         )\n1: def nand_gate(input_1: int, input_2: int) -> int:     return int(not (input_1 and input_2))\n2: def factorial(num: int) -> int:     fact = 1     for i in range(1, num + 1):         fact *= i     return fact", "output": "0"}
{"task": "detection", "input": "classify code:\ndef modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef make_points(a, b, h):\n    x = a + h\n    while x < (b - h):\n        yield x\n        x = x + h", "output": "def make_points(a, b, h):\n    \"\"\"\n    Generates points between 'a' and 'b' with step size 'h', excluding the end points.\n    Args:\n        a (float): Start value\n        b (float): End value\n        h (float): Step size\n    Examples:\n    >>> list(make_points(0, 10, 2.5))\n    [2.5, 5.0, 7.5]\n\n    >>> list(make_points(0, 10, 2))\n    [2, 4, 6, 8]\n\n    >>> list(make_points(1, 21, 5))\n    [6, 11, 16]\n\n    >>> list(make_points(1, 5, 2))\n    [3]\n\n    >>> list(make_points(1, 4, 3))\n    []\n    \"\"\"\n    x = a + h\n    while x <= (b - h):\n        yield x\n        x = x + h"}
{"task": "detection", "input": "classify code:\ndef generate_large_matrix() -> list[list[int]]:\n    \"\"\"\n    >>> generate_large_matrix() # doctest: +ELLIPSIS\n    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]\n    \"\"\"\n    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef lomuto_partition(sorting: list, left: int, right: int) -> int:\n    \"\"\"\n    Example:\n    >>> lomuto_partition([1,5,7,6], 0, 3)\n    2\n    \"\"\"\n    pivot = sorting[right]\n    store_index = left\n    for i in range(left, right):\n        if sorting[i] < pivot:\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\n            store_index += 1\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\n    return store_index", "output": "def lomuto_partition(sorting: list, left: int, right: int) -> int:\n    \"\"\"\n    Example:\n    >>> lomuto_partition([1,5,7,6], 0, 3)\n    2\n    \"\"\"\n    pivot = sorting[right]\n    store_index = left\n    for i in range(left, right):\n        if sorting[i] < pivot:\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\n            store_index += 1\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\n    return store_index"}
{"task": "search", "input": "search code:\nreturn the arithmetic mean of series\n\nChoices:\n0: def bruteforce(input_string: str) -> dict[int, str]:     results = {}     for key_guess in range(1, len(input_string)):  # tries every key         results[key_guess] = decrypt(input_string, key_guess)     return results\n1: def random_matrix(width: int, height: int, a: int, b: int) -> Matrix:     random.seed(None)     matrix: list[list[float]] = [         [random.randint(a, b) for _ in range(width)] for _ in range(height)     ]     return Matrix(matrix, width, height)\n2: def arithmetic_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 0     for val in series:         answer += val     return answer / len(series)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef takewhile_inclusive(predicate, iterable):\n    for x in iterable:\n        yield x\n        if not predicate(x):\n            break", "output": "A variant of :func:`takewhile` that yields one additional element."}
{"task": "repair", "input": "fix bug:\ndef subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n\n    Args:\n        * `elements`: The list of elements from which combinations will be generated.\n        * `n`: The number of elements in each combination.\n\n    Returns:\n        A list of tuples, each representing a combination of `n` elements.\n\n    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n    >>> subset_combinations(elements=[1, 2, 3], n=1)\n    [(1,), (2,), (3,)]\n    >>> subset_combinations(elements=[1, 2, 3], n=3)\n    [(1, 2, 3)]\n    >>> subset_combinations(elements=[42], n=1)\n    [(42,)]\n    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n    [(6, 7, 8, 9)]\n    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n    [()]\n    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n    >>> subset_combinations(elements=['single'], n=0)\n    [()]\n    >>> subset_combinations(elements=[], n=9)\n    []\n    >>> from itertools import combinations\n    >>> all(subset_combinations(items, n) == list(combinations(items, n))\n    ...     for items, n in (\n    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n    True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]", "output": "def subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n\n    Args:\n        * `elements`: The list of elements from which combinations will be generated.\n        * `n`: The number of elements in each combination.\n\n    Returns:\n        A list of tuples, each representing a combination of `n` elements.\n\n    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n    >>> subset_combinations(elements=[1, 2, 3], n=1)\n    [(1,), (2,), (3,)]\n    >>> subset_combinations(elements=[1, 2, 3], n=3)\n    [(1, 2, 3)]\n    >>> subset_combinations(elements=[42], n=1)\n    [(42,)]\n    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n    [(6, 7, 8, 9)]\n    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n    [()]\n    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n    >>> subset_combinations(elements=['single'], n=0)\n    [()]\n    >>> subset_combinations(elements=[], n=9)\n    []\n    >>> from itertools import combinations\n    >>> all(subset_combinations(items, n) == list(combinations(items, n))\n    ...     for items, n in (\n    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n    True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    return fibonacci_digits_index(n)", "output": "Returns the index of the first term in the Fibonacci sequence to contain"}
{"task": "search", "input": "search code:\nSome examples\n\nChoices:\n0: def gray_code_sequence_string(bit_count: int) -> list:      # The approach is a recursive one     # Base case achieved when either n = 0 or n=1     if bit_count == 0:         return [\"0\"]      if bit_count == 1:         return [\"0\", \"1\"]      seq_len = 1 << bit_count  # defines the length of the sequence     # 1<< n is equivalent to 2^n      # recursive answer will generate answer for n-1 bits     smaller_sequence = gray_code_sequence_string(bit_count - 1)      sequence = []      # append 0 to first half of the smaller sequence generated     for i in range(seq_len // 2):         generated_no = \"0\" + smaller_sequence[i]         sequence.append(generated_no)      # append 1 to second half ... start from the end of the list     for i in reversed(range(seq_len // 2)):         generated_no = \"1\" + smaller_sequence[i]         sequence.append(generated_no)      return sequence\n1: def msd_radix_sort_inplace(list_of_ints: list[int]):      length = len(list_of_ints)     if not list_of_ints or length == 1:         return      if min(list_of_ints) < 0:         raise ValueError(\"All numbers must be positive\")      most_bits = max(len(bin(x)[2:]) for x in list_of_ints)     _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)\n2: def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive     array_length = len(array)     # If the array contains only one element, we return it (it's the stop condition of     # recursion)     if array_length <= 1:         return array         # Else     pivot = array[0]     is_found = False     i = 1     longest_subseq: list[int] = []     while not is_found and i < array_length:         if array[i] < pivot:             is_found = True             temp_array = array[i:]             temp_array = longest_subsequence(temp_array)             if len(temp_array) > len(longest_subseq):                 longest_subseq = temp_array         else:             i += 1      temp_array = [element for element in array[1:] if element >= pivot]     temp_array = [pivot, *longest_subsequence(temp_array)]     if len(temp_array) > len(longest_subseq):         return temp_array     else:         return longest_subseq", "output": "2"}
{"task": "detection", "input": "classify code:\ndef generate_key(message: str, key: str) -> str:\n    \"\"\"\n    >>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n    'SECRETSECRETSECRE'\n    \"\"\"\n    x = len(message)\n    i = 0\n    while True:\n        if x == i:\n            i = 0\n        if len(key) == len(message):\n            break\n        key += key[i]\n        i += 1\n    return key", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    triangle = os.path.join(script_dir, \"triangle.txt\")\n\n    with open(triangle) as f:\n        triangle = f.readlines()\n\n    a = [[int(y) for y in x.rstrip(\"\\r\\n\").split(\" \")] for x in triangle]\n\n    for i in range(1, len(a)):\n        for j in range(len(a[i])):\n            number1 = a[i - 1][j] if j != len(a[i - 1]) else 0\n            number2 = a[i - 1][j - 1] if j > 0 else 0\n            a[i][j] += max(number1, number2)\n    return max(a[-1])", "output": "Finds the maximum total in a triangle as described by the problem statement"}
{"task": "repair", "input": "fix bug:\ndef prime_sieve(n: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "def prime_sieve(n: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes"}
{"task": "search", "input": "search code:\nchecking whether the input series is arithmetic series or not\n\nChoices:\n0: def is_arithmetic_series(series: list) -> bool:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     if len(series) == 1:         return True     common_diff = series[1] - series[0]     for index in range(len(series) - 1):         if series[index + 1] - series[index] != common_diff:             return False     return True\n1: def unit_len(sized_iterable, unit_noun='item'):  # TODO: len_units()/unitize()?     count = len(sized_iterable)     units = cardinalize(unit_noun, count)     if count:         return f'{count} {units}'     return f'No {units}'\n2: def sigmoid_linear_unit(vector: np.ndarray) -> np.ndarray:     return vector * sigmoid(vector)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef text_from_bits(bits, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_from_bits('011011010111001101100111')\n    'msg'\n    \"\"\"\n    n = int(bits, 2)\n    return n.to_bytes((n.bit_length() + 7) // 8, \"big\").decode(encoding, errors) or \"\\0\"", "output": "def text_from_bits(bits, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_from_bits('011011010111001101100111')\n    'msg'\n    \"\"\"\n    n = int(bits, 2)\n    return n.to_bytes((n.bit_length() + 7) // 8, \"big\").decode(encoding, errors) or \"\\0\""}
{"task": "search", "input": "search code:\nPlots of whether the absolute value of z_final is greater than\n\nChoices:\n0: def show_results(     function_label: str,     function_params: Any,     escape_radius: float,     z_final: np.ndarray, ) -> None:      abs_z_final = (abs(z_final)).transpose()     abs_z_final[:, :] = abs_z_final[::-1, :]     plt.matshow(abs_z_final < escape_radius)     plt.title(f\"Julia set of ${function_label}$, $c={function_params}$\")     plt.show()\n1: def main():     print(\"Volumes:\")     print(f\"Cube: {vol_cube(2) = }\")  # = 8     print(f\"Cuboid: {vol_cuboid(2, 2, 2) = }\")  # = 8     print(f\"Cone: {vol_cone(2, 2) = }\")  # ~= 1.33     print(f\"Right Circular Cone: {vol_right_circ_cone(2, 2) = }\")  # ~= 8.38     print(f\"Prism: {vol_prism(2, 2) = }\")  # = 4     print(f\"Pyramid: {vol_pyramid(2, 2) = }\")  # ~= 1.33     print(f\"Sphere: {vol_sphere(2) = }\")  # ~= 33.5     print(f\"Hemisphere: {vol_hemisphere(2) = }\")  # ~= 16.75     print(f\"Circular Cylinder: {vol_circular_cylinder(2, 2) = }\")  # ~= 25.1     print(f\"Torus: {vol_torus(2, 2) = }\")  # ~= 157.9     print(f\"Conical Frustum: {vol_conical_frustum(2, 2, 4) = }\")  # ~= 58.6     print(f\"Spherical cap: {vol_spherical_cap(1, 2) = }\")  # ~= 5.24     print(f\"Spheres intersection: {vol_spheres_intersect(2, 2, 1) = }\")  # ~= 21.21     print(f\"Spheres union: {vol_spheres_union(2, 2, 1) = }\")  # ~= 45.81     print(         f\"Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }\"     )  # ~= 28.3     print(f\"Icosahedron: {vol_icosahedron(2.5) = }\")  # ~=34.09\n2: def hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:      # Initialize path with -1, indicating that we have not visited them yet     path = [-1] * (len(graph) + 1)     # initialize start and end of path with starting index     path[0] = path[-1] = start_index     # evaluate and if we find answer return path either return empty array     return path if util_hamilton_cycle(graph, path, 1) else []", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef fib_memoization(n: int) -> list[int]:\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]", "output": "Calculates the first n (0-indexed) Fibonacci numbers using memoization"}
{"task": "detection", "input": "classify code:\ndef match_pattern(input_string: str, pattern: str) -> bool:\n    \"\"\"\n    uses bottom-up dynamic programming solution for matching the input\n    string with a given pattern.\n\n    Runtime: O(len(input_string)*len(pattern))\n\n    Arguments\n    --------\n    input_string: str, any string which should be compared with the pattern\n    pattern: str, the string that represents a pattern and may contain\n    '.' for single character matches and '*' for zero or more of preceding character\n    matches\n\n    Note\n    ----\n    the pattern cannot start with a '*',\n    because there should be at least one character before *\n\n    Returns\n    -------\n    A Boolean denoting whether the given string follows the pattern\n\n    Examples\n    -------\n    >>> match_pattern(\"aab\", \"c*a*b\")\n    True\n    >>> match_pattern(\"dabc\", \"*abc\")\n    False\n    >>> match_pattern(\"aaa\", \"aa\")\n    False\n    >>> match_pattern(\"aaa\", \"a.a\")\n    True\n    >>> match_pattern(\"aaab\", \"aa*\")\n    False\n    >>> match_pattern(\"aaab\", \".*\")\n    True\n    >>> match_pattern(\"a\", \"bbbb\")\n    False\n    >>> match_pattern(\"\", \"bbbb\")\n    False\n    >>> match_pattern(\"a\", \"\")\n    False\n    >>> match_pattern(\"\", \"\")\n    True\n    \"\"\"\n\n    len_string = len(input_string) + 1\n    len_pattern = len(pattern) + 1\n\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\n    # length i of input_string matches with prefix string of length j of\n    # given pattern.\n    # \"dp\" stands for dynamic programming.\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\n\n    # since string of zero length match pattern of zero length\n    dp[0][0] = 1\n\n    # since pattern of zero length will never match with string of non-zero length\n    for i in range(1, len_string):\n        dp[i][0] = 0\n\n    # since string of zero length will match with pattern where there\n    # is at least one * alternatively\n    for j in range(1, len_pattern):\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \"*\" else 0\n\n    # now using bottom-up approach to find for all remaining lengths\n    for i in range(1, len_string):\n        for j in range(1, len_pattern):\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \".\":\n                dp[i][j] = dp[i - 1][j - 1]\n\n            elif pattern[j - 1] == \"*\":\n                if dp[i][j - 2] == 1:\n                    dp[i][j] = 1\n                elif pattern[j - 2] in (input_string[i - 1], \".\"):\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n\n    return bool(dp[-1][-1])", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)"}
{"task": "summary", "input": "summarize code:\ndef exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:\n    return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))", "output": "Implements the ELU activation function."}
{"task": "search", "input": "search code:\nFind the minimum number of multiplcations required to multiply the chain of matrices\n\nChoices:\n0: def clear_bit(number: int, position: int) -> int:     return number & ~(1 << position)\n1: def matrix_chain_multiply(arr: list[int]) -> int:     if len(arr) < 2:         return 0     # initialising 2D dp matrix     n = len(arr)     dp = [[maxsize for j in range(n)] for i in range(n)]     # we want minimum cost of multiplication of matrices     # of dimension (i*k) and (k*j). This cost is arr[i-1]*arr[k]*arr[j].     for i in range(n - 1, 0, -1):         for j in range(i, n):             if i == j:                 dp[i][j] = 0                 continue             for k in range(i, j):                 dp[i][j] = min(                     dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]                 )      return dp[1][n - 1]\n2: def is_germain_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return is_prime(number) and is_prime(2 * number + 1)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef dp_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Dynamic programming matching algorithm.\n\n    | Time complexity: O(\\|text\\| * \\|pattern\\|)\n    | Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef decrypt_message(\n    message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5\n) -> str:\n    message, alphabet, character_to_number, number_to_character = __prepare(\n        message, alphabet\n    )\n\n    decrypted_numeric = []\n    for i in range(0, len(message), period):\n        a, b, c = __decrypt_part(message[i : i + period], character_to_number)\n\n        for j in range(len(a)):\n            decrypted_numeric.append(a[j] + b[j] + c[j])\n\n    return \"\".join(number_to_character[each] for each in decrypted_numeric)", "output": "decrypt_message"}
{"task": "repair", "input": "fix bug:\ndef largest_divisible_subset(items: list[int]) -> list[int]:\n    \"\"\"\n    Algorithm to find the biggest subset in the given array such that for any 2 elements\n    x and y in the subset, either x divides y or y divides x.\n    >>> largest_divisible_subset([1, 16, 7, 8, 4])\n    [16, 8, 4, 1]\n    >>> largest_divisible_subset([1, 2, 3])\n    [2, 1]\n    >>> largest_divisible_subset([-1, -2, -3])\n    [-3]\n    >>> largest_divisible_subset([1, 2, 4, 8])\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset((1, 2, 4, 8))\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset([1, 1, 1])\n    [1, 1, 1]\n    >>> largest_divisible_subset([0, 0, 0])\n    [0, 0, 0]\n    >>> largest_divisible_subset([-1, -1, -1])\n    [-1, -1, -1]\n    >>> largest_divisible_subset([])\n    []\n    \"\"\"\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result", "output": "def largest_divisible_subset(items: list[int]) -> list[int]:\n    \"\"\"\n    Algorithm to find the biggest subset in the given array such that for any 2 elements\n    x and y in the subset, either x divides y or y divides x.\n    >>> largest_divisible_subset([1, 16, 7, 8, 4])\n    [16, 8, 4, 1]\n    >>> largest_divisible_subset([1, 2, 3])\n    [2, 1]\n    >>> largest_divisible_subset([-1, -2, -3])\n    [-3]\n    >>> largest_divisible_subset([1, 2, 4, 8])\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset((1, 2, 4, 8))\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset([1, 1, 1])\n    [1, 1, 1]\n    >>> largest_divisible_subset([0, 0, 0])\n    [0, 0, 0]\n    >>> largest_divisible_subset([-1, -1, -1])\n    [-1, -1, -1]\n    >>> largest_divisible_subset([])\n    []\n    \"\"\"\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result"}
{"task": "search", "input": "search code:\nReturns the count of all n-digit numbers which are nth power\n\nChoices:\n0: def find_freq_subgraph_given_support(s, cluster, graph):     k = int(s / 100 * (len(cluster) - 1))     for i in cluster[k]:         my_dfs(graph, tuple(cluster[k][i]), ([\"Header\"],))\n1: def solution(max_base: int = 10, max_power: int = 22) -> int:     bases = range(1, max_base)     powers = range(1, max_power)     return sum(         1 for power in powers for base in bases if len(str(base**power)) == power     )\n2: def get_format_args(fstr):     # TODO: memoize     formatter = Formatter()     fargs, fkwargs, _dedup = [], [], set()      def _add_arg(argname, type_char='s'):         if argname not in _dedup:             _dedup.add(argname)             argtype = _TYPE_MAP.get(type_char, str)  # TODO: unicode             try:                 fargs.append((int(argname), argtype))             except ValueError:                 fkwargs.append((argname, argtype))      for lit, fname, fspec, conv in formatter.parse(fstr):         if fname is not None:             type_char = fspec[-1:]             fname_list = re.split('[.[]', fname)             if len(fname_list) > 1:                 raise ValueError('encountered compound format arg: %r' % fname)             try:                 base_fname = fname_list[0]                 assert base_fname             except (IndexError, AssertionError):                 raise ValueError('encountered anonymous positional argument')             _add_arg(fname, type_char)             for sublit, subfname, _, _ in formatter.parse(fspec):                 # TODO: positional and anon args not allowed here.                 if subfname is not None:                     _add_arg(subfname)     return fargs, fkwargs", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False", "output": "def exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False"}
{"task": "summary", "input": "summarize code:\ndef maclaurin_cos(theta: float, accuracy: int = 30) -> float:\n\n    if not isinstance(theta, (int, float)):\n        raise ValueError(\"maclaurin_cos() requires either an int or float for theta\")\n\n    if not isinstance(accuracy, int) or accuracy <= 0:\n        raise ValueError(\"maclaurin_cos() requires a positive int for accuracy\")\n\n    theta = float(theta)\n    div = theta // (2 * pi)\n    theta -= 2 * div * pi\n    return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))", "output": "Finds the maclaurin approximation of cos"}
{"task": "search", "input": "search code:\nReturns the number of mondays that fall on the first of the month during\n\nChoices:\n0: def solution():     days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]      day = 6     month = 1     year = 1901      sundays = 0      while year < 2001:         day += 7          if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):             if day > days_per_month[month - 1] and month != 2:                 month += 1                 day = day - days_per_month[month - 2]             elif day > 29 and month == 2:                 month += 1                 day = day - 29         elif day > days_per_month[month - 1]:             month += 1             day = day - days_per_month[month - 2]          if month > 12:             year += 1             month = 1          if year < 2001 and day == 1:             sundays += 1     return sundays\n1: def electrical_impedance(     resistance: float, reactance: float, impedance: float ) -> dict[str, float]:     if (resistance, reactance, impedance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance == 0:         return {\"resistance\": sqrt(pow(impedance, 2) - pow(reactance, 2))}     elif reactance == 0:         return {\"reactance\": sqrt(pow(impedance, 2) - pow(resistance, 2))}     elif impedance == 0:         return {\"impedance\": sqrt(pow(resistance, 2) + pow(reactance, 2))}     else:         raise ValueError(\"Exactly one argument must be 0\")\n2: def calc_derivative(f: RealFunc, x: float, delta_x: float = 1e-3) -> float:     return (f(x + delta_x / 2) - f(x - delta_x / 2)) / delta_x", "output": "0"}
{"task": "detection", "input": "classify code:\ndef swap_case(sentence):\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        if char.islower():\n            new_string += char.upper()\n        if regexp.search(char):\n            new_string += char\n\n    return new_string", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef unique(src, key=None):\n    return list(unique_iter(src, key))", "output": "``unique()`` returns a list of unique values, as determined by"}
{"task": "detection", "input": "classify code:\ndef elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef swap_case(sentence):\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        if char.islower():\n            new_string += char.upper()\n        if regexp.search(char):\n            new_string += char\n\n    return new_string", "output": "def swap_case(sentence: str) -> str:\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n\n    return new_string"}
{"task": "search", "input": "search code:\nThe :mod:`gzip` module is great if you have a file or file-like\n\nChoices:\n0: def intcomma(value, ndigits=None):     sep = thousands_separator()     try:         if isinstance(value, str):             float(value.replace(sep, \"\"))         else:             float(value)     except (TypeError, ValueError):         return value      if ndigits:         orig = \"{0:.{1}f}\".format(value, ndigits)     else:         orig = str(value)      new = re.sub(r\"^(-?\\d+)(\\d{3})\", rf\"\\g<1>{sep}\\g<2>\", orig)     if orig == new:         return new     else:         return intcomma(new)\n1: def gunzip_bytes(bytestring):     return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)\n2: def job_sequencing_with_deadlines(jobs: list) -> list:      # Sort the jobs in descending order of profit     jobs = sorted(jobs, key=lambda value: value[2], reverse=True)      # Create a list of size equal to the maximum deadline     # and initialize it with -1     max_deadline = max(jobs, key=lambda value: value[1])[1]     time_slots = [-1] * max_deadline      # Finding the maximum profit and the count of jobs     count = 0     max_profit = 0     for job in jobs:         # Find a free time slot for this job         # (Note that we start from the last possible slot)         for i in range(job[1] - 1, -1, -1):             if time_slots[i] == -1:                 time_slots[i] = job[0]                 count += 1                 max_profit += job[2]                 break     return [count, max_profit]", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "output": "def calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r"}
{"task": "search", "input": "search code:\nCalculates a list of totients from 0 to max_one exclusive, using the\n\nChoices:\n0: def get_totients(max_one: int) -> list[int]:     totients = np.arange(max_one)      for i in range(2, max_one):         if totients[i] == i:             x = np.arange(i, max_one, i)  # array of indexes to select             totients[x] -= totients[x] // i      return totients.tolist()\n1: def capacitor_series(capacitors: list[float]) -> float:      first_sum = 0.0     for index, capacitor in enumerate(capacitors):         if capacitor <= 0:             msg = f\"Capacitor at index {index} has a negative or zero value!\"             raise ValueError(msg)         first_sum += 1 / capacitor     return 1 / first_sum\n2: def right_rotation(node: MyNode) -> MyNode:     print(\"left rotation node:\", node.get_data())     ret = node.get_left()     assert ret is not None     node.set_left(ret.get_right())     ret.set_right(node)     h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1     node.set_height(h1)     h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1     ret.set_height(h2)     return ret", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5", "output": "Calculates the speed of sound in a fluid from its density and bulk modulus"}
{"task": "detection", "input": "classify code:\ndef identity(n: int) -> list[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef find_min(arr):\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i][j - 1]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff", "output": "BUGGY"}
{"task": "search", "input": "search code:\nConsidering natural numbers of the form, a**b, where a, b < 100,\n\nChoices:\n0: def solution(n: int = 1000) -> int:     return sum(2 * a * ((a - 1) // 2) for a in range(3, n + 1))\n1: def solution(a: int = 100, b: int = 100) -> int:      # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of     # BASE raised to the POWER     return max(         sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)     )\n2: def remove_prefix(data_bits: str) -> str:     counter = 0     for letter in data_bits:         if letter == \"1\":             break         counter += 1      data_bits = data_bits[counter:]     data_bits = data_bits[counter + 1 :]     return data_bits", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Create a dictionary that maps lowercase letters to uppercase letters\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    lower_to_upper = dict(zip(ascii_lowercase, ascii_uppercase))\n    return lower_to_upper.get(sentence[0], sentence[0]) + sentence[1:]", "output": "def capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    return sentence[0].upper() + sentence[1:]"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    day = 6\n    month = 1\n    year = 1901\n\n    sundays = 0\n\n    while year < 2001:\n        day += 7\n\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            if day > days_per_month[month - 1] and month != 2:\n                month += 1\n                day = day - days_per_month[month - 2]\n            elif day > 29 and month == 2:\n                month += 1\n                day = day - 29\n        elif day > days_per_month[month - 1]:\n            month += 1\n            day = day - days_per_month[month - 2]\n\n        if month > 12:\n            year += 1\n            month = 1\n\n        if year < 2001 and day == 1:\n            sundays += 1\n    return sundays", "output": "Returns the number of mondays that fall on the first of the month during"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 100) -> int:\n    singles: list[int] = [*list(range(1, 21)), 25]\n    doubles: list[int] = [2 * x for x in range(1, 21)] + [50]\n    triples: list[int] = [3 * x for x in range(1, 21)]\n    all_values: list[int] = singles + doubles + triples + [0]\n\n    num_checkouts: int = 0\n    double: int\n    throw1: int\n    throw2: int\n    checkout_total: int\n\n    for double in doubles:\n        for throw1, throw2 in combinations_with_replacement(all_values, 2):\n            checkout_total = double + throw1 + throw2\n            if checkout_total < limit:\n                num_checkouts += 1\n\n    return num_checkouts", "output": "Count the number of distinct ways a player can checkout with a score"}
{"task": "repair", "input": "fix bug:\ndef get_data(source_data: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])\n    [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]\n    \"\"\"\n    data_lists: list[list[float]] = []\n    for data in source_data:\n        for i, el in enumerate(data):\n            if len(data_lists) < i + 1:\n                data_lists.append([])\n            data_lists[i].append(float(el))\n    return data_lists", "output": "def get_data(source_data: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])\n    [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]\n    \"\"\"\n    data_lists: list[list[float]] = []\n    for data in source_data:\n        for i, el in enumerate(data):\n            if len(data_lists) < i + 1:\n                data_lists.append([])\n            data_lists[i].append(float(el))\n    return data_lists"}
{"task": "search", "input": "search code:\nFormat the exception part of a traceback.\n\nChoices:\n0: def solution(limit: int = 1_000_000) -> int:      # generating an array from -1 to limit     phi = np.arange(-1, limit)      for i in range(2, limit + 1):         if phi[i] == i - 1:             ind = np.arange(2 * i, limit + 1, i)  # indexes for selection             phi[ind] -= phi[ind] // i      return int(np.sum(phi[2 : limit + 1]))\n1: def format_exception_only(etype, value):     # Gracefully handle (the way Python 2.4 and earlier did) the case of     # being called with (None, None).     if etype is None:         return [_format_final_exc_line(etype, value)]      stype = etype.__name__     smod = etype.__module__     if smod not in (\"__main__\", \"builtins\", \"exceptions\"):         stype = smod + '.' + stype      if not issubclass(etype, SyntaxError):         return [_format_final_exc_line(stype, value)]      # It was a syntax error; show exactly where the problem was found.     lines = []     filename = value.filename or \"<string>\"     lineno = str(value.lineno) or '?'     lines.append(f'  File \"{filename}\", line {lineno}\\n')     badline = value.text     offset = value.offset     if badline is not None:         lines.append('    %s\\n' % badline.strip())         if offset is not None:             caretspace = badline.rstrip('\\n')[:offset].lstrip()             # non-space whitespace (likes tabs) must be kept for alignment             caretspace = ((c.isspace() and c or ' ') for c in caretspace)             # only three spaces to account for offset1 == pos 0             lines.append('   %s^\\n' % ''.join(caretspace))     msg = value.msg or \"<no detail available>\"     lines.append(f\"{stype}: {msg}\\n\")     return lines\n2: def split_when(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      it = iter(iterable)     try:         cur_item = next(it)     except StopIteration:         return      buf = [cur_item]     for next_item in it:         if pred(cur_item, next_item):             yield buf             if maxsplit == 1:                 yield [next_item, *it]                 return             buf = []             maxsplit -= 1          buf.append(next_item)         cur_item = next_item      yield buf", "output": "1"}
{"task": "detection", "input": "classify code:\ndef two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    >>> num_digits(0)\n    1\n    >>> num_digits(-1)\n    1\n    >>> num_digits(-123456)\n    6\n    \"\"\"\n    digits = 0\n    n = abs(n)\n    while True:\n        n = n // 10\n        digits += 1\n        if n == 0:\n            break\n    return digits", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef palindromic_string(input_string: str) -> str:\n    \"\"\"\n    >>> palindromic_string('abbbaba')\n    'abbba'\n    >>> palindromic_string('ababa')\n    'ababa'\n\n    Manacher's algorithm which finds Longest palindromic Substring in linear time.\n\n    1. first this convert input_string(\"xyx\") into new_string(\"x|y|x\") where odd\n        positions are actual input characters.\n    2. for each character in new_string it find corresponding length and\n        store the length and left,right to store previously calculated info.\n        (please look the explanation for details)\n\n    3. return corresponding output_string by removing all \"|\"\n    \"\"\"\n    max_length = 0\n\n    # if input_string is \"aba\" than new_input_string become \"a|b|a\"\n    new_input_string = \"\"\n    output_string = \"\"\n\n    # append each character + \"|\" in new_string for range(0, length-1)\n    for i in input_string[: len(input_string) - 1]:\n        new_input_string += i + \"|\"\n    # append last character\n    new_input_string += input_string[-1]\n\n    # we will store the starting and ending of previous furthest ending palindromic\n    # substring\n    left, right = 0, 0\n\n    # length[i] shows the length of palindromic substring with center i\n    length = [1 for i in range(len(new_input_string))]\n\n    # for each character in new_string find corresponding palindromic string\n    start = 0\n    for j in range(len(new_input_string)):\n        k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)\n        while (\n            j - k >= 0\n            and j + k < len(new_input_string)\n            and new_input_string[k + j] == new_input_string[j - k]\n        ):\n            k += 1\n\n        length[j] = 2 * k - 1\n\n        # does this string is ending after the previously explored end (that is right) ?\n        # if yes the update the new right to the last index of this\n        if j + k - 1 > right:\n            left = j - k + 1\n            right = j + k - 1\n\n        # update max_length and start position\n        if max_length < length[j]:\n            max_length = length[j]\n            start = j\n\n    # create that string\n    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]\n    for i in s:\n        if i != \"|\":\n            output_string += i\n\n    return output_string", "output": "def palindromic_string(input_string: str) -> str:\n    \"\"\"\n    >>> palindromic_string('abbbaba')\n    'abbba'\n    >>> palindromic_string('ababa')\n    'ababa'\n\n    Manacher's algorithm which finds Longest palindromic Substring in linear time.\n\n    1. first this convert input_string(\"xyx\") into new_string(\"x|y|x\") where odd\n        positions are actual input characters.\n    2. for each character in new_string it find corresponding length and\n        store the length and left,right to store previously calculated info.\n        (please look the explanation for details)\n\n    3. return corresponding output_string by removing all \"|\"\n    \"\"\"\n    max_length = 0\n\n    # if input_string is \"aba\" than new_input_string become \"a|b|a\"\n    new_input_string = \"\"\n    output_string = \"\"\n\n    # append each character + \"|\" in new_string for range(0, length-1)\n    for i in input_string[: len(input_string) - 1]:\n        new_input_string += i + \"|\"\n    # append last character\n    new_input_string += input_string[-1]\n\n    # we will store the starting and ending of previous furthest ending palindromic\n    # substring\n    left, right = 0, 0\n\n    # length[i] shows the length of palindromic substring with center i\n    length = [1 for i in range(len(new_input_string))]\n\n    # for each character in new_string find corresponding palindromic string\n    start = 0\n    for j in range(len(new_input_string)):\n        k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)\n        while (\n            j - k >= 0\n            and j + k < len(new_input_string)\n            and new_input_string[k + j] == new_input_string[j - k]\n        ):\n            k += 1\n\n        length[j] = 2 * k - 1\n\n        # does this string is ending after the previously explored end (that is right) ?\n        # if yes the update the new right to the last index of this\n        if j + k - 1 > right:\n            left = j - k + 1\n            right = j + k - 1\n\n        # update max_length and start position\n        if max_length < length[j]:\n            max_length = length[j]\n            start = j\n\n    # create that string\n    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]\n    for i in s:\n        if i != \"|\":\n            output_string += i\n\n    return output_string"}
{"task": "summary", "input": "summarize code:\ndef area_rhombus(diagonal_1: float, diagonal_2: float) -> float:\n    if diagonal_1 < 0 or diagonal_2 < 0:\n        raise ValueError(\"area_rhombus() only accepts non-negative values\")\n    return 1 / 2 * diagonal_1 * diagonal_2", "output": "Calculate the area of a rhombus."}
{"task": "search", "input": "search code:\nBackport of non-windowed running_median() for Python 3.13 and prior.\n\nChoices:\n0: def _running_median_minheap_only(iterator):  # pragma: no cover     \"Backport of non-windowed running_median() for Python 3.13 and prior.\"      read = iterator.__next__     lo = []  # max-heap (actually a minheap with negated values)     hi = []  # min-heap (same size as or one smaller than lo)      with suppress(StopIteration):         while True:             heappush(lo, -heappushpop(hi, read()))             yield -lo[0]              heappush(hi, -heappushpop(lo, -read()))             yield (hi[0] - lo[0]) / 2\n1: def value_chain(*args):     scalar_types = (str, bytes)     for value in args:         if isinstance(value, scalar_types):             yield value             continue         try:             yield from value         except TypeError:             yield value\n2: def intersection(function: Callable[[float], float], x0: float, x1: float) -> float:     x_n: float = x0     x_n1: float = x1     while True:         if x_n == x_n1 or function(x_n1) == function(x_n):             raise ZeroDivisionError(\"float division by zero, could not find root\")         x_n2: float = x_n1 - (             function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))         )         if abs(x_n2 - x_n1) < 10**-5:             return x_n2         x_n = x_n1         x_n1 = x_n2", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares", "output": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares"}
{"task": "detection", "input": "classify code:\ndef wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCommands:\n\nChoices:\n0: def interact_treap(root: Node | None, args: str) -> Node | None:     for arg in args.split():         if arg[0] == \"+\":             root = insert(root, int(arg[1:]))          elif arg[0] == \"-\":             root = erase(root, int(arg[1:]))          else:             print(\"Unknown command\")      return root\n1: def stooge_sort(arr: list[int]) -> list[int]:     stooge(arr, 0, len(arr) - 1)     return arr\n2: def decode(coded: str) -> str:     if set(coded) - {\"A\", \"B\", \" \"} != set():         raise Exception(\"decode() accepts only 'A', 'B' and spaces\")     decoded = \"\"     for word in coded.split():         while len(word) != 0:             decoded += decode_dict[word[:5]]             word = word[5:]         decoded += \" \"     return decoded.strip()", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:\n\n    id_ = 0\n    n = len(graph)  # No of vertices in graph\n    low = [0] * n\n    visited = [False] * n\n\n    def dfs(at, parent, bridges, id_):\n        visited[at] = True\n        low[at] = id_\n        id_ += 1\n        for to in graph[at]:\n            if to == parent:\n                pass\n            elif not visited[to]:\n                dfs(to, at, bridges, id_)\n                low[at] = min(low[at], low[to])\n                if id_ <= low[to]:\n                    bridges.append((at, to) if at < to else (to, at))\n            else:\n                # This edge is a back edge and cannot be a bridge\n                low[at] = min(low[at], low[to])\n\n    bridges: list[tuple[int, int]] = []\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, -1, bridges, id_)\n    return bridges", "output": "Return the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi"}
{"task": "summary", "input": "summarize code:\ndef vol_cube(side_length: float) -> float:\n    if side_length < 0:\n        raise ValueError(\"vol_cube() only accepts non-negative values\")\n    return pow(side_length, 3)", "output": "Calculate the Volume of a Cube."}
{"task": "repair", "input": "fix bug:\ndef unique_prime_factors(n: int) -> set:\n    \"\"\"\n    Find unique prime factors of an integer.\n    Tests include sorting because only the set matters,\n    not the order in which it is produced.\n    >>> sorted(set(unique_prime_factors(14)))\n    [2, 7]\n    >>> sorted(set(unique_prime_factors(644)))\n    [2, 7, 23]\n    >>> sorted(set(unique_prime_factors(646)))\n    [2, 17, 19]\n    \"\"\"\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors", "output": "def unique_prime_factors(n: int) -> set:\n    \"\"\"\n    Find unique prime factors of an integer.\n    Tests include sorting because only the set matters,\n    not the order in which it is produced.\n    >>> sorted(set(unique_prime_factors(14)))\n    [2, 7]\n    >>> sorted(set(unique_prime_factors(644)))\n    [2, 7, 23]\n    >>> sorted(set(unique_prime_factors(646)))\n    [2, 17, 19]\n    \"\"\"\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors"}
{"task": "detection", "input": "classify code:\ndef prime_sieve(n: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the horizontal distance that the object cover\n\nChoices:\n0: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]\n1: def horizontal_distance(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(2 * angle)     return round(init_velocity**2 * sin(radians) / g, 2)\n2: def zigzag(root: Node | None) -> Generator[int]:     if root is None:         return      flag = 0     height_tree = height(root)      for h in range(1, height_tree + 1):         if not flag:             yield from get_nodes_from_left_to_right(root, h)             flag = 1         else:             yield from get_nodes_from_right_to_left(root, h)             flag = 0", "output": "1"}
{"task": "search", "input": "search code:\nReturn the floor of x as an Integral.\n\nChoices:\n0: def floor(x: float) -> int:     return int(x) if x - int(x) >= 0 else int(x) - 1\n1: def apnumber(value):     try:         value = int(value)     except (TypeError, ValueError):         return value     if not 0 <= value < 10:         return str(value)     return (         _(\"zero\"),         _(\"one\"),         _(\"two\"),         _(\"three\"),         _(\"four\"),         _(\"five\"),         _(\"six\"),         _(\"seven\"),         _(\"eight\"),         _(\"nine\"),     )[value]\n2: def euler_phi(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = n     for x in set(prime_factors(n)):         s *= (x - 1) / x     return int(s)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef digit_factorial_sum(number: int) -> int:\n    if not isinstance(number, int):\n        raise TypeError(\"Parameter number must be int\")\n\n    if number < 0:\n        raise ValueError(\"Parameter number must be greater than or equal to 0\")\n\n    # Converts number in string to iterate on its digits and adds its factorial.\n    return sum(DIGIT_FACTORIAL[digit] for digit in str(number))", "output": "Function to perform the sum of the factorial of all the digits in number"}
{"task": "detection", "input": "classify code:\ndef calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares", "output": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares"}
{"task": "repair", "input": "fix bug:\ndef find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n    \"\"\"\n    n = len(nums)\n    missing_number = n\n\n    for i in range(n):\n        missing_number ^= i ^ nums[i]\n\n    return missing_number", "output": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n\n    for i in range(low, high):\n        missing_number ^= i ^ nums[i - low]\n\n    return missing_number"}
{"task": "detection", "input": "classify code:\ndef vector_product(point1: Tuple[int, int], point2: Tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nIn-order traversal visits left subtree, root node, right subtree.\n\nChoices:\n0: def is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:     for i in range(9):         if n in {grid[row][i], grid[i][column]}:             return False      for i in range(3):         for j in range(3):             if grid[(row - row % 3) + i][(column - column % 3) + j] == n:                 return False      return True\n1: def benchmark() -> None:      def do_benchmark(number: int) -> None:         setup = \"import __main__ as z\"         print(f\"Benchmark when {number = }:\")         print(f\"{get_set_bits_count_using_modulo_operator(number) = }\")         timing = timeit(             f\"z.get_set_bits_count_using_modulo_operator({number})\", setup=setup         )         print(f\"timeit() runs in {timing} seconds\")         print(f\"{get_set_bits_count_using_brian_kernighans_algorithm(number) = }\")         timing = timeit(             f\"z.get_set_bits_count_using_brian_kernighans_algorithm({number})\",             setup=setup,         )         print(f\"timeit() runs in {timing} seconds\")      for number in (25, 37, 58, 0):         do_benchmark(number)         print()\n2: def inorder(root: Node | None) -> Generator[int]:     if not root:         return     yield from inorder(root.left)     yield root.data     yield from inorder(root.right)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef capture_area(capture_radius: float) -> float:\n\n    if capture_radius < 0:\n        raise ValueError(\"Cannot have a capture radius less than 0\")\n    sigma = pi * pow(capture_radius, 2)\n    return round(sigma, 0)", "output": "Input Param:"}
{"task": "detection", "input": "classify code:\ndef validate(*values: float) -> bool:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> validate(2.016, 4.002)\n    True\n    >>> validate(-2.016, 4.002)\n    False\n    >>> validate()\n    False\n    \"\"\"\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef bisect_right(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "def bisect_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo"}
{"task": "summary", "input": "summarize code:\ndef solution(base: int = 800800, degree: int = 800800) -> int:\n\n    upper_bound = degree * log2(base)\n    max_prime = int(upper_bound)\n    prime_numbers = calculate_prime_numbers(max_prime)\n\n    hybrid_integers_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left < right:\n        while (\n            prime_numbers[right] * log2(prime_numbers[left])\n            + prime_numbers[left] * log2(prime_numbers[right])\n            > upper_bound\n        ):\n            right -= 1\n        hybrid_integers_count += right - left\n        left += 1\n\n    return hybrid_integers_count", "output": "Returns the number of hybrid-integers less than or equal to base^degree"}
{"task": "search", "input": "search code:\nFormat a non-expression-style repr\n\nChoices:\n0: def format_nonexp_repr(obj, req_names=None, opt_names=None, opt_key=None):     cn = obj.__class__.__name__     req_names = req_names or []     opt_names = opt_names or []     uniq_names, all_names = set(), []     for name in req_names + opt_names:         if name in uniq_names:             continue         uniq_names.add(name)         all_names.append(name)      if opt_key is None:         opt_key = lambda v: v is None     assert callable(opt_key)      items = [(name, getattr(obj, name, None)) for name in all_names]     labels = [f'{name}={val!r}' for name, val in items               if not (name in opt_names and opt_key(val))]     if not labels:         labels = ['id=%s' % id(obj)]     ret = '<{} {}>'.format(cn, ' '.join(labels))     return ret\n1: def harmonic_series(n_term: str) -> list:     if n_term == \"\":         return []     series: list = []     for temp in range(int(n_term)):         series.append(f\"1/{temp + 1}\" if series else \"1\")     return series\n2: def simulate(     highway: list, number_of_update: int, probability: float, max_speed: int ) -> list:      number_of_cells = len(highway[0])      for i in range(number_of_update):         next_speeds_calculated = update(highway[i], probability, max_speed)         real_next_speeds = [-1] * number_of_cells          for car_index in range(number_of_cells):             speed = next_speeds_calculated[car_index]             if speed != -1:                 # Change the position based on the speed (with % to create the loop)                 index = (car_index + speed) % number_of_cells                 # Commit the change of position                 real_next_speeds[index] = speed         highway.append(real_next_speeds)      return highway", "output": "0"}
{"task": "detection", "input": "classify code:\ndef calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef second_molar_mass(\n    molar_mass: float, effusion_rate_1: float, effusion_rate_2: float\n) -> float | ValueError:\n    return (\n        round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)\n        if validate(molar_mass, effusion_rate_1, effusion_rate_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )", "output": "Input Parameters:"}
{"task": "repair", "input": "fix bug:\ndef is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True", "output": "def is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True"}
{"task": "search", "input": "search code:\nDoes very basic splitting of a format string, returns a list of\n\nChoices:\n0: def consume(iterator, n=None):     # Use functions that consume iterators at C speed.     if n is None:         # feed the entire iterator into a zero-length deque         deque(iterator, maxlen=0)     else:         # advance to the empty slice starting at position n         next(islice(iterator, n, n), None)\n1: def random_graph(     vertices_number: int, probability: float, directed: bool = False ) -> dict:     graph: dict = {i: [] for i in range(vertices_number)}      # if probability is greater or equal than 1, then generate a complete graph     if probability >= 1:         return complete_graph(vertices_number)     # if probability is lower or equal than 0, then return a graph without edges     if probability <= 0:         return graph      # for each couple of nodes, add an edge from u to v     # if the number randomly generated is greater than probability probability     for i in range(vertices_number):         for j in range(i + 1, vertices_number):             if random.random() < probability:                 graph[i].append(j)                 if not directed:                     # if the graph is undirected, add an edge in from j to i, either                     graph[j].append(i)     return graph\n2: def split_format_str(fstr):     ret = []      for lit, fname, fspec, conv in Formatter().parse(fstr):         if fname is None:             ret.append((lit, None))             continue         field_str = construct_format_field_str(fname, fspec, conv)         ret.append((lit, field_str))     return ret", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area", "output": "def largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area"}
{"task": "summary", "input": "summarize code:\ndef emitter_converter(size_par, data):\n    if size_par + len(data) <= 2**size_par - (len(data) - 1):\n        raise ValueError(\"size of parity don't match with size of data\")\n\n    data_out = []\n    parity = []\n    bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]\n\n    # sorted information data for the size of the output data\n    data_ord = []\n    # data position template + parity\n    data_out_gab = []\n    # parity bit counter\n    qtd_bp = 0\n    # counter position of data bits\n    cont_data = 0\n\n    for x in range(1, size_par + len(data) + 1):\n        # Performs a template of bit positions - who should be given,\n        # and who should be parity\n        if qtd_bp < size_par:\n            if (np.log(x) / np.log(2)).is_integer():\n                data_out_gab.append(\"P\")\n                qtd_bp = qtd_bp + 1\n            else:\n                data_out_gab.append(\"D\")\n        else:\n            data_out_gab.append(\"D\")\n\n        # Sorts the data to the new output size\n        if data_out_gab[-1] == \"D\":\n            data_ord.append(data[cont_data])\n            cont_data += 1\n        else:\n            data_ord.append(None)\n\n    # Calculates parity\n    qtd_bp = 0  # parity bit counter\n    for bp in range(1, size_par + 1):\n        # Bit counter one for a given parity\n        cont_bo = 0\n        # counter to control the loop reading\n        for cont_loop, x in enumerate(data_ord):\n            if x is not None:\n                try:\n                    aux = (bin_pos[cont_loop])[-1 * (bp)]\n                except IndexError:\n                    aux = \"0\"\n                if aux == \"1\" and x == \"1\":\n                    cont_bo += 1\n        parity.append(cont_bo % 2)\n\n        qtd_bp += 1\n\n    # Mount the message\n    cont_bp = 0  # parity bit counter\n    for x in range(size_par + len(data)):\n        if data_ord[x] is None:\n            data_out.append(str(parity[cont_bp]))\n            cont_bp += 1\n        else:\n            data_out.append(data_ord[x])\n\n    return data_out", "output": "- bits of information merged with parity bits"}
{"task": "detection", "input": "classify code:\ndef simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set", "output": "BUGGY"}
{"task": "search", "input": "search code:\nConverts a string of roman numerals to an integer.\n\nChoices:\n0: def cocktail_shaker_sort(arr: list[int]) -> list[int]:     start, end = 0, len(arr) - 1      while start < end:         swapped = False          # Pass from left to right         for i in range(start, end):             if arr[i] > arr[i + 1]:                 arr[i], arr[i + 1] = arr[i + 1], arr[i]                 swapped = True          if not swapped:             break          end -= 1  # Decrease the end pointer after each pass          # Pass from right to left         for i in range(end, start, -1):             if arr[i] < arr[i - 1]:                 arr[i], arr[i - 1] = arr[i - 1], arr[i]                 swapped = True          if not swapped:             break          start += 1  # Increase the start pointer after each pass      return arr\n1: def parse_roman_numerals(numerals: str) -> int:      total_value = 0      index = 0     while index < len(numerals) - 1:         current_value = SYMBOLS[numerals[index]]         next_value = SYMBOLS[numerals[index + 1]]         if current_value < next_value:             total_value -= current_value         else:             total_value += current_value         index += 1     total_value += SYMBOLS[numerals[index]]      return total_value\n2: def polynomial_eval(coefficients, x):     n = len(coefficients)     if n == 0:         return type(x)(0)     powers = map(pow, repeat(x), reversed(range(n)))     return _sumprod(coefficients, powers)", "output": "1"}
{"task": "search", "input": "search code:\nImplementation of djb2 hash algorithm that\n\nChoices:\n0: def djb2(s: str) -> int:     hash_value = 5381     for x in s:         hash_value = ((hash_value << 5) + hash_value) + ord(x)     return hash_value & 0xFFFFFFFF\n1: def union_set(x: Node, y: Node) -> None:     x, y = find_set(x), find_set(y)     if x == y:         return      elif x.rank > y.rank:         y.parent = x     else:         x.parent = y         if x.rank == y.rank:             y.rank += 1\n2: def decimal_to_ipv4(decimal_ipv4: int) -> str:      if not (0 <= decimal_ipv4 <= 4294967295):         raise ValueError(\"Invalid decimal IPv4 address\")      ip_parts = []     for _ in range(4):         ip_parts.append(str(decimal_ipv4 & 255))         decimal_ipv4 >>= 8      return \".\".join(reversed(ip_parts))", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    -1\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return -1\n    else:\n        return \"\".join(l1)", "output": "def compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    'X'\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return \"X\"\n    else:\n        return \"\".join(l1)"}
{"task": "summary", "input": "summarize code:\ndef non_bouncy_upto(n: int) -> int:\n    return sum(non_bouncy_exact(i) for i in range(1, n + 1))", "output": "Calculate the number of non-bouncy numbers with at most n digits."}
{"task": "detection", "input": "classify code:\ndef jaro_winkler(str1: str, str2: str) -> float:\n    \"\"\"\n    Jaro-Winkler distance is a string metric measuring an edit distance between two\n    sequences.\n    Output value is between 0.0 and 1.0.\n\n    >>> jaro_winkler(\"martha\", \"marhta\")\n    0.9611111111111111\n    >>> jaro_winkler(\"CRATE\", \"TRACE\")\n    0.7333333333333334\n    >>> jaro_winkler(\"test\", \"dbdbdbdb\")\n    0.0\n    >>> jaro_winkler(\"test\", \"test\")\n    1.0\n    >>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n    0.6363636363636364\n    >>> jaro_winkler(\"test\", \"\")\n    0.0\n    >>> jaro_winkler(\"hello\", \"world\")\n    0.4666666666666666\n    >>> jaro_winkler(\"hell**o\", \"*world\")\n    0.4365079365079365\n    \"\"\"\n\n    def get_matched_characters(_str1: str, _str2: str) -> str:\n        matched = []\n        limit = min(len(_str1), len(_str2)) // 2\n        for i, char in enumerate(_str1):\n            left = int(max(0, i - limit))\n            right = int(min(i + limit + 1, len(_str2)))\n            if char in _str2[left:right]:\n                matched.append(char)\n                _str2 = (\n                    f\"{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}\"\n                )\n\n        return \"\".join(matched)\n\n    # matching characters\n    matching_1 = get_matched_characters(str1, str2)\n    matching_2 = get_matched_characters(str2, str1)\n    match_count = len(matching_1)\n\n    # transposition\n    transpositions = (\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\n    )\n\n    if not match_count:\n        jaro = 0.0\n    else:\n        jaro = (\n            1\n            / 3\n            * (\n                match_count / len(str1)\n                + match_count / len(str2)\n                + (match_count - transpositions) / match_count\n            )\n        )\n\n    # common prefix up to 4 characters\n    prefix_len = 0\n    for c1, c2 in zip(str1[:4], str2[:4]):\n        if c1 == c2:\n            prefix_len += 1\n        else:\n            break\n\n    return jaro + 0.1 * prefix_len * (1 - jaro)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid's Algorithm\n\n    >>> greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    >>> greatest_common_divisor(121, 11)\n    11\n\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while a % b != 0:\n        a, b = b, a % b\n\n    return b", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef data_safety_checker(list_vote: list, actual_result: float) -> None:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2,3,4],5.0)\n    Today's data is not safe.\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe = safe + 1\n            else:\n                not_safe = not_safe + 1\n    print(f\"Today's data is {'not ' if safe <= not_safe else ''}safe.\")", "output": "def data_safety_checker(list_vote: list, actual_result: float) -> bool:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2, 3, 4], 5.0)\n    False\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe += 1\n            else:\n                not_safe += 1\n    return safe > not_safe"}
{"task": "summary", "input": "summarize code:\ndef newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force", "output": "Calculates force from `mass` and `acceleration`"}
{"task": "search", "input": "search code:\nReturns a sorted list of positive integers based on\n\nChoices:\n0: def decimal_to_octal(num: int) -> str:     octal = 0     counter = 0     while num > 0:         remainder = num % 8         octal = octal + (remainder * math.floor(math.pow(10, counter)))         counter += 1         num = math.floor(num / 8)  # basically /= 8 without remainder if any         # This formatting removes trailing '.0' from `octal`.     return f\"0o{int(octal)}\"\n1: def parse_int_list(range_string, delim=',', range_delim='-'):     output = []      for x in range_string.strip().split(delim):          # Range         if range_delim in x:             range_limits = list(map(int, x.split(range_delim)))             output += list(range(min(range_limits), max(range_limits)+1))          # Empty String         elif not x:             continue          # Integer         else:             output.append(int(x))      return sorted(output)\n2: def n_input_and_gate(inputs: list[int]) -> int:     return int(all(inputs))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef some(seq):\n    for e in seq:\n        if e:\n            return e\n    return False", "output": "Return some element of seq that is true."}
{"task": "search", "input": "search code:\nApplies sigmoid activation function.\n\nChoices:\n0: def total_frequency_distribution(sides_number: int, dice_number: int) -> list[int]:      max_face_number = sides_number     max_total = max_face_number * dice_number     totals_frequencies = [0] * (max_total + 1)      min_face_number = 1     faces_numbers = range(min_face_number, max_face_number + 1)     for dice_numbers in product(faces_numbers, repeat=dice_number):         total = sum(dice_numbers)         totals_frequencies[total] += 1      return totals_frequencies\n1: def sigmoid(value: np.ndarray) -> np.ndarray:     return 1 / (1 + np.exp(-value))\n2: def encode(plaintext: str, key: str) -> str:      table = generate_table(key)     plaintext = prepare_input(plaintext)     ciphertext = \"\"      for char1, char2 in chunker(plaintext, 2):         row1, col1 = divmod(table.index(char1), 5)         row2, col2 = divmod(table.index(char2), 5)          if row1 == row2:             ciphertext += table[row1 * 5 + (col1 + 1) % 5]             ciphertext += table[row2 * 5 + (col2 + 1) % 5]         elif col1 == col2:             ciphertext += table[((row1 + 1) % 5) * 5 + col1]             ciphertext += table[((row2 + 1) % 5) * 5 + col2]         else:  # rectangle             ciphertext += table[row1 * 5 + col2]             ciphertext += table[row2 * 5 + col1]      return ciphertext", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp", "output": "def ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp"}
{"task": "detection", "input": "classify code:\ndef max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum([15, 2, 11, 7], 13)\n    [1, 2]\n    >>> two_sum([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum([7, 15, 11, 2], 18)\n    [0, 2]\n    >>> two_sum([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum([2, 7, 11, 15], 8)\n    []\n    >>> two_sum([3 * i for i in range(10)], 19)\n    []\n    \"\"\"\n    chk_map: dict[int, int] = {}\n    for index, val in enumerate(nums):\n        compl = target - val\n        if compl in chk_map:\n            return [chk_map[compl], index]\n        chk_map[val] = index\n    return []", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))", "output": "def get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))"}
{"task": "search", "input": "search code:\nCalculate the volume of the intersection of two spheres.\n\nChoices:\n0: def insert_next(collection: list, index: int):     # Checks order between adjacent elements     if index >= len(collection) or collection[index - 1] <= collection[index]:         return      # Swaps adjacent elements since they are not in ascending order     collection[index - 1], collection[index] = (         collection[index],         collection[index - 1],     )      insert_next(collection, index + 1)\n1: def vol_spheres_intersect(     radius_1: float, radius_2: float, centers_distance: float ) -> float:     if radius_1 < 0 or radius_2 < 0 or centers_distance < 0:         raise ValueError(\"vol_spheres_intersect() only accepts non-negative values\")     if centers_distance == 0:         return vol_sphere(min(radius_1, radius_2))      h1 = (         (radius_1 - radius_2 + centers_distance)         * (radius_1 + radius_2 - centers_distance)         / (2 * centers_distance)     )     h2 = (         (radius_2 - radius_1 + centers_distance)         * (radius_2 + radius_1 - centers_distance)         / (2 * centers_distance)     )      return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)\n2: def resistor_series(resistors: list[float]) -> float:     sum_r = 0.00     for index, resistor in enumerate(resistors):         sum_r += resistor         if resistor < 0:             msg = f\"Resistor at index {index} has a negative value!\"             raise ValueError(msg)     return sum_r", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef naturaltime(\n    value,\n    future=False,\n    months=True,\n    minimum_unit=\"seconds\",\n    when=None,\n) -> str:\n    now = when or _now()\n    date, delta = _date_and_delta(value, now=now)\n    if date is None:\n        return value\n    # determine tense by value only if datetime/timedelta were passed\n    if isinstance(value, (dt.datetime, dt.timedelta)):\n        future = date > now\n\n    ago = _(\"%s from now\") if future else _(\"%s ago\")\n    delta = naturaldelta(delta, months, minimum_unit)\n\n    if delta == _(\"a moment\"):\n        return _(\"now\")\n\n    return ago % delta", "output": "Return a natural representation of a time in a resolution that makes sense."}
{"task": "repair", "input": "fix bug:\ndef get_pascal_triangle_unique_coefficients(depth: int) -> Set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients", "output": "def get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    num_points: int = 5000\n    cube_size: float = 10.0  # Size of the hypercube (edge length)\n    num_dimensions: int = 10\n\n    # Generate random points within the hypercube\n    points: np.ndarray = hypercube_points(num_points, cube_size, num_dimensions)\n    hypercube_kdtree = build_kdtree(points.tolist())\n\n    # Generate a random query point within the same space\n    rng = np.random.default_rng()\n    query_point: list[float] = rng.random(num_dimensions).tolist()\n\n    # Perform nearest neighbor search\n    nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(\n        hypercube_kdtree, query_point\n    )\n\n    # Print the results\n    print(f\"Query point: {query_point}\")\n    print(f\"Nearest point: {nearest_point}\")\n    print(f\"Distance: {nearest_dist:.4f}\")\n    print(f\"Nodes visited: {nodes_visited}\")", "output": "Demonstrates the use of KD-Tree by building it from random points"}
{"task": "search", "input": "search code:\nCalculates the first n (0-indexed) Fibonacci numbers using recursion\n\nChoices:\n0: def print_pascal_triangle(num_rows: int) -> None:     triangle = generate_pascal_triangle(num_rows)     for row_idx in range(num_rows):         # Print left spaces         for _ in range(num_rows - row_idx - 1):             print(end=\" \")         # Print row values         for col_idx in range(row_idx + 1):             if col_idx != row_idx:                 print(triangle[row_idx][col_idx], end=\" \")             else:                 print(triangle[row_idx][col_idx], end=\"\")         print()\n1: def fib_recursive(n: int) -> list[int]:      def fib_recursive_term(i: int) -> int:         if i < 0:             raise ValueError(\"n is negative\")         if i < 2:             return i         return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)      if n < 0:         raise ValueError(\"n is negative\")     return [fib_recursive_term(i) for i in range(n + 1)]\n2: def solution(n: int = 1000000):     total = 0      for i in range(1, n):         if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):             total += i     return total", "output": "1"}
{"task": "detection", "input": "classify code:\ndef largest_divisible_subset(items: list[int]) -> list[int]:\n    \"\"\"\n    Algorithm to find the biggest subset in the given array such that for any 2 elements\n    x and y in the subset, either x divides y or y divides x.\n    >>> largest_divisible_subset([1, 16, 7, 8, 4])\n    [16, 8, 4, 1]\n    >>> largest_divisible_subset([1, 2, 3])\n    [2, 1]\n    >>> largest_divisible_subset([-1, -2, -3])\n    [-3]\n    >>> largest_divisible_subset([1, 2, 4, 8])\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset((1, 2, 4, 8))\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset([1, 1, 1])\n    [1, 1, 1]\n    >>> largest_divisible_subset([0, 0, 0])\n    [0, 0, 0]\n    >>> largest_divisible_subset([-1, -1, -1])\n    [-1, -1, -1]\n    >>> largest_divisible_subset([])\n    []\n    \"\"\"\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef validate_adjacency_list(graph: list[list[int | None]]) -> None:\n    if not isinstance(graph, list):\n        raise ValueError(\"Graph should be a list of lists.\")\n\n    for node_index, neighbors in enumerate(graph):\n        if not isinstance(neighbors, list):\n            no_neighbors_message: str = (\n                f\"Node {node_index} should have a list of neighbors.\"\n            )\n            raise ValueError(no_neighbors_message)\n        for neighbor_index in neighbors:\n            if (\n                not isinstance(neighbor_index, int)\n                or neighbor_index < 0\n                or neighbor_index >= len(graph)\n            ):\n                invalid_neighbor_message: str = (\n                    f\"Invalid neighbor {neighbor_index} in node {node_index} \"\n                    f\"adjacency list.\"\n                )\n                raise ValueError(invalid_neighbor_message)", "output": "Validates the adjacency list format for the graph."}
{"task": "search", "input": "search code:\nImplementation of pigeon hole sort algorithm\n\nChoices:\n0: def zero_vector(dimension: int) -> Vector:     # precondition     assert isinstance(dimension, int)     return Vector([0] * dimension)\n1: def pigeon_sort(array: list[int]) -> list[int]:     if len(array) == 0:         return array      _min, _max = min(array), max(array)      # Compute the variables     holes_range = _max - _min + 1     holes, holes_repeat = [0] * holes_range, [0] * holes_range      # Make the sorting.     for i in array:         index = i - _min         holes[index] = i         holes_repeat[index] += 1      # Makes the array back by replacing the numbers.     index = 0     for i in range(holes_range):         while holes_repeat[i] > 0:             array[index] = holes[i]             index += 1             holes_repeat[i] -= 1      # Returns the sorted array.     return array\n2: def iter_merge_sort(input_list: list) -> list:     if len(input_list) <= 1:         return input_list     input_list = list(input_list)      # iteration for two-way merging     p = 2     while p <= len(input_list):         # getting low, high and middle value for merge-sort of single list         for i in range(0, len(input_list), p):             low = i             high = i + p - 1             mid = (low + high + 1) // 2             input_list = merge(input_list, low, mid, high)         # final merge of last two parts         if p * 2 >= len(input_list):             mid = i             input_list = merge(input_list, 0, mid, len(input_list) - 1)             break         p *= 2      return input_list", "output": "1"}
{"task": "detection", "input": "classify code:\ndef geometric_series(nth_term: int, start_term_a: int, common_ratio_r: int) -> list:\n    \"\"\"Pure Python implementation of Geometric Series algorithm\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, '4.41', '9.261000000000001', '19.448100000000004']\n    >>> geometric_series(4, 2, -2)\n    [2, '-4.0', '8.0', '-16.0']\n    >>> geometric_series(4, -2, 2)\n    [-2, '-4.0', '-8.0', '-16.0']\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if \"\" in (nth_term, start_term_a, common_ratio_r):\n        return \"\"\n    series = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(str(float(start_term_a) * float(multiple)))\n            multiple = pow(float(common_ratio_r), power)\n    return series", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n    \"\"\"[summary]\n\n    This function will take input of drug name and zipcode,\n    then request to the BASE_URL site.\n    Get the page data and scrape it to generate the\n    list of the lowest prices for the prescription drug.\n\n    Args:\n        drug_name (str): [Drug name]\n        zip_code(str): [Zip code]\n\n    Returns:\n        list: [List of pharmacy name and price]\n\n    >>> print(fetch_pharmacy_and_price_list(None, None))\n    None\n    >>> print(fetch_pharmacy_and_price_list(None, 30303))\n    None\n    >>> print(fetch_pharmacy_and_price_list(\"eliquis\", None))\n    None\n    \"\"\"\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None", "output": "def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n    \"\"\"[summary]\n\n    This function will take input of drug name and zipcode,\n    then request to the BASE_URL site.\n    Get the page data and scrape it to generate the\n    list of the lowest prices for the prescription drug.\n\n    Args:\n        drug_name (str): [Drug name]\n        zip_code(str): [Zip code]\n\n    Returns:\n        list: [List of pharmacy name and price]\n\n    >>> print(fetch_pharmacy_and_price_list(None, None))\n    None\n    >>> print(fetch_pharmacy_and_price_list(None, 30303))\n    None\n    >>> print(fetch_pharmacy_and_price_list(\"eliquis\", None))\n    None\n    \"\"\"\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None"}
{"task": "search", "input": "search code:\nReturn the lowest common ancestor between u and v\n\nChoices:\n0: def lowest_common_ancestor(     u: int, v: int, level: list[int], parent: list[list[int]] ) -> int:     # u must be deeper in the tree than v     if level[u] < level[v]:         u, v = swap(u, v)     # making depth of u same as depth of v     for i in range(18, -1, -1):         if level[u] - (1 << i) >= level[v]:             u = parent[i][u]     # at the same depth if u==v that mean lca is found     if u == v:         return u     # moving both nodes upwards till lca in found     for i in range(18, -1, -1):         if parent[i][u] not in [0, parent[i][v]]:             u, v = parent[i][u], parent[i][v]     # returning longest common ancestor of u,v     return parent[0][u]\n1: def unquote_to_bytes(string):     # Note: strings are encoded as UTF-8. This is only an issue if it contains     # unescaped non-ASCII characters, which URIs should not.     if not string:         # Is it a string-like object?         string.split         return b''     if isinstance(string, str):         string = string.encode('utf-8')     bits = string.split(b'%')     if len(bits) == 1:         return string     # import pdb;pdb.set_trace()     res = [bits[0]]     append = res.append      for item in bits[1:]:         try:             append(_HEX_CHAR_MAP[item[:2]])             append(item[2:])         except KeyError:             append(b'%')             append(item)     return b''.join(res)\n2: def open_knight_tour_helper(     board: list[list[int]], pos: tuple[int, int], curr: int ) -> bool:      if is_complete(board):         return True      for position in get_valid_pos(pos, len(board)):         y, x = position          if board[y][x] == 0:             board[y][x] = curr + 1             if open_knight_tour_helper(board, position, curr + 1):                 return True             board[y][x] = 0      return False", "output": "0"}
{"task": "detection", "input": "classify code:\ndef is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef is_bit_set(number: int, position: int) -> bool:\n    return ((number >> position) & 1) == 1", "output": "Is the bit at position set?"}
{"task": "repair", "input": "fix bug:\ndef maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)", "output": "def maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)"}
{"task": "summary", "input": "summarize code:\ndef search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:\n    right = right or len(list_data) - 1\n    if left > right:\n        return -1\n    elif list_data[left] == key:\n        return left\n    elif list_data[right] == key:\n        return right\n    else:\n        return search(list_data, key, left + 1, right - 1)", "output": "Iterate through the array to find the index of key using recursion."}
{"task": "repair", "input": "fix bug:\ndef text_justification(word: str, max_width: int) -> list:\n    \"\"\"\n    Will format the string such that each line has exactly\n    (max_width) characters and is fully (left and right) justified,\n    and return the list of justified text.\n\n    example 1:\n    string = \"This is an example of text justification.\"\n    max_width = 16\n\n    output = ['This    is    an',\n              'example  of text',\n              'justification.  ']\n\n    >>> text_justification(\"This is an example of text justification.\", 16)\n    ['This    is    an', 'example  of text', 'justification.  ']\n\n    example 2:\n    string = \"Two roads diverged in a yellow wood\"\n    max_width = 16\n    output = ['Two        roads',\n              'diverged   in  a',\n              'yellow wood     ']\n\n    >>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n    ['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\n    Time complexity: O(m*n)\n    Space complexity: O(m*n)\n    \"\"\"\n\n    # Converting string into list of strings split by a space\n    words = word.split()\n\n    def justify(line: list, width: int, max_width: int) -> str:\n        overall_spaces_count = max_width - width\n        words_count = len(line)\n        if len(line) == 1:\n            # if there is only word in line\n            # just insert overall_spaces_count for the remainder of line\n            return line[0] + \" \" * overall_spaces_count\n        else:\n            spaces_to_insert_between_words = words_count - 1\n            # num_spaces_between_words_list[i] : tells you to insert\n            # num_spaces_between_words_list[i] spaces\n            # after word on line[i]\n            num_spaces_between_words_list = spaces_to_insert_between_words * [\n                overall_spaces_count // spaces_to_insert_between_words\n            ]\n            spaces_count_in_locations = (\n                overall_spaces_count % spaces_to_insert_between_words\n            )\n            # distribute spaces via round robin to the left words\n            for i in range(spaces_count_in_locations):\n                num_spaces_between_words_list[i] += 1\n            aligned_words_list = []\n            for i in range(spaces_to_insert_between_words):\n                # add the word\n                aligned_words_list.append(line[i])\n                # add the spaces to insert\n                aligned_words_list.append(num_spaces_between_words_list[i] * \" \")\n            # just add the last word to the sentence\n            aligned_words_list.append(line[-1])\n            # join the aligned words list to form a justified line\n            return \"\".join(aligned_words_list)\n\n    answer = []\n    line: list[str] = []\n    width = 0\n    for inner_word in words:\n        if width + len(inner_word) + len(line) <= max_width:\n            # keep adding words until we can fill out max_width\n            # width = sum of length of all words (without overall_spaces_count)\n            # len(inner_word) = length of current inner_word\n            # len(line) = number of overall_spaces_count to insert between words\n            line.append(inner_word)\n            width += len(inner_word)\n        else:\n            # justify the line and add it to result\n            answer.append(justify(line, width, max_width))\n            # reset new line and new width\n            line, width = [inner_word], len(inner_word)\n    remaining_spaces = max_width - width - len(line)\n    answer.append(\" \".join(line) + (remaining_spaces + 1) * \" \")\n    return answer", "output": "def text_justification(word: str, max_width: int) -> list:\n    \"\"\"\n    Will format the string such that each line has exactly\n    (max_width) characters and is fully (left and right) justified,\n    and return the list of justified text.\n\n    example 1:\n    string = \"This is an example of text justification.\"\n    max_width = 16\n\n    output = ['This    is    an',\n              'example  of text',\n              'justification.  ']\n\n    >>> text_justification(\"This is an example of text justification.\", 16)\n    ['This    is    an', 'example  of text', 'justification.  ']\n\n    example 2:\n    string = \"Two roads diverged in a yellow wood\"\n    max_width = 16\n    output = ['Two        roads',\n              'diverged   in  a',\n              'yellow wood     ']\n\n    >>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n    ['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\n    Time complexity: O(m*n)\n    Space complexity: O(m*n)\n    \"\"\"\n\n    # Converting string into list of strings split by a space\n    words = word.split()\n\n    def justify(line: list, width: int, max_width: int) -> str:\n        overall_spaces_count = max_width - width\n        words_count = len(line)\n        if len(line) == 1:\n            # if there is only word in line\n            # just insert overall_spaces_count for the remainder of line\n            return line[0] + \" \" * overall_spaces_count\n        else:\n            spaces_to_insert_between_words = words_count - 1\n            # num_spaces_between_words_list[i] : tells you to insert\n            # num_spaces_between_words_list[i] spaces\n            # after word on line[i]\n            num_spaces_between_words_list = spaces_to_insert_between_words * [\n                overall_spaces_count // spaces_to_insert_between_words\n            ]\n            spaces_count_in_locations = (\n                overall_spaces_count % spaces_to_insert_between_words\n            )\n            # distribute spaces via round robin to the left words\n            for i in range(spaces_count_in_locations):\n                num_spaces_between_words_list[i] += 1\n            aligned_words_list = []\n            for i in range(spaces_to_insert_between_words):\n                # add the word\n                aligned_words_list.append(line[i])\n                # add the spaces to insert\n                aligned_words_list.append(num_spaces_between_words_list[i] * \" \")\n            # just add the last word to the sentence\n            aligned_words_list.append(line[-1])\n            # join the aligned words list to form a justified line\n            return \"\".join(aligned_words_list)\n\n    answer = []\n    line: list[str] = []\n    width = 0\n    for inner_word in words:\n        if width + len(inner_word) + len(line) <= max_width:\n            # keep adding words until we can fill out max_width\n            # width = sum of length of all words (without overall_spaces_count)\n            # len(inner_word) = length of current inner_word\n            # len(line) = number of overall_spaces_count to insert between words\n            line.append(inner_word)\n            width += len(inner_word)\n        else:\n            # justify the line and add it to result\n            answer.append(justify(line, width, max_width))\n            # reset new line and new width\n            line, width = [inner_word], len(inner_word)\n    remaining_spaces = max_width - width - len(line)\n    answer.append(\" \".join(line) + (remaining_spaces + 1) * \" \")\n    return answer"}
{"task": "detection", "input": "classify code:\ndef odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn the solution to the problem\n\nChoices:\n0: def solution(n: int = 1000000) -> int:      result = max((collatz_sequence_length(i), i) for i in range(1, n))     return result[1]\n1: def solution() -> int:     return compute_nums(1)[0]\n2: def benchmark() -> None:     from timeit import timeit      setup = \"from __main__ import is_pangram, is_pangram_faster, is_pangram_fastest\"     print(timeit(\"is_pangram()\", setup=setup))     print(timeit(\"is_pangram_faster()\", setup=setup))     print(timeit(\"is_pangram_fastest()\", setup=setup))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n    \"\"\"\n    n = len(nums)\n    missing_number = n\n\n    for i in range(n):\n        missing_number ^= i ^ nums[i]\n\n    return missing_number", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFunction implements adler-32 hash.\n\nChoices:\n0: def random_chars(number_char: int = 32) -> str:     assert number_char > 1, \"The number of character should greater than 1\"     letter_code = ascii_lowercase + digits     return \"\".join(random.choice(letter_code) for _ in range(number_char))\n1: def partition(pred, iterable):     if pred is None:         pred = bool      t1, t2, p = tee(iterable, 3)     p1, p2 = tee(map(pred, p))     return (compress(t1, map(not_, p1)), compress(t2, p2))\n2: def adler32(plain_text: str) -> int:     a = 1     b = 0     for plain_chr in plain_text:         a = (a + ord(plain_chr)) % MOD_ADLER         b = (b + a) % MOD_ADLER     return (b << 16) | a", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef bisect_left(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "def bisect_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo"}
{"task": "summary", "input": "summarize code:\ndef lin_search(left: int, right: int, array: list[int], target: int) -> int:\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1", "output": "Perform linear search in list. Returns -1 if element is not found."}
{"task": "detection", "input": "classify code:\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    >>> is_palindrome(\"Able was I ere I saw Elba\")\n    True\n    >>> is_palindrome(\"racecar\")\n    True\n    >>> is_palindrome(\"Mr. Owl ate my metal worm?\")\n    True\n    \"\"\"\n    # Since Punctuation, capitalization, and spaces are usually ignored while checking Palindrome,\n    # we first remove them from our string.\n    s = \"\".join([character for character in s.lower() if character.isalnum()])\n    return s == s[::-1]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution(n_limit: int = 50 * 10**6) -> int:\n    n_sol = [0] * n_limit\n\n    for delta in range(1, (n_limit + 1) // 4 + 1):\n        for y in range(4 * delta - 1, delta, -1):\n            n = y * (4 * delta - y)\n            if n >= n_limit:\n                break\n            n_sol[n] += 1\n\n    ans = 0\n    for i in range(n_limit):\n        if n_sol[i] == 1:\n            ans += 1\n\n    return ans", "output": "Define n count list and loop over delta, y to get the counts, then check"}
{"task": "repair", "input": "fix bug:\ndef max_difference(a: List[int]) -> (int, int):\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second", "output": "def max_difference(a: list[int]) -> tuple[int, int]:\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second"}
{"task": "search", "input": "search code:\n[summary]\n\nChoices:\n0: def solution(max_d: int = 12_000) -> int:      fractions_number = 0     for d in range(max_d + 1):         n_start = d // 3 + 1         n_step = 1         if d % 2 == 0:             n_start += 1 - n_start % 2             n_step = 2         for n in range(n_start, (d + 1) // 2, n_step):             if gcd(n, d) == 1:                 fractions_number += 1     return fractions_number\n1: def shell_sort(collection: list[int]) -> list[int]:     # Marcin Ciura's gap sequence      gaps = [701, 301, 132, 57, 23, 10, 4, 1]     for gap in gaps:         for i in range(gap, len(collection)):             insert_value = collection[i]             j = i             while j >= gap and collection[j - gap] > insert_value:                 collection[j] = collection[j - gap]                 j -= gap             if j != i:                 collection[j] = insert_value     return collection\n2: def search_anime_episode_list(episode_endpoint: str) -> list:      request_url = f\"{BASE_URL}{episode_endpoint}\"      response = httpx.get(         url=request_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10     )     response.raise_for_status()      soup = BeautifulSoup(response.text, \"html.parser\")      # With this id. get the episode list.     episode_page_ul = soup.find(\"ul\", {\"id\": \"episode_related\"})     if episode_page_ul is None or isinstance(episode_page_ul, NavigableString):         msg = f\"Could not find any anime eposiodes with name {anime_name}\"         raise ValueError(msg)     episode_page_li = episode_page_ul.children      episode_list = []     for episode in episode_page_li:         if isinstance(episode, Tag):             url = episode.find(\"a\")             if url is None or isinstance(url, NavigableString):                 continue             title = episode.find(\"div\", {\"class\": \"name\"})             if title is None or isinstance(title, NavigableString):                 continue              episode_list.append(                 {\"title\": title.text.replace(\" \", \"\"), \"url\": url[\"href\"]}             )      return episode_list", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef cycle_sort(array):\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return ans", "output": "def cycle_sort(array: list) -> list:\n    \"\"\"\n    >>> cycle_sort([4, 3, 2, 1])\n    [1, 2, 3, 4]\n\n    >>> cycle_sort([-4, 20, 0, -50, 100, -1])\n    [-50, -4, -1, 0, 20, 100]\n\n    >>> cycle_sort([-.1, -.2, 1.3, -.8])\n    [-0.8, -0.2, -0.1, 1.3]\n\n    >>> cycle_sort([])\n    []\n    \"\"\"\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return array"}
{"task": "summary", "input": "summarize code:\ndef parse_file(file_path: str) -> list[Letter]:\n    chars: dict[str, int] = {}\n    with open(file_path) as f:\n        while True:\n            c = f.read(1)\n            if not c:\n                break\n            chars[c] = chars[c] + 1 if c in chars else 1\n    return sorted((Letter(c, f) for c, f in chars.items()), key=lambda x: x.freq)", "output": "Read the file and build a dict of all letters and their"}
{"task": "detection", "input": "classify code:\ndef get_squared_primes_to_use(\n    num_to_look: int, squared_primes: List[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx", "output": "BUGGY"}
{"task": "search", "input": "search code:\nDetermines whether number is prime\n\nChoices:\n0: def is_prime(number: int) -> bool:      return all(number % divisor != 0 for divisor in range(2, isqrt(number) + 1))\n1: def get_cost_derivative(index):     cost_derivative_value = summation_of_cost_derivative(index, m) / m     return cost_derivative_value\n2: def in_static_equilibrium(     forces: NDArray[float64], location: NDArray[float64], eps: float = 10**-1 ) -> bool:     # summation of moments is zero     moments: NDArray[float64] = cross(location, forces)     sum_moments: float = sum(moments)     return bool(abs(sum_moments) < eps)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef emails_from_url(url: str = \"https://github.com\") -> list[str]:\n    # Get the base domain from the url\n    domain = get_domain_name(url)\n\n    # Initialize the parser\n    parser = Parser(domain)\n\n    try:\n        # Open URL\n        r = httpx.get(url, timeout=10, follow_redirects=True)\n\n        # pass the raw HTML to the parser to get links\n        parser.feed(r.text)\n\n        # Get links and loop through\n        valid_emails = set()\n        for link in parser.urls:\n            # open URL.\n            # Check if the link is already absolute\n            if not link.startswith(\"http://\") and not link.startswith(\"https://\"):\n                # Prepend protocol only if link starts with domain, normalize otherwise\n                if link.startswith(domain):\n                    link = f\"https://{link}\"\n                else:\n                    link = parse.urljoin(f\"https://{domain}\", link)\n            try:\n                read = httpx.get(link, timeout=10, follow_redirects=True)\n                # Get the valid email.\n                emails = re.findall(\"[a-zA-Z0-9]+@\" + domain, read.text)\n                # If not in list then append it.\n                for email in emails:\n                    valid_emails.add(email)\n            except ValueError:\n                pass\n    except ValueError:\n        raise SystemExit(1)\n\n    # Finally return a sorted list of email addresses with no duplicates.\n    return sorted(valid_emails)", "output": "This function takes url and return all valid urls"}
{"task": "detection", "input": "classify code:\ndef simple_fibonacci(n, f1, f2):\n    \"\"\"\n    Returns the nth number of the Fibonacci sequence that\n    starts with f1 and f2\n    Uses the definition\n    >>> simple_fibonacci(1, 5, 6)\n    5\n    >>> simple_fibonacci(2, 10, 11)\n    11\n    >>> simple_fibonacci(13, 0, 1)\n    144\n    >>> simple_fibonacci(10, 5, 9)\n    411\n    >>> simple_fibonacci(9, 2, 3)\n    89\n    \"\"\"\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    n -= 2\n\n    while n > 0:\n        f2, f1 = f1 + f2, f2\n        n -= 1\n\n    return f2", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef identity(n: int) -> List[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]", "output": "def identity(n: int) -> list[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]"}
{"task": "search", "input": "search code:\nCalculates the work required to move an object from one orbit to another in a\n\nChoices:\n0: def orbital_transfer_work(     mass_central: float, mass_object: float, r_initial: float, r_final: float ) -> str:     gravitational_constant = 6.67430e-11      if r_initial <= 0 or r_final <= 0:         raise ValueError(\"Orbital radii must be greater than zero.\")      work = (gravitational_constant * mass_central * mass_object / 2) * (         1 / r_initial - 1 / r_final     )     return f\"{work:.3e}\"\n1: def mf_knapsack(i, wt, val, j):     global f  # a global dp table for knapsack     if f[i][j] < 0:         if j < wt[i - 1]:             val = mf_knapsack(i - 1, wt, val, j)         else:             val = max(                 mf_knapsack(i - 1, wt, val, j),                 mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],             )         f[i][j] = val     return f[i][j]\n2: def erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:     output = np.zeros_like(image)     image_padded = np.zeros(         (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)     )      # Copy image to padded image     image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image      # Iterate over image & apply kernel     for x in range(image.shape[1]):         for y in range(image.shape[0]):             summation = (                 kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]             ).sum()             output[y, x] = int(summation == 5)     return output", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef is_prime(n: int) -> bool:\n    return sieve[n]", "output": "For 2 <= n <= 1000000, return True if n is prime."}
{"task": "detection", "input": "classify code:\ndef calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "output": "BUGGY"}
{"task": "search", "input": "search code:\nUtility-function to check that two hsv-colors are approximately equal\n\nChoices:\n0: def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:     check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2     check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002     check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002      return check_hue and check_saturation and check_value\n1: def euler_phi(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = n     for x in set(prime_factors(n)):         s *= (x - 1) / x     return int(s)\n2: def iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:     vectors = initial_vectors     for _ in range(steps):         vectors = iteration_step(vectors)     return vectors", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x", "output": "def equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x"}
{"task": "detection", "input": "classify code:\ndef max_difference(a: List[int]) -> (int, int):\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second", "output": "BUGGY"}
{"task": "search", "input": "search code:\nThis function can calculate any one of the three -\n\nChoices:\n0: def electric_conductivity(     conductivity: float,     electron_conc: float,     mobility: float, ) -> tuple[str, float]:     if (conductivity, electron_conc, mobility).count(0) != 1:         raise ValueError(\"You cannot supply more or less than 2 values\")     elif conductivity < 0:         raise ValueError(\"Conductivity cannot be negative\")     elif electron_conc < 0:         raise ValueError(\"Electron concentration cannot be negative\")     elif mobility < 0:         raise ValueError(\"mobility cannot be negative\")     elif conductivity == 0:         return (             \"conductivity\",             mobility * electron_conc * ELECTRON_CHARGE,         )     elif electron_conc == 0:         return (             \"electron_conc\",             conductivity / (mobility * ELECTRON_CHARGE),         )     else:         return (             \"mobility\",             conductivity / (electron_conc * ELECTRON_CHARGE),         )\n1: def minimum_squares_to_represent_a_number(number: int) -> int:     if number != int(number):         raise ValueError(\"the value of input must be a natural number\")     if number < 0:         raise ValueError(\"the value of input must not be a negative number\")     if number == 0:         return 1     answers = [-1] * (number + 1)     answers[0] = 0     for i in range(1, number + 1):         answer = sys.maxsize         root = int(math.sqrt(i))         for j in range(1, root + 1):             current_answer = 1 + answers[i - (j**2)]             answer = min(answer, current_answer)         answers[i] = answer     return answers[number]\n2: def get_child_right_position(position: int) -> int:     return (2 * position) + 2", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef get_failure_array(pattern: str) -> list[int]:\n    failure = [0]\n    i = 0\n    j = 1\n    while j < len(pattern):\n        if pattern[i] == pattern[j]:\n            i += 1\n        elif i > 0:\n            i = failure[i - 1]\n            continue\n        j += 1\n        failure.append(i)\n    return failure", "output": "Calculates the new index we should go to if we fail a comparison"}
{"task": "repair", "input": "fix bug:\ndef counting_sort(collection):\n    \"\"\"Pure implementation of counting sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> counting_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> counting_sort([])\n    []\n    >>> counting_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered", "output": "def counting_sort(collection):\n    \"\"\"Pure implementation of counting sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> counting_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> counting_sort([])\n    []\n    >>> counting_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered"}
{"task": "repair", "input": "fix bug:\ndef peak(lst: List[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])", "output": "def peak(lst: list[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])"}
{"task": "detection", "input": "classify code:\ndef filter_common_word(possibles: list[str], common_word: str) -> list[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns a symmetric positive definite matrix given a dimension.\n\nChoices:\n0: def get_week_day(year: int, month: int, day: int) -> str:     # minimal input check:     assert len(str(year)) > 2, \"year should be in YYYY format\"     assert 1 <= month <= 12, \"month should be between 1 to 12\"     assert 1 <= day <= 31, \"day should be between 1 to 31\"      # Doomsday algorithm:     century = year // 100     century_anchor = (5 * (century % 4) + 2) % 7     centurian = year % 100     centurian_m = centurian % 12     dooms_day = (         (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor     ) % 7     day_anchor = (         DOOMSDAY_NOT_LEAP[month - 1]         if year % 4 != 0 or (centurian == 0 and year % 400 != 0)         else DOOMSDAY_LEAP[month - 1]     )     week_day = (dooms_day + day - day_anchor) % 7     return WEEK_DAY_NAMES[week_day]\n1: def left_rotate_32(i: int, shift: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")     if shift < 0:         raise ValueError(\"Shift must be non-negative\")     return ((i << shift) ^ (i >> (32 - shift))) % 2**32\n2: def _create_spd_matrix(dimension: int) -> Any:     rng = np.random.default_rng()     random_matrix = rng.normal(size=(dimension, dimension))     spd_matrix = np.dot(random_matrix, random_matrix.T)     assert _is_matrix_spd(spd_matrix)     return spd_matrix", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef fibonacci_with_matrix_exponentiation(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n    matrix = Matrix([[1, 1], [1, 0]])\n    matrix = modular_exponentiation(matrix, n - 2)\n    return f2 * matrix.t[0][0] + f1 * matrix.t[0][1]", "output": "Returns the nth number of the Fibonacci sequence that"}
{"task": "summary", "input": "summarize code:\ndef continuous_fraction_period(n: int) -> int:\n    numerator = 0.0\n    denominator = 1.0\n    root = int(sqrt(n))\n    integer_part = root\n    period = 0\n    while integer_part != 2 * root:\n        numerator = denominator * integer_part - numerator\n        denominator = (n - numerator**2) / denominator\n        integer_part = int((root + numerator) / denominator)\n        period += 1\n    return period", "output": "Returns the continued fraction period of a number n."}
{"task": "repair", "input": "fix bug:\ndef get_squared_primes_to_use(\n    num_to_look: int, squared_primes: List[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx", "output": "def get_squared_primes_to_use(\n    num_to_look: int, squared_primes: list[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx"}
{"task": "detection", "input": "classify code:\ndef solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in xrange(1, 1001):\n        total += i ** i\n    return str(total)[-10:]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nArea under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi\n\nChoices:\n0: def edit_distance(source: str, target: str) -> int:     if len(source) == 0:         return len(target)     elif len(target) == 0:         return len(source)      delta = int(source[-1] != target[-1])  # Substitution     return min(         edit_distance(source[:-1], target[:-1]) + delta,         edit_distance(source, target[:-1]) + 1,         edit_distance(source[:-1], target) + 1,     )\n1: def pi_estimator_using_area_under_curve(iterations: int) -> None:      def function_to_integrate(x: float) -> float:         return sqrt(4.0 - x * x)      estimated_value = area_under_curve_estimator(         iterations, function_to_integrate, 0.0, 2.0     )      print(\"******************\")     print(\"Estimating pi using area_under_curve_estimator\")     print(f\"Estimated value is {estimated_value}\")     print(f\"Expected value is {pi}\")     print(f\"Total error is {abs(estimated_value - pi)}\")     print(\"******************\")\n2: def ignore_overflow_warnings() -> None:     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in multiply\"     )     warnings.filterwarnings(         \"ignore\",         category=RuntimeWarning,         message=\"invalid value encountered in multiply\",     )     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in absolute\"     )     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in exp\"     )", "output": "1"}
{"task": "detection", "input": "classify code:\ndef calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times", "output": "BUGGY"}
{"task": "search", "input": "search code:\nChecks if input number and 2*number + 1 are prime.\n\nChoices:\n0: def check_anagrams(first_str: str, second_str: str) -> bool:     first_str = first_str.lower().strip()     second_str = second_str.lower().strip()      # Remove whitespace     first_str = first_str.replace(\" \", \"\")     second_str = second_str.replace(\" \", \"\")      # Strings of different lengths are not anagrams     if len(first_str) != len(second_str):         return False      # Default values for count should be 0     count: defaultdict[str, int] = defaultdict(int)      # For each character in input strings,     # increment count in the corresponding     for i in range(len(first_str)):         count[first_str[i]] += 1         count[second_str[i]] -= 1      return all(_count == 0 for _count in count.values())\n1: def is_germain_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return is_prime(number) and is_prime(2 * number + 1)\n2: def dir_dict(obj, raise_exc=False):     # TODO: separate function for handling descriptors on types?     ret = {}     for k in dir(obj):         try:             ret[k] = getattr(obj, k)         except Exception:             if raise_exc:                 raise     return ret", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef search_anime_episode_list(episode_endpoint: str) -> list:\n\n    request_url = f\"{BASE_URL}{episode_endpoint}\"\n\n    response = httpx.get(\n        url=request_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10\n    )\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    # With this id. get the episode list.\n    episode_page_ul = soup.find(\"ul\", {\"id\": \"episode_related\"})\n    if episode_page_ul is None or isinstance(episode_page_ul, NavigableString):\n        msg = f\"Could not find any anime eposiodes with name {anime_name}\"\n        raise ValueError(msg)\n    episode_page_li = episode_page_ul.children\n\n    episode_list = []\n    for episode in episode_page_li:\n        if isinstance(episode, Tag):\n            url = episode.find(\"a\")\n            if url is None or isinstance(url, NavigableString):\n                continue\n            title = episode.find(\"div\", {\"class\": \"name\"})\n            if title is None or isinstance(title, NavigableString):\n                continue\n\n            episode_list.append(\n                {\"title\": title.text.replace(\" \", \"\"), \"url\": url[\"href\"]}\n            )\n\n    return episode_list", "output": "[summary]"}
{"task": "repair", "input": "fix bug:\ndef is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n    Note: this doesn't check if P and Q are equal, but that's handled by the use of\n    itertools.combinations in the solution function.\n\n    >>> is_right(0, 1, 2, 0)\n    True\n    >>> is_right(1, 0, 2, 2)\n    False\n    \"\"\"\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )", "output": "def is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n    Note: this doesn't check if P and Q are equal, but that's handled by the use of\n    itertools.combinations in the solution function.\n\n    >>> is_right(0, 1, 2, 0)\n    True\n    >>> is_right(1, 0, 2, 2)\n    False\n    \"\"\"\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )"}
{"task": "summary", "input": "summarize code:\ndef run_length_decode(encoded: list) -> str:\n    return \"\".join(char * length for char, length in encoded)", "output": "Performs Run Length Decoding"}
{"task": "detection", "input": "classify code:\ndef combination_sum_iv_dp_array(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef is_balanced(s: str) -> bool:\n    \"\"\"\n    >>> is_balanced(\"\")\n    True\n    >>> is_balanced(\"()\")\n    True\n    >>> is_balanced(\"[]\")\n    True\n    >>> is_balanced(\"{}\")\n    True\n    >>> is_balanced(\"()[]{}\")\n    True\n    >>> is_balanced(\"(())\")\n    True\n    >>> is_balanced(\"[[\")\n    False\n    >>> is_balanced(\"([{}])\")\n    True\n    >>> is_balanced(\"(()[)]\")\n    False\n    >>> is_balanced(\"([)]\")\n    False\n    >>> is_balanced(\"[[()]]\")\n    True\n    >>> is_balanced(\"(()(()))\")\n    True\n    >>> is_balanced(\"]\")\n    False\n    >>> is_balanced(\"Life is a bowl of cherries.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che{}ies.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che}{ies.\")\n    False\n    \"\"\"\n    open_to_closed = {\"{\": \"}\", \"[\": \"]\", \"(\": \")\"}\n    stack = []\n    for symbol in s:\n        if symbol in open_to_closed:\n            stack.append(symbol)\n        elif symbol in open_to_closed.values() and (\n            not stack or open_to_closed[stack.pop()] != symbol\n        ):\n            return False\n    return not stack  # stack should be empty", "output": "def is_balanced(s: str) -> bool:\n    \"\"\"\n    >>> is_balanced(\"\")\n    True\n    >>> is_balanced(\"()\")\n    True\n    >>> is_balanced(\"[]\")\n    True\n    >>> is_balanced(\"{}\")\n    True\n    >>> is_balanced(\"()[]{}\")\n    True\n    >>> is_balanced(\"(())\")\n    True\n    >>> is_balanced(\"[[\")\n    False\n    >>> is_balanced(\"([{}])\")\n    True\n    >>> is_balanced(\"(()[)]\")\n    False\n    >>> is_balanced(\"([)]\")\n    False\n    >>> is_balanced(\"[[()]]\")\n    True\n    >>> is_balanced(\"(()(()))\")\n    True\n    >>> is_balanced(\"]\")\n    False\n    >>> is_balanced(\"Life is a bowl of cherries.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che{}ies.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che}{ies.\")\n    False\n    \"\"\"\n    open_to_closed = {\"{\": \"}\", \"[\": \"]\", \"(\": \")\"}\n    stack = []\n    for symbol in s:\n        if symbol in open_to_closed:\n            stack.append(symbol)\n        elif symbol in open_to_closed.values() and (\n            not stack or open_to_closed[stack.pop()] != symbol\n        ):\n            return False\n    return not stack  # stack should be empty"}
{"task": "search", "input": "search code:\nReturn binary image from gray image\n\nChoices:\n0: def gray_to_binary(gray: np.ndarray) -> np.ndarray:     return (gray > 127) & (gray <= 255)\n1: def netstring_server(server_socket):     \"A basic netstring server loop, supporting a few operations\"     try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock)             while 1:                 request = client.read_ns()                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'reply4k':                     client.write_ns(b'a' * 4096)                 elif request == b'ping':                     client.write_ns(b'pong')                 elif request == b'reply128k':                     client.setmaxsize(128 * 1024)                     client.write_ns(b'huge' * 32 * 1024)  # 128kb                     client.setmaxsize(32768)  # back to default     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise\n2: def solution(limit: int = 999_966_663_333) -> int:     primes_upper_bound = math.floor(math.sqrt(limit)) + 100     primes = prime_sieve(primes_upper_bound)      matches_sum = 0     prime_index = 0     last_prime = primes[prime_index]      while (last_prime**2) <= limit:         next_prime = primes[prime_index + 1]          lower_bound = last_prime**2         upper_bound = next_prime**2          # Get numbers divisible by lps(current)         current = lower_bound + last_prime         while upper_bound > current <= limit:             matches_sum += current             current += last_prime          # Reset the upper_bound         while (upper_bound - next_prime) > limit:             upper_bound -= next_prime          # Add the numbers divisible by ups(current)         current = upper_bound - next_prime         while current > lower_bound:             matches_sum += current             current -= next_prime          # Remove the numbers divisible by both ups and lps         current = 0         while upper_bound > current <= limit:             if current <= lower_bound:                 # Increment the current number                 current += last_prime * next_prime                 continue              if current > limit:                 break              # Remove twice since it was added by both ups and lps             matches_sum -= current * 2              # Increment the current number             current += last_prime * next_prime          # Setup for next pair         last_prime = next_prime         prime_index += 1      return matches_sum", "output": "0"}
{"task": "detection", "input": "classify code:\ndef selection(chart: list[list[int]], prime_implicants: list[str]) -> list[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0", "output": "CORRECT"}
{"task": "search", "input": "search code:\nRecursive function to print a BST from a root table.\n\nChoices:\n0: def solution(n: int = 1000) -> int:     answer = 1     gen = fibonacci_generator()     while len(str(next(gen))) < n:         answer += 1     return answer + 1\n1: def print_binary_search_tree(root, key, i, j, parent, is_left):     if i > j or i < 0 or j > len(root) - 1:         return      node = root[i][j]     if parent == -1:  # root does not have a parent         print(f\"{key[node]} is the root of the binary search tree.\")     elif is_left:         print(f\"{key[node]} is the left child of key {parent}.\")     else:         print(f\"{key[node]} is the right child of key {parent}.\")      print_binary_search_tree(root, key, i, node - 1, key[node], True)     print_binary_search_tree(root, key, node + 1, j, key[node], False)\n2: def longest_common_subsequence(x: str, y: str):     # find the length of strings      assert x is not None     assert y is not None      m = len(x)     n = len(y)      # declaring the array for storing the dp values     dp = [[0] * (n + 1) for _ in range(m + 1)]      for i in range(1, m + 1):         for j in range(1, n + 1):             match = 1 if x[i - 1] == y[j - 1] else 0              dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)      seq = \"\"     i, j = m, n     while i > 0 and j > 0:         match = 1 if x[i - 1] == y[j - 1] else 0          if dp[i][j] == dp[i - 1][j - 1] + match:             if match == 1:                 seq = x[i - 1] + seq             i -= 1             j -= 1         elif dp[i][j] == dp[i - 1][j]:             i -= 1         else:             j -= 1      return dp[m][n], seq", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_", "output": "def elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_"}
{"task": "summary", "input": "summarize code:\ndef traverse_tree(root: Letter | TreeNode, bitstring: str) -> list[Letter]:\n    if isinstance(root, Letter):\n        root.bitstring[root.letter] = bitstring\n        return [root]\n    treenode: TreeNode = root\n    letters = []\n    letters += traverse_tree(treenode.left, bitstring + \"0\")\n    letters += traverse_tree(treenode.right, bitstring + \"1\")\n    return letters", "output": "Recursively traverse the Huffman Tree to set each"}
{"task": "detection", "input": "classify code:\ndef _msd_radix_sort(list_of_ints: List[int], bit_position: int) -> List[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res", "output": "BUGGY"}
{"task": "search", "input": "search code:\nConstructs the convex hull of a set of 2D points using a divide-and-conquer strategy\n\nChoices:\n0: def choose(n: int, r: int) -> int:     ret = 1.0     for i in range(1, r + 1):         ret *= (n + 1 - i) / i     return round(ret)\n1: def res(x, y):     if 0 not in (x, y):         # We use the relation x^y = y*log10(x), where 10 is the base.         return y * math.log10(x)     elif x == 0:  # 0 raised to any number is 0         return 0     elif y == 0:         return 1  # any number raised to 0 is 1     raise AssertionError(\"This should never happen\")\n2: def convex_hull_recursive(points: list[Point]) -> list[Point]:     points = sorted(_validate_input(points))     n = len(points)      # divide all the points into an upper hull and a lower hull     # the left most point and the right most point are definitely     # members of the convex hull by definition.     # use these two anchors to divide all the points into two hulls,     # an upper hull and a lower hull.      # all points to the left (above) the line joining the extreme points belong to the     # upper hull     # all points to the right (below) the line joining the extreme points below to the     # lower hull     # ignore all points on the line joining the extreme points since they cannot be     # part of the convex hull      left_most_point = points[0]     right_most_point = points[n - 1]      convex_set = {left_most_point, right_most_point}     upper_hull = []     lower_hull = []      for i in range(1, n - 1):         det = _det(left_most_point, right_most_point, points[i])          if det > 0:             upper_hull.append(points[i])         elif det < 0:             lower_hull.append(points[i])      _construct_hull(upper_hull, left_most_point, right_most_point, convex_set)     _construct_hull(lower_hull, right_most_point, left_most_point, convex_set)      return sorted(convex_set)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef _ngettext(message, plural, num):\n    return get_translation().ngettext(message, plural, num)", "output": "Plural version of _gettext."}
{"task": "repair", "input": "fix bug:\ndef simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set", "output": "def simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set"}
{"task": "summary", "input": "summarize code:\ndef floyd(n):\n    result = \"\"\n    for i in range(n):\n        for _ in range(n - i - 1):  # printing spaces\n            result += \" \"\n        for _ in range(i + 1):  # printing stars\n            result += \"* \"\n        result += \"\\n\"\n    return result", "output": "Print the upper half of a diamond pattern with '*' characters."}
{"task": "repair", "input": "fix bug:\ndef vol_cube(side_length: Union[int, float]) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)", "output": "def vol_cube(side_length: int | float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)"}
{"task": "search", "input": "search code:\nReturns the number of blue discs for the first arrangement to contain\n\nChoices:\n0: def emitter_converter(size_par, data):     if size_par + len(data) <= 2**size_par - (len(data) - 1):         raise ValueError(\"size of parity don't match with size of data\")      data_out = []     parity = []     bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]      # sorted information data for the size of the output data     data_ord = []     # data position template + parity     data_out_gab = []     # parity bit counter     qtd_bp = 0     # counter position of data bits     cont_data = 0      for x in range(1, size_par + len(data) + 1):         # Performs a template of bit positions - who should be given,         # and who should be parity         if qtd_bp < size_par:             if (np.log(x) / np.log(2)).is_integer():                 data_out_gab.append(\"P\")                 qtd_bp = qtd_bp + 1             else:                 data_out_gab.append(\"D\")         else:             data_out_gab.append(\"D\")          # Sorts the data to the new output size         if data_out_gab[-1] == \"D\":             data_ord.append(data[cont_data])             cont_data += 1         else:             data_ord.append(None)      # Calculates parity     qtd_bp = 0  # parity bit counter     for bp in range(1, size_par + 1):         # Bit counter one for a given parity         cont_bo = 0         # counter to control the loop reading         for cont_loop, x in enumerate(data_ord):             if x is not None:                 try:                     aux = (bin_pos[cont_loop])[-1 * (bp)]                 except IndexError:                     aux = \"0\"                 if aux == \"1\" and x == \"1\":                     cont_bo += 1         parity.append(cont_bo % 2)          qtd_bp += 1      # Mount the message     cont_bp = 0  # parity bit counter     for x in range(size_par + len(data)):         if data_ord[x] is None:             data_out.append(str(parity[cont_bp]))             cont_bp += 1         else:             data_out.append(data_ord[x])      return data_out\n1: def product_sum(arr: list[int | list], depth: int) -> int:     total_sum = 0     for ele in arr:         total_sum += product_sum(ele, depth + 1) if isinstance(ele, list) else ele     return total_sum * depth\n2: def solution(min_total: int = 10**12) -> int:      prev_numerator = 1     prev_denominator = 0      numerator = 1     denominator = 1      while numerator <= 2 * min_total - 1:         prev_numerator += 2 * numerator         numerator += 2 * prev_numerator          prev_denominator += 2 * denominator         denominator += 2 * prev_denominator      return (denominator + 1) // 2", "output": "2"}
{"task": "detection", "input": "classify code:\ndef calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef _gettext(message):\n    return get_translation().gettext(message)", "output": "Get translation."}
{"task": "repair", "input": "fix bug:\ndef calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times", "output": "def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times"}
{"task": "search", "input": "search code:\nDemonstrates the use of KD-Tree by building it from random points\n\nChoices:\n0: def main() -> None:     num_points: int = 5000     cube_size: float = 10.0  # Size of the hypercube (edge length)     num_dimensions: int = 10      # Generate random points within the hypercube     points: np.ndarray = hypercube_points(num_points, cube_size, num_dimensions)     hypercube_kdtree = build_kdtree(points.tolist())      # Generate a random query point within the same space     rng = np.random.default_rng()     query_point: list[float] = rng.random(num_dimensions).tolist()      # Perform nearest neighbor search     nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(         hypercube_kdtree, query_point     )      # Print the results     print(f\"Query point: {query_point}\")     print(f\"Nearest point: {nearest_point}\")     print(f\"Distance: {nearest_dist:.4f}\")     print(f\"Nodes visited: {nodes_visited}\")\n1: def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:     arr.sort()     n = len(arr)     for i in range(n - 1):         left, right = i + 1, n - 1         while left < right:             if arr[i] + arr[left] + arr[right] == target:                 return (arr[i], arr[left], arr[right])             elif arr[i] + arr[left] + arr[right] < target:                 left += 1             elif arr[i] + arr[left] + arr[right] > target:                 right -= 1     return (0, 0, 0)\n2: def iter_merge_sort(input_list: list) -> list:     if len(input_list) <= 1:         return input_list     input_list = list(input_list)      # iteration for two-way merging     p = 2     while p <= len(input_list):         # getting low, high and middle value for merge-sort of single list         for i in range(0, len(input_list), p):             low = i             high = i + p - 1             mid = (low + high + 1) // 2             input_list = merge(input_list, low, mid, high)         # final merge of last two parts         if p * 2 >= len(input_list):             mid = i             input_list = merge(input_list, 0, mid, len(input_list) - 1)             break         p *= 2      return input_list", "output": "0"}
{"task": "search", "input": "search code:\nPure implementation of a binary search algorithm in Python by recursion\n\nChoices:\n0: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n1: def binary_search_by_recursion(     sorted_collection: list[int], item: int, left: int = 0, right: int = -1 ) -> int:     if right < 0:         right = len(sorted_collection) - 1     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     if right < left:         return -1      midpoint = left + (right - left) // 2      if sorted_collection[midpoint] == item:         return midpoint     elif sorted_collection[midpoint] > item:         return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)     else:         return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)\n2: def write_file_binary(file_path: str, to_write: str) -> None:     byte_length = 8     try:         with open(file_path, \"wb\") as opened_file:             result_byte_array = [                 to_write[i : i + byte_length]                 for i in range(0, len(to_write), byte_length)             ]              if len(result_byte_array[-1]) % byte_length == 0:                 result_byte_array.append(\"10000000\")             else:                 result_byte_array[-1] += \"1\" + \"0\" * (                     byte_length - len(result_byte_array[-1]) - 1                 )              for elem in result_byte_array:                 opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))     except OSError:         print(\"File not accessible\")         sys.exit()", "output": "1"}
{"task": "detection", "input": "classify code:\ndef solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution(100)\n    25164150\n    \"\"\"\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef is_square_form(num: int) -> bool:\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True", "output": "Determines if num is in the form 1_2_3_4_5_6_7_8_9"}
{"task": "repair", "input": "fix bug:\ndef kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is Â½mvÂ²\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)", "output": "def kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is Â½mvÂ²\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)"}
{"task": "repair", "input": "fix bug:\ndef binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res", "output": "def binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res"}
{"task": "summary", "input": "summarize code:\ndef main():\n    if len(sys.argv) < 3:\n        print(\"2 integer arguments required\")\n        return 1\n    a = int(sys.argv[1])\n    b = int(sys.argv[2])\n    print(extended_euclidean_algorithm(a, b))\n    return 0", "output": "Call Extended Euclidean Algorithm."}
{"task": "search", "input": "search code:\nFunction implements sdbm hash, easy to use, great for bits scrambling.\n\nChoices:\n0: def is_palindrome(n: int | str) -> bool:     n = str(n)     return n == n[::-1]\n1: def sdbm(plain_text: str) -> int:     hash_value = 0     for plain_chr in plain_text:         hash_value = (             ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value         )     return hash_value\n2: def join_mappings(**field_to_map):     ret = defaultdict(dict)      for field_name, mapping in field_to_map.items():         for key, value in mapping.items():             ret[key][field_name] = value      return dict(ret)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef data_safety_checker(list_vote: list, actual_result: float) -> None:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2,3,4],5.0)\n    Today's data is not safe.\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe = safe + 1\n            else:\n                not_safe = not_safe + 1\n    print(f\"Today's data is {'not ' if safe <= not_safe else ''}safe.\")", "output": "BUGGY"}
{"task": "search", "input": "search code:\nThis code involves the concept of memory functions. Here we solve the subproblems\n\nChoices:\n0: def mf_knapsack(i, wt, val, j):     global f  # a global dp table for knapsack     if f[i][j] < 0:         if j < wt[i - 1]:             val = mf_knapsack(i - 1, wt, val, j)         else:             val = max(                 mf_knapsack(i - 1, wt, val, j),                 mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],             )         f[i][j] = val     return f[i][j]\n1: def solution(n: int = 2) -> int:     result = 1.0     for fraction in fraction_list(n):         frac = Fraction(fraction)         result *= frac.denominator / frac.numerator     return int(result)\n2: def to_complex_case(text: str, upper: bool, separator: str) -> str:     try:         string_split = split_input(text)         if upper:             res_str = \"\".join(                 [                     separator.join([char.upper() for char in sub_str])                     for sub_str in string_split                 ]             )         else:             res_str = \"\".join(                 [                     separator.join([char.lower() for char in sub_str])                     for sub_str in string_split                 ]             )         return res_str     except IndexError:         return \"not valid string\"", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef check_direction(\n    starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int]\n) -> Direction:\n    x0, y0 = starting\n    x1, y1 = via\n    x2, y2 = target\n    via_angle = degrees(atan2(y1 - y0, x1 - x0))\n    via_angle %= 360\n    target_angle = degrees(atan2(y2 - y0, x2 - x0))\n    target_angle %= 360\n    # t-\n    #  \\ \\\n    #   \\ v\n    #    \\|\n    #     s\n    # via_angle is always lower than target_angle, if direction is left.\n    # If they are same, it means they are on a same line of convex hull.\n    if target_angle > via_angle:\n        return Direction.left\n    elif target_angle == via_angle:\n        return Direction.straight\n    else:\n        return Direction.right", "output": "Return the direction toward to the line from via to target from starting"}
{"task": "repair", "input": "fix bug:\ndef lower(word: str) -> str:\n    \"\"\"\n    Will convert the entire string to lowercase letters\n\n    >>> lower(\"wow\")\n    'wow'\n    >>> lower(\"HellZo\")\n    'hellzo'\n    >>> lower(\"WHAT\")\n    'what'\n    >>> lower(\"wh[]32\")\n    'wh[]32'\n    >>> lower(\"whAT\")\n    'what'\n    \"\"\"\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)", "output": "def lower(word: str) -> str:\n    \"\"\"\n    Will convert the entire string to lowercase letters\n\n    >>> lower(\"wow\")\n    'wow'\n    >>> lower(\"HellZo\")\n    'hellzo'\n    >>> lower(\"WHAT\")\n    'what'\n    >>> lower(\"wh[]32\")\n    'wh[]32'\n    >>> lower(\"whAT\")\n    'what'\n    \"\"\"\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)"}
{"task": "detection", "input": "classify code:\ndef three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef calculate_turnaroundtime(\n    burst_time: list[int], no_of_processes: int, waiting_time: list[int]\n) -> list[int]:\n\n    turn_around_time = [0] * no_of_processes\n    for i in range(no_of_processes):\n        turn_around_time[i] = burst_time[i] + waiting_time[i]\n    return turn_around_time", "output": "Calculate the turnaround time of each process."}
{"task": "repair", "input": "fix bug:\ndef generate_roman_numerals(num: int) -> str:\n    \"\"\"\n    Generates a string of roman numerals for a given integer.\n    e.g.\n    >>> generate_roman_numerals(89)\n    'LXXXIX'\n    >>> generate_roman_numerals(4)\n    'IV'\n    \"\"\"\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals", "output": "def generate_roman_numerals(num: int) -> str:\n    \"\"\"\n    Generates a string of roman numerals for a given integer.\n    e.g.\n    >>> generate_roman_numerals(89)\n    'LXXXIX'\n    >>> generate_roman_numerals(4)\n    'IV'\n    \"\"\"\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals"}
{"task": "search", "input": "search code:\nPure implementation of counting sort algorithm in Python\n\nChoices:\n0: def evaluate(item: str, main_target: str) -> tuple[str, float]:     score = len([g for position, g in enumerate(item) if g == main_target[position]])     return (item, float(score))\n1: def stalin_sort(sequence: list[int]) -> list[int]:     result = [sequence[0]]     for element in sequence[1:]:         if element >= result[-1]:             result.append(element)      return result\n2: def counting_sort(collection):     # if the collection is empty, returns empty     if collection == []:         return []      # get some information about the collection     coll_len = len(collection)     coll_max = max(collection)     coll_min = min(collection)      # create the counting array     counting_arr_length = coll_max + 1 - coll_min     counting_arr = [0] * counting_arr_length      # count how much a number appears in the collection     for number in collection:         counting_arr[number - coll_min] += 1      # sum each position with it's predecessors. now, counting_arr[i] tells     # us how many elements <= i has in the collection     for i in range(1, counting_arr_length):         counting_arr[i] = counting_arr[i] + counting_arr[i - 1]      # create the output collection     ordered = [0] * coll_len      # place the elements in the output, respecting the original order (stable     # sort) from end to begin, updating counting_arr     for i in reversed(range(coll_len)):         ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]         counting_arr[collection[i] - coll_min] -= 1      return ordered", "output": "2"}
{"task": "detection", "input": "classify code:\ndef generate_roman_numerals(num: int) -> str:\n    \"\"\"\n    Generates a string of roman numerals for a given integer.\n    e.g.\n    >>> generate_roman_numerals(89)\n    'LXXXIX'\n    >>> generate_roman_numerals(4)\n    'IV'\n    \"\"\"\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals", "output": "BUGGY"}
{"task": "search", "input": "search code:\nYield slices of length *n* from the sequence *seq*.\n\nChoices:\n0: def is_palindrome(head: ListNode | None) -> bool:     if not head:         return True     # split the list to two parts     fast: ListNode | None = head.next_node     slow: ListNode | None = head     while fast and fast.next_node:         fast = fast.next_node.next_node         slow = slow.next_node if slow else None     if slow:         # slow will always be defined,         # adding this check to resolve mypy static check         second = slow.next_node         slow.next_node = None  # Don't forget here! But forget still works!     # reverse the second part     node: ListNode | None = None     while second:         nxt = second.next_node         second.next_node = node         node = second         second = nxt     # compare two parts     # second part has the same or one less node     while node and head:         if node.val != head.val:             return False         node = node.next_node         head = head.next_node     return True\n1: def sliced(seq, n, strict=False):     iterator = takewhile(len, (seq[i : i + n] for i in count(0, n)))     if strict:          def ret():             for _slice in iterator:                 if len(_slice) != n:                     raise ValueError(\"seq is not divisible by n.\")                 yield _slice          return ret()     else:         return iterator\n2: def netstring_server_timeout_override(server_socket):      try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock, timeout=0.01)             while 1:                 request = client.read_ns(1)                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'ping':                     client.write_ns(b'pong')     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef multi_replace(text, sub_map, **kwargs):\n    m = MultiReplace(sub_map, **kwargs)\n    return m.sub(text)", "output": "Shortcut function to invoke MultiReplace in a single call."}
{"task": "detection", "input": "classify code:\ndef text_justification(word: str, max_width: int) -> list:\n    \"\"\"\n    Will format the string such that each line has exactly\n    (max_width) characters and is fully (left and right) justified,\n    and return the list of justified text.\n\n    example 1:\n    string = \"This is an example of text justification.\"\n    max_width = 16\n\n    output = ['This    is    an',\n              'example  of text',\n              'justification.  ']\n\n    >>> text_justification(\"This is an example of text justification.\", 16)\n    ['This    is    an', 'example  of text', 'justification.  ']\n\n    example 2:\n    string = \"Two roads diverged in a yellow wood\"\n    max_width = 16\n    output = ['Two        roads',\n              'diverged   in  a',\n              'yellow wood     ']\n\n    >>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n    ['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\n    Time complexity: O(m*n)\n    Space complexity: O(m*n)\n    \"\"\"\n\n    # Converting string into list of strings split by a space\n    words = word.split()\n\n    def justify(line: list, width: int, max_width: int) -> str:\n        overall_spaces_count = max_width - width\n        words_count = len(line)\n        if len(line) == 1:\n            # if there is only word in line\n            # just insert overall_spaces_count for the remainder of line\n            return line[0] + \" \" * overall_spaces_count\n        else:\n            spaces_to_insert_between_words = words_count - 1\n            # num_spaces_between_words_list[i] : tells you to insert\n            # num_spaces_between_words_list[i] spaces\n            # after word on line[i]\n            num_spaces_between_words_list = spaces_to_insert_between_words * [\n                overall_spaces_count // spaces_to_insert_between_words\n            ]\n            spaces_count_in_locations = (\n                overall_spaces_count % spaces_to_insert_between_words\n            )\n            # distribute spaces via round robin to the left words\n            for i in range(spaces_count_in_locations):\n                num_spaces_between_words_list[i] += 1\n            aligned_words_list = []\n            for i in range(spaces_to_insert_between_words):\n                # add the word\n                aligned_words_list.append(line[i])\n                # add the spaces to insert\n                aligned_words_list.append(num_spaces_between_words_list[i] * \" \")\n            # just add the last word to the sentence\n            aligned_words_list.append(line[-1])\n            # join the aligned words list to form a justified line\n            return \"\".join(aligned_words_list)\n\n    answer = []\n    line: list[str] = []\n    width = 0\n    for inner_word in words:\n        if width + len(inner_word) + len(line) <= max_width:\n            # keep adding words until we can fill out max_width\n            # width = sum of length of all words (without overall_spaces_count)\n            # len(inner_word) = length of current inner_word\n            # len(line) = number of overall_spaces_count to insert between words\n            line.append(inner_word)\n            width += len(inner_word)\n        else:\n            # justify the line and add it to result\n            answer.append(justify(line, width, max_width))\n            # reset new line and new width\n            line, width = [inner_word], len(inner_word)\n    remaining_spaces = max_width - width - len(line)\n    answer.append(\" \".join(line) + (remaining_spaces + 1) * \" \")\n    return answer", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef list_truncated_nums(n: int) -> List[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r", "output": "def list_truncated_nums(n: int) -> list[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r"}
{"task": "detection", "input": "classify code:\ndef tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef josephus_recursive(num_people: int, step_size: int) -> int:\n    if (\n        not isinstance(num_people, int)\n        or not isinstance(step_size, int)\n        or num_people <= 0\n        or step_size <= 0\n    ):\n        raise ValueError(\"num_people or step_size is not a positive integer.\")\n\n    if num_people == 1:\n        return 0\n\n    return (josephus_recursive(num_people - 1, step_size) + step_size) % num_people", "output": "Solve the Josephus problem for num_people and a step_size recursively."}
{"task": "repair", "input": "fix bug:\ndef simple_fibonacci(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    fn_1 = f1\n    fn_2 = f2\n    n -= 2\n\n    while n > 0:\n        fn_1, fn_2 = fn_1 + fn_2, fn_1\n        n -= 1\n\n    return fn_1", "output": "def simple_fibonacci(n, f1, f2):\n    \"\"\"\n    Returns the nth number of the Fibonacci sequence that\n    starts with f1 and f2\n    Uses the definition\n    >>> simple_fibonacci(1, 5, 6)\n    5\n    >>> simple_fibonacci(2, 10, 11)\n    11\n    >>> simple_fibonacci(13, 0, 1)\n    144\n    >>> simple_fibonacci(10, 5, 9)\n    411\n    >>> simple_fibonacci(9, 2, 3)\n    89\n    \"\"\"\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    n -= 2\n\n    while n > 0:\n        f2, f1 = f1 + f2, f2\n        n -= 1\n\n    return f2"}
{"task": "search", "input": "search code:\ninput: a 'scalar' and two vectors 'x' and 'y'\n\nChoices:\n0: def axpy(scalar: float, x: Vector, y: Vector) -> Vector:     # precondition     assert isinstance(x, Vector)     assert isinstance(y, Vector)     assert isinstance(scalar, (int, float))     return x * scalar + y\n1: def compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:      id_ = 0     n = len(graph)  # No of vertices in graph     low = [0] * n     visited = [False] * n      def dfs(at, parent, bridges, id_):         visited[at] = True         low[at] = id_         id_ += 1         for to in graph[at]:             if to == parent:                 pass             elif not visited[to]:                 dfs(to, at, bridges, id_)                 low[at] = min(low[at], low[to])                 if id_ <= low[to]:                     bridges.append((at, to) if at < to else (to, at))             else:                 # This edge is a back edge and cannot be a bridge                 low[at] = min(low[at], low[to])      bridges: list[tuple[int, int]] = []     for i in range(n):         if not visited[i]:             dfs(i, -1, bridges, id_)     return bridges\n2: def unit_len(sized_iterable, unit_noun='item'):  # TODO: len_units()/unitize()?     count = len(sized_iterable)     units = cardinalize(unit_noun, count)     if count:         return f'{count} {units}'     return f'No {units}'", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef gunzip_bytes(bytestring):\n    return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)", "output": "The :mod:`gzip` module is great if you have a file or file-like"}
{"task": "search", "input": "search code:\nA function to print the solution in the form\n\nChoices:\n0: def can_string_be_rearranged_as_palindrome(input_str: str = \"\") -> bool:     if len(input_str) == 0:         return True     lower_case_input_str = input_str.replace(\" \", \"\").lower()     # character_freq_dict: Stores the frequency of every character in the input string     character_freq_dict: dict[str, int] = {}      for character in lower_case_input_str:         character_freq_dict[character] = character_freq_dict.get(character, 0) + 1     odd_char = 0      for character_count in character_freq_dict.values():         if character_count % 2:             odd_char += 1     return not odd_char > 1\n1: def print_solution(grid: Matrix) -> None:     for row in grid:         for cell in row:             print(cell, end=\" \")         print()\n2: def decode(coded: str) -> str:     if set(coded) - {\"A\", \"B\", \" \"} != set():         raise Exception(\"decode() accepts only 'A', 'B' and spaces\")     decoded = \"\"     for word in coded.split():         while len(word) != 0:             decoded += decode_dict[word[:5]]             word = word[5:]         decoded += \" \"     return decoded.strip()", "output": "1"}
{"task": "detection", "input": "classify code:\ndef get_totients(max_one: int) -> list[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef minor(matrix: List[list], row: int, column: int) -> List[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]", "output": "def minor(matrix: list[list], row: int, column: int) -> list[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]"}
{"task": "summary", "input": "summarize code:\ndef area_trapezium(base1: float, base2: float, height: float) -> float:\n    if base1 < 0 or base2 < 0 or height < 0:\n        raise ValueError(\"area_trapezium() only accepts non-negative values\")\n    return 1 / 2 * (base1 + base2) * height", "output": "Calculate the area of a trapezium."}
{"task": "repair", "input": "fix bug:\ndef solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares", "output": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares"}
{"task": "search", "input": "search code:\nReturns the number of composite integers below max_number have precisely two,\n\nChoices:\n0: def reversible_numbers(     remaining_length: int, remainder: int, digits: list[int], length: int ) -> int:     # There exist no reversible 1, 5, 9, 13 (ie. 4k+1) digit numbers     if (length - 1) % 4 == 0:         return 0      return slow_reversible_numbers(remaining_length, remainder, digits, length)\n1: def effusion_ratio(molar_mass_1: float, molar_mass_2: float) -> float | ValueError:     return (         round(sqrt(molar_mass_2 / molar_mass_1), 6)         if validate(molar_mass_1, molar_mass_2)         else ValueError(\"Input Error: Molar mass values must greater than 0.\")     )\n2: def solution(max_number: int = 10**8) -> int:      prime_numbers = calculate_prime_numbers(max_number // 2)      semiprimes_count = 0     right = len(prime_numbers) - 1     for left in range(len(prime_numbers)):         if left > right:             break         for r in range(right, left - 2, -1):             if prime_numbers[left] * prime_numbers[r] < max_number:                 break         right = r         semiprimes_count += right - left + 1      return semiprimes_count", "output": "2"}
{"task": "detection", "input": "classify code:\ndef calculate_waiting_times(burst_times: List[int]) -> List[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r", "output": "BUGGY"}
{"task": "search", "input": "search code:\nMake a random puzzle with N or more assignments. Restart on contradictions.\n\nChoices:\n0: def run(canvas: list[list[bool]]) -> list[list[bool]]:     current_canvas = np.array(canvas)     next_gen_canvas = np.array(create_canvas(current_canvas.shape[0]))     for r, row in enumerate(current_canvas):         for c, pt in enumerate(row):             next_gen_canvas[r][c] = __judge_point(                 pt, current_canvas[r - 1 : r + 2, c - 1 : c + 2]             )      return next_gen_canvas.tolist()\n1: def random_puzzle(assignments=17):     values = dict.fromkeys(squares, digits)     for s in shuffled(squares):         if not assign(values, s, random.choice(values[s])):             break         ds = [values[s] for s in squares if len(values[s]) == 1]         if len(ds) >= assignments and len(set(ds)) >= 8:             return \"\".join(values[s] if len(values[s]) == 1 else \".\" for s in squares)     return random_puzzle(assignments)  ## Give up and make a new puzzle\n2: def compress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         add_key_to_lexicon(lexicon, curr_string, index, last_match_id)         index += 1         curr_string = \"\"      while curr_string != \"\" and curr_string not in lexicon:         curr_string += \"0\"      if curr_string != \"\":         last_match_id = lexicon[curr_string]         result += last_match_id      return result", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(a: int = 100, b: int = 100) -> int:\n\n    # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of\n    # BASE raised to the POWER\n    return max(\n        sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)\n    )", "output": "Considering natural numbers of the form, a**b, where a, b < 100,"}
{"task": "repair", "input": "fix bug:\ndef solve(nums: list[int], goal: int, depth: int) -> bool:\n    \"\"\"\n    Checks if nums can have a sum equal to goal, given that length of nums does\n    not exceed depth.\n\n    >>> solve([1], 2, 2)\n    True\n    >>> solve([1], 2, 0)\n    False\n    \"\"\"\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False", "output": "def solve(nums: list[int], goal: int, depth: int) -> bool:\n    \"\"\"\n    Checks if nums can have a sum equal to goal, given that length of nums does\n    not exceed depth.\n\n    >>> solve([1], 2, 2)\n    True\n    >>> solve([1], 2, 0)\n    False\n    \"\"\"\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False"}
{"task": "detection", "input": "classify code:\ndef shell_sort(collection: list) -> list:\n    \"\"\"Implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([3, 2, 1])\n    [1, 2, 3]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([1])\n    [1]\n    \"\"\"\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef contains_an_even_digit(n: int) -> bool:\n    return any(digit in \"02468\" for digit in str(n))", "output": "Return True if n contains an even digit."}
{"task": "repair", "input": "fix bug:\ndef extended_euclidean_algorithm(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b", "output": "def extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b"}
{"task": "search", "input": "search code:\nComparing local neighborhood pixel value with threshold value of centre pixel.\n\nChoices:\n0: def is_prime(number: int) -> bool:      return all(number % divisor != 0 for divisor in range(2, isqrt(number) + 1))\n1: def get_neighbors_pixel(     image: np.ndarray, x_coordinate: int, y_coordinate: int, center: int ) -> int:      try:         return int(image[x_coordinate][y_coordinate] >= center)     except (IndexError, TypeError):         return 0\n2: def create_all_state(     increment: int,     total_number: int,     level: int,     current_list: list[int],     total_list: list[list[int]], ) -> None:     if level == 0:         total_list.append(current_list[:])         return      for i in range(increment, total_number - level + 2):         current_list.append(i)         create_all_state(i + 1, total_number, level - 1, current_list, total_list)         current_list.pop()", "output": "1"}
{"task": "detection", "input": "classify code:\ndef solution(n):\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    [2, 8]\r\n    >>> solution(15)\r\n    [2, 8]\r\n    >>> solution(2)\r\n    [2]\r\n    >>> solution(1)\r\n    []\r\n    >>> solution(34)\r\n    [2, 8, 34]\r\n    \"\"\"\r\n    ls = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            ls.append(b)\r\n        a, b = b, a + b\r\n    return ls\r", "output": "BUGGY"}
{"task": "search", "input": "search code:\nSolves the problem for n_digits number of digits.\n\nChoices:\n0: def avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:     arr = np.array(arr)     if arr.shape[0] != arr.shape[1]:         raise ValueError(\"The input array is not a square matrix\")     i = 0     j = 0     mat_i = 0     mat_j = 0      # compute the shape of the output matrix     avgpool_shape = (arr.shape[0] - size) // stride + 1     # initialize the output matrix with zeros of shape avgpool_shape     updated_arr = np.zeros((avgpool_shape, avgpool_shape))      while i < arr.shape[0]:         # if the end of the matrix is reached, break         if i + size > arr.shape[0]:             break         while j < arr.shape[1]:             # if the end of the matrix is reached, break             if j + size > arr.shape[1]:                 break             # compute the average of the pooling matrix             updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))             # shift the pooling matrix by stride of column pixels             j += stride             mat_j += 1          # shift the pooling matrix by stride of row pixels         i += stride         mat_i += 1         # reset the column index to 0         j = 0         mat_j = 0      return updated_arr\n1: def get_reverse_bit_string(number: int) -> str:     if not isinstance(number, int):         msg = (             \"operation can not be conducted on an object of type \"             f\"{type(number).__name__}\"         )         raise TypeError(msg)     bit_string = \"\"     for _ in range(32):         bit_string += str(number % 2)         number >>= 1     return bit_string\n2: def solution(n_digits: int = 20) -> int:     cache: dict[str, int] = {}     return solve(digit=n_digits, prev1=0, prev2=0, sum_max=9, first=True, cache=cache)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef selection(chart: List[List[int]], prime_implicants: List[str]) -> List[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0", "output": "def selection(chart: list[list[int]], prime_implicants: list[str]) -> list[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0"}
{"task": "summary", "input": "summarize code:\ndef quantum_fourier_transform(number_of_qubits: int = 3) -> qiskit.result.counts.Counts:\n    if isinstance(number_of_qubits, str):\n        raise TypeError(\"number of qubits must be a integer.\")\n    if number_of_qubits <= 0:\n        raise ValueError(\"number of qubits must be > 0.\")\n    if math.floor(number_of_qubits) != number_of_qubits:\n        raise ValueError(\"number of qubits must be exact integer.\")\n    if number_of_qubits > 10:\n        raise ValueError(\"number of qubits too large to simulate(>10).\")\n\n    qr = QuantumRegister(number_of_qubits, \"qr\")\n    cr = ClassicalRegister(number_of_qubits, \"cr\")\n\n    quantum_circuit = QuantumCircuit(qr, cr)\n\n    counter = number_of_qubits\n\n    for i in range(counter):\n        quantum_circuit.h(number_of_qubits - i - 1)\n        counter -= 1\n        for j in range(counter):\n            quantum_circuit.cp(np.pi / 2 ** (counter - j), j, counter)\n\n    for k in range(number_of_qubits // 2):\n        quantum_circuit.swap(k, number_of_qubits - k - 1)\n\n    # measure all the qubits\n    quantum_circuit.measure(qr, cr)\n    # simulate with 10000 shots\n    backend = Aer.get_backend(\"qasm_simulator\")\n    job = execute(quantum_circuit, backend, shots=10000)\n\n    return job.result().get_counts(quantum_circuit)", "output": "# >>> quantum_fourier_transform(2)"}
{"task": "search", "input": "search code:\nThe `guess_the_number` function that guess the number by some operations\n\nChoices:\n0: def guess_the_number(lower: int, higher: int, to_guess: int) -> None:     assert (         isinstance(lower, int) and isinstance(higher, int) and isinstance(to_guess, int)     ), 'argument values must be type of \"int\"'      if lower > higher:         raise ValueError(\"argument value for lower and higher must be(lower > higher)\")      if not lower < to_guess < higher:         raise ValueError(             \"guess value must be within the range of lower and higher value\"         )      def answer(number: int) -> str:         if number > to_guess:             return \"high\"         elif number < to_guess:             return \"low\"         else:             return \"same\"      print(\"started...\")      last_lowest = lower     last_highest = higher      last_numbers = []      while True:         number = get_avg(last_lowest, last_highest)         last_numbers.append(number)          if answer(number) == \"low\":             last_lowest = number         elif answer(number) == \"high\":             last_highest = number         else:             break      print(f\"guess the number : {last_numbers[-1]}\")     print(f\"details : {last_numbers!s}\")\n1: def decrypt(input_string: str, key: int) -> str:     grid = []     lowest = key - 1      if key <= 0:         raise ValueError(\"Height of grid can't be 0 or negative\")     if key == 1:         return input_string      temp_grid: list[list[str]] = [[] for _ in range(key)]  # generates template     for position in range(len(input_string)):         num = position % (lowest * 2)  # puts it in bounds         num = min(num, lowest * 2 - num)  # creates zigzag pattern         temp_grid[num].append(\"*\")      counter = 0     for row in temp_grid:  # fills in the characters         splice = input_string[counter : counter + len(row)]         grid.append(list(splice))         counter += len(row)      output_string = \"\"  # reads as zigzag     for position in range(len(input_string)):         num = position % (lowest * 2)  # puts it in bounds         num = min(num, lowest * 2 - num)  # creates zigzag pattern         output_string += grid[num][0]         grid[num].pop(0)     return output_string\n2: def removeprefix(text: str, prefix: str) -> str:     if text.startswith(prefix):         return text[len(prefix):]     return text", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:\n    vectors = initial_vectors\n    for _ in range(steps):\n        vectors = iteration_step(vectors)\n    return vectors", "output": "Go through the number of iterations determined by the argument \"steps\"."}
{"task": "repair", "input": "fix bug:\ndef pigeon_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "def pigeon_sort(array: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array"}
{"task": "detection", "input": "classify code:\ndef calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef rstrip(iterable, strip_value=None):\n    return list(rstrip_iter(iterable, strip_value))", "output": "Strips values from the end of an iterable. Stripped items will"}
{"task": "search", "input": "search code:\nReturns the difference between the sum of the squares of the first n\n\nChoices:\n0: def nimply_gate(input_1: int, input_2: int) -> int:     return int(input_1 == 1 and input_2 == 0)\n1: def solution(n: int = 100) -> int:      sum_of_squares = 0     sum_of_ints = 0     for i in range(1, n + 1):         sum_of_squares += i**2         sum_of_ints += i     return sum_of_ints**2 - sum_of_squares\n2: def solution() -> int:     return compute_nums(1)[0]", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef is_palindrome(s):\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    \"\"\"\n    return s == s[::-1]", "output": "def is_palindrome(s: str) -> bool:\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    >>> is_palindrome(\"Able was I ere I saw Elba\")\n    True\n    >>> is_palindrome(\"racecar\")\n    True\n    >>> is_palindrome(\"Mr. Owl ate my metal worm?\")\n    True\n    \"\"\"\n    # Since Punctuation, capitalization, and spaces are usually ignored while checking Palindrome,\n    # we first remove them from our string.\n    s = \"\".join([character for character in s.lower() if character.isalnum()])\n    return s == s[::-1]"}
{"task": "detection", "input": "classify code:\ndef vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the product of a,b,c which are Pythagorean Triplet that satisfies\n\nChoices:\n0: def valid_connection(     graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int] ) -> bool:      # 1. Validate that path exists between current and next vertices     if graph[path[curr_ind - 1]][next_ver] == 0:         return False      # 2. Validate that next vertex is not already in path     return not any(vertex == next_ver for vertex in path)\n1: def solution_fast() -> int:      for a in range(300):         for b in range(400):             c = 1000 - a - b             if a < b < c and (a**2) + (b**2) == (c**2):                 return a * b * c      return -1\n2: def rotate_array(arr: list[int], steps: int) -> list[int]:      n = len(arr)     if n == 0:         return arr      steps = steps % n      if steps < 0:         steps += n      def reverse(start: int, end: int) -> None:          while start < end:             arr[start], arr[end] = arr[end], arr[start]             start += 1             end -= 1      reverse(0, n - 1)     reverse(0, steps - 1)     reverse(steps, n - 1)      return arr", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef validate_credit_card_number(credit_card_number: str) -> bool:\n    error_message = f\"{credit_card_number} is an invalid credit card number because\"\n    if not credit_card_number.isdigit():\n        print(f\"{error_message} it has nonnumerical characters.\")\n        return False\n\n    if not 13 <= len(credit_card_number) <= 16:\n        print(f\"{error_message} of its length.\")\n        return False\n\n    if not validate_initial_digits(credit_card_number):\n        print(f\"{error_message} of its first two digits.\")\n        return False\n\n    if not luhn_validation(credit_card_number):\n        print(f\"{error_message} it fails the Luhn check.\")\n        return False\n\n    print(f\"{credit_card_number} is a valid credit card number.\")\n    return True", "output": "Function to validate the given credit card number."}
{"task": "detection", "input": "classify code:\ndef pigeon_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "def calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)"}
{"task": "search", "input": "search code:\nReturn an \"absolute\" value for a timedelta, always representing a time distance.\n\nChoices:\n0: def fix_print_exception():     sys.excepthook = print_exception\n1: def _abs_timedelta(delta):     if delta.days < 0:         now = _now()         return now - (now + delta)     return delta\n2: def interquartile_range_checker(train_user: list) -> float:     train_user.sort()     q1 = np.percentile(train_user, 25)     q3 = np.percentile(train_user, 75)     iqr = q3 - q1     low_lim = q1 - (iqr * 0.1)     return float(low_lim)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution(100)\n    25164150\n    \"\"\"\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)", "output": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)"}
{"task": "summary", "input": "summarize code:\ndef download_image(url: str) -> str:\n    try:\n        response = httpx.get(url, timeout=10)\n        response.raise_for_status()\n    except httpx.RequestError as e:\n        return f\"An error occurred during the HTTP request to {url}: {e!r}\"\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n    image_meta_tag = soup.find(\"meta\", {\"property\": \"og:image\"})\n    if not image_meta_tag:\n        return \"No meta tag with property 'og:image' was found.\"\n\n    image_url = image_meta_tag.get(\"content\")\n    if not image_url:\n        return f\"Image URL not found in meta tag {image_meta_tag}.\"\n\n    try:\n        image_data = httpx.get(image_url, timeout=10).content\n    except httpx.RequestError as e:\n        return f\"An error occurred during the HTTP request to {image_url}: {e!r}\"\n    if not image_data:\n        return f\"Failed to download the image from {image_url}.\"\n\n    file_name = f\"{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H-%M-%S}.jpg\"\n    with open(file_name, \"wb\") as out_file:\n        out_file.write(image_data)\n    return f\"Image downloaded and saved in the file {file_name}\"", "output": "Download an image from a given URL by scraping the 'og:image' meta tag."}
{"task": "detection", "input": "classify code:\ndef peak(lst: list[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef gaussian_error_linear_unit(vector: np.ndarray) -> np.ndarray:\n    return vector * sigmoid(1.702 * vector)", "output": "Implements the Gaussian Error Linear Unit (GELU) function"}
{"task": "repair", "input": "fix bug:\ndef solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in xrange(1, 1001):\n        total += i ** i\n    return str(total)[-10:]", "output": "def solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in range(1, 1001):\n        total += i ** i\n    return str(total)[-10:]"}
{"task": "detection", "input": "classify code:\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nreturn the geometric mean of series\n\nChoices:\n0: def args2sh(args, sep=' '):     ret_list = []      for arg in args:         if not arg:             ret_list.append(\"''\")             continue         if _find_sh_unsafe(arg) is None:             ret_list.append(arg)             continue         # use single quotes, and put single quotes into double quotes         # the string $'b is then quoted as '$'\"'\"'b'         ret_list.append(\"'\" + arg.replace(\"'\", \"'\\\"'\\\"'\") + \"'\")      return ' '.join(ret_list)\n1: def geometric_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 1     for value in series:         answer *= value     return pow(answer, 1 / len(series))\n2: def solution(limit: int = 100) -> int:     singles: list[int] = [*list(range(1, 21)), 25]     doubles: list[int] = [2 * x for x in range(1, 21)] + [50]     triples: list[int] = [3 * x for x in range(1, 21)]     all_values: list[int] = singles + doubles + triples + [0]      num_checkouts: int = 0     double: int     throw1: int     throw2: int     checkout_total: int      for double in doubles:         for throw1, throw2 in combinations_with_replacement(all_values, 2):             checkout_total = double + throw1 + throw2             if checkout_total < limit:                 num_checkouts += 1      return num_checkouts", "output": "1"}
{"task": "search", "input": "search code:\nInput Parameters\n\nChoices:\n0: def is_safe(board: list[list[int]], row: int, column: int) -> bool:      n = len(board)  # Size of the board      # Check if there is any queen in the same upper column,     # left upper diagonal and right upper diagonal     return (         all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))         )         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))         )     )\n1: def casimir_force(force: float, area: float, distance: float) -> dict[str, float]:      if (force, area, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if force < 0:         raise ValueError(\"Magnitude of force can not be negative\")     if distance < 0:         raise ValueError(\"Distance can not be negative\")     if area < 0:         raise ValueError(\"Area can not be negative\")     if force == 0:         force = (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (             240 * (distance) ** 4         )         return {\"force\": force}     elif area == 0:         area = (240 * force * (distance) ** 4) / (             REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2         )         return {\"area\": area}     elif distance == 0:         distance = (             (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (240 * force)         ) ** (1 / 4)         return {\"distance\": distance}     raise ValueError(\"One and only one argument must be 0\")\n2: def solution(n: int = 1000) -> int:      total = 0     terms = (n - 1) // 3     total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.     terms = (n - 1) // 5     total += ((terms) * (10 + (terms - 1) * 5)) // 2     terms = (n - 1) // 15     total -= ((terms) * (30 + (terms - 1) * 15)) // 2     return total", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef transform(velocity: float, event: np.ndarray | None = None) -> np.ndarray:\n    # Ensure event is not empty\n    if event is None:\n        event = np.array([ct, x, y, z])  # Symbolic four vector\n    else:\n        event[0] *= c  # x0 is ct (speed of light * time)\n\n    return transformation_matrix(velocity) @ event", "output": "Calculate a Lorentz transformation for movement in the x direction given a"}
{"task": "repair", "input": "fix bug:\ndef is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0", "output": "def is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0"}
{"task": "detection", "input": "classify code:\ndef prime_sieve(limit: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn a shell-escaped string version of *args*, separated by\n\nChoices:\n0: def args2sh(args, sep=' '):     ret_list = []      for arg in args:         if not arg:             ret_list.append(\"''\")             continue         if _find_sh_unsafe(arg) is None:             ret_list.append(arg)             continue         # use single quotes, and put single quotes into double quotes         # the string $'b is then quoted as '$'\"'\"'b'         ret_list.append(\"'\" + arg.replace(\"'\", \"'\\\"'\\\"'\") + \"'\")      return ' '.join(ret_list)\n1: def _construct_hull(     points: list[Point], left: Point, right: Point, convex_set: set[Point] ) -> None:     if points:         extreme_point = None         extreme_point_distance = float(\"-inf\")         candidate_points = []          for p in points:             det = _det(left, right, p)              if det > 0:                 candidate_points.append(p)                  if det > extreme_point_distance:                     extreme_point_distance = det                     extreme_point = p          if extreme_point:             _construct_hull(candidate_points, left, extreme_point, convex_set)             convex_set.add(extreme_point)             _construct_hull(candidate_points, extreme_point, right, convex_set)\n2: def area_trapezium(base1: float, base2: float, height: float) -> float:     if base1 < 0 or base2 < 0 or height < 0:         raise ValueError(\"area_trapezium() only accepts non-negative values\")     return 1 / 2 * (base1 + base2) * height", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef longest_subsequence(array: List[int]) -> List[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq"}
{"task": "detection", "input": "classify code:\ndef standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution(days: int = 30) -> int:\n\n    return _calculate(days, absent=0, late=0)", "output": "Returns the number of possible prize strings for a particular number"}
{"task": "search", "input": "search code:\nFind all the valid positions a knight can move to from the current position.\n\nChoices:\n0: def linear_regression_prediction(     train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list ) -> float:     x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])     y = np.array(train_usr)     beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)     return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])\n1: def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:      y, x = position     positions = [         (y + 1, x + 2),         (y - 1, x + 2),         (y + 1, x - 2),         (y - 1, x - 2),         (y + 2, x + 1),         (y + 2, x - 1),         (y - 2, x + 1),         (y - 2, x - 1),     ]     permissible_positions = []      for inner_position in positions:         y_test, x_test = inner_position         if 0 <= y_test < n and 0 <= x_test < n:             permissible_positions.append(inner_position)      return permissible_positions\n2: def prefix_function(input_string: str) -> list:      # list for the result values     prefix_result = [0] * len(input_string)      for i in range(1, len(input_string)):         # use last results for better performance - dynamic programming         j = prefix_result[i - 1]         while j > 0 and input_string[i] != input_string[j]:             j = prefix_result[j - 1]          if input_string[i] == input_string[j]:             j += 1         prefix_result[i] = j      return prefix_result", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef covariance_between_classes(\n    features: np.ndarray, labels: np.ndarray, classes: int\n) -> np.ndarray:\n\n    general_data_mean = features.mean(1)\n    covariance_sum = np.nan\n    for i in range(classes):\n        data = features[:, labels == i]\n        device_data = data.shape[1]\n        data_mean = data.mean(1)\n        if i > 0:\n            # If covariance_sum is not None\n            covariance_sum += device_data * np.dot(\n                column_reshape(data_mean) - column_reshape(general_data_mean),\n                (column_reshape(data_mean) - column_reshape(general_data_mean)).T,\n            )\n        else:\n            # If covariance_sum is np.nan (i.e. first loop)\n            covariance_sum = device_data * np.dot(\n                column_reshape(data_mean) - column_reshape(general_data_mean),\n                (column_reshape(data_mean) - column_reshape(general_data_mean)).T,\n            )\n\n    return covariance_sum / features.shape[1]", "output": "Function to compute the covariance matrix between multiple classes"}
{"task": "detection", "input": "classify code:\ndef cycle_sort(array):\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return ans", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef max_sub_array(nums: List[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best", "output": "def max_sub_array(nums: list[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best"}
{"task": "summary", "input": "summarize code:\ndef largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]", "output": "Function updates the largest_square_area[0], if recursive call found"}
{"task": "search", "input": "search code:\nCapitalizes the first letter of a sentence or word.\n\nChoices:\n0: def capitalize(sentence: str) -> str:     if not sentence:         return \"\"      # Capitalize the first character if it's a lowercase letter     # Concatenate the capitalized character with the rest of the string     return sentence[0].upper() + sentence[1:]\n1: def chain_length(n: int, previous: set | None = None) -> int:     previous = previous or set()     if n in CHAIN_LENGTH_CACHE:         return CHAIN_LENGTH_CACHE[n]     next_number = sum_digit_factorials(n)     if next_number in previous:         CHAIN_LENGTH_CACHE[n] = 0         return 0     else:         previous.add(n)         ret = 1 + chain_length(next_number, previous)         CHAIN_LENGTH_CACHE[n] = ret         return ret\n2: def solution(max_n: int = 100) -> int:     pre_numerator = 1     cur_numerator = 2      for i in range(2, max_n + 1):         temp = pre_numerator         e_cont = 2 * i // 3 if i % 3 == 0 else 1         pre_numerator = cur_numerator         cur_numerator = e_cont * pre_numerator + temp      return sum_digits(cur_numerator)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef prime_sieve(limit: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius", "output": "def centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius"}
{"task": "detection", "input": "classify code:\ndef minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef perfect_square_binary_search(n: int) -> bool:\n    left = 0\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        if mid**2 == n:\n            return True\n        elif mid**2 > n:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False", "output": "Check if a number is perfect square using binary search."}
{"task": "repair", "input": "fix bug:\ndef check(binary: List[str]) -> List[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))", "output": "def check(binary: list[str]) -> list[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))"}
{"task": "search", "input": "search code:\nPrints the boards that have a successful combination.\n\nChoices:\n0: def solution() -> int:      return next(         iter(             [                 a * b * (1000 - a - b)                 for a in range(1, 999)                 for b in range(a, 999)                 if (a * a + b * b == (1000 - a - b) ** 2)             ]         )     )\n1: def printboard(board: list[list[int]]) -> None:     for i in range(len(board)):         for j in range(len(board)):             if board[i][j] == 1:                 print(\"Q\", end=\" \")  # Queen is present             else:                 print(\".\", end=\" \")  # Empty cell         print()\n2: def int_ranges_from_int_list(range_string, delim=',', range_delim='-'):     int_tuples = []     # Normalize the range string to our internal format for processing.     range_string = format_int_list(         parse_int_list(range_string, delim, range_delim))     if range_string:         for bounds in range_string.split(','):             if '-' in bounds:                 start, end = bounds.split('-')             else:                 start, end = bounds, bounds             int_tuples.append((int(start), int(end)))     return tuple(int_tuples)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef fletcher16(text: str) -> int:\n    \"\"\"\n    Loop through every character in the data and add to two sums.\n\n    >>> fletcher16('hello world')\n    6752\n    >>> fletcher16('onethousandfourhundredthirtyfour')\n    28347\n    >>> fletcher16('The quick brown fox jumps over the lazy dog.')\n    5655\n    \"\"\"\n    data = bytes(text, \"ascii\")\n    sum1 = 0\n    sum2 = 0\n    for character in data:\n        sum1 = (sum1 + character) % 255\n        sum2 = (sum1 + sum2) % 255\n    return (sum2 << 8) | sum1", "output": "def fletcher16(text: str) -> int:\n    \"\"\"\n    Loop through every character in the data and add to two sums.\n\n    >>> fletcher16('hello world')\n    6752\n    >>> fletcher16('onethousandfourhundredthirtyfour')\n    28347\n    >>> fletcher16('The quick brown fox jumps over the lazy dog.')\n    5655\n    \"\"\"\n    data = bytes(text, \"ascii\")\n    sum1 = 0\n    sum2 = 0\n    for character in data:\n        sum1 = (sum1 + character) % 255\n        sum2 = (sum1 + sum2) % 255\n    return (sum2 << 8) | sum1"}
{"task": "detection", "input": "classify code:\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPseudo-Code\n\nChoices:\n0: def util_color(     graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int ) -> bool:      # Base Case     if index == len(graph):         return True      # Recursive Step     for i in range(max_colors):         if valid_coloring(graph[index], colored_vertices, i):             # Color current vertex             colored_vertices[index] = i             # Validate coloring             if util_color(graph, max_colors, colored_vertices, index + 1):                 return True             # Backtrack             colored_vertices[index] = -1     return False\n1: def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:      try:         # Has user provided both inputs?         if not drug_name or not zip_code:             return None          request_url = BASE_URL.format(drug_name, zip_code)         response = httpx.get(request_url, timeout=10).raise_for_status()          # Scrape the data using bs4         soup = BeautifulSoup(response.text, \"html.parser\")          # This list will store the name and price.         pharmacy_price_list = []          # Fetch all the grids that contain the items.         grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})         if grid_list and len(grid_list) > 0:             for grid in grid_list:                 # Get the pharmacy price.                 pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text                  # Get the price of the drug.                 price = grid.find(\"span\", {\"p\", \"price price-large\"}).text                  pharmacy_price_list.append(                     {                         \"pharmacy_name\": pharmacy_name,                         \"price\": price,                     }                 )          return pharmacy_price_list      except (httpx.HTTPError, ValueError):         return None\n2: def generate_formula() -> Formula:     clauses: set[Clause] = set()     no_of_clauses = random.randint(1, 10)     while len(clauses) < no_of_clauses:         clauses.add(generate_clause())     return Formula(clauses)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef construct_format_field_str(fname, fspec, conv):\n    if fname is None:\n        return ''\n    ret = '{' + fname\n    if conv:\n        ret += '!' + conv\n    if fspec:\n        ret += ':' + fspec\n    ret += '}'\n    return ret", "output": "Constructs a format field string from the field name, spec, and"}
{"task": "detection", "input": "classify code:\ndef merge_insertion_sort(collection: List[int]) -> List[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef validate_matrix_content(matrix: list[str], size: int) -> None:\n    print(matrix)\n    if len(matrix) != size:\n        raise ValueError(\"The matrix dont match with size.\")\n    for row in matrix:\n        if len(row) != size:\n            msg = f\"Each row in the matrix must have exactly {size} characters.\"\n            raise ValueError(msg)\n        if not all(char.isalnum() for char in row):\n            raise ValueError(\"Matrix rows can only contain letters and numbers.\")", "output": "Validates that the number of elements in the matrix matches the given size."}
{"task": "search", "input": "search code:\nCreates a state space tree to iterate through each branch using DFS.\n\nChoices:\n0: def solution(num: int = 100) -> int:     return sum(map(int, str(factorial(num))))\n1: def fib_memoization(n: int) -> list[int]:     if n < 0:         raise ValueError(\"n is negative\")     # Cache must be outside recursive function     # other it will reset every time it calls itself.     cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache      def rec_fn_memoized(num: int) -> int:         if num in cache:             return cache[num]          value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)         cache[num] = value         return value      return [rec_fn_memoized(i) for i in range(n + 1)]\n2: def create_state_space_tree(     sequence: list[int | str],     current_sequence: list[int | str],     index: int,     index_used: list[int], ) -> None:      if index == len(sequence):         print(current_sequence)         return      for i in range(len(sequence)):         if not index_used[i]:             current_sequence.append(sequence[i])             index_used[i] = True             create_state_space_tree(sequence, current_sequence, index + 1, index_used)             current_sequence.pop()             index_used[i] = False", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq", "output": "def longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq"}
{"task": "repair", "input": "fix bug:\ndef to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word", "output": "def to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 200) -> int:\n    return two_pound(n)", "output": "Returns the number of different ways can n pence be made using any number of"}
{"task": "detection", "input": "classify code:\ndef perfect_cube(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not.\n\n    >>> perfect_cube(27)\n    True\n    >>> perfect_cube(4)\n    False\n    \"\"\"\n    val = n ** (1 / 3)\n    return (val * val * val) == n", "output": "CORRECT"}
{"task": "search", "input": "search code:\nApply Ohm's Law, on any two given electrical values, which can be voltage, current,\n\nChoices:\n0: def ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:     if (voltage, current, resistance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance < 0:         raise ValueError(\"Resistance cannot be negative\")     if voltage == 0:         return {\"voltage\": float(current * resistance)}     elif current == 0:         return {\"current\": voltage / resistance}     elif resistance == 0:         return {\"resistance\": voltage / current}     else:         raise ValueError(\"Exactly one argument must be 0\")\n1: def encipher(message: str, cipher_map: dict[str, str]) -> str:     return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())\n2: def solution(func: Callable[[int], int] = question_function, order: int = 10) -> int:     data_points: list[int] = [func(x_val) for x_val in range(1, order + 1)]      polynomials: list[Callable[[int], int]] = [         interpolate(data_points[:max_coeff]) for max_coeff in range(1, order + 1)     ]      ret: int = 0     poly: Callable[[int], int]     x_val: int      for poly in polynomials:         x_val = 1         while func(x_val) == poly(x_val):             x_val += 1          ret += poly(x_val)      return ret", "output": "0"}
{"task": "detection", "input": "classify code:\ndef reverse_letters(input_str: str) -> str:\n    \"\"\"\n    Reverses letters in a given string without adjusting the position of the words\n    >>> reverse_letters('The cat in the hat')\n    'ehT tac ni eht tah'\n    >>> reverse_letters('The quick brown fox jumped over the lazy dog.')\n    'ehT kciuq nworb xof depmuj revo eht yzal .god'\n    >>> reverse_letters('Is this true?')\n    'sI siht ?eurt'\n    >>> reverse_letters(\"I   love       Python\")\n    'I evol nohtyP'\n    \"\"\"\n    return \" \".join([word[::-1] for word in input_str.split()])", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the first ten digits of the sum of the array elements\n\nChoices:\n0: def iter_index(iterable, value, start=0, stop=None):     seq_index = getattr(iterable, 'index', None)     if seq_index is None:         # Slow path for general iterables         iterator = islice(iterable, start, stop)         for i, element in enumerate(iterator, start):             if element is value or element == value:                 yield i     else:         # Fast path for sequences         stop = len(iterable) if stop is None else stop         i = start - 1         with suppress(ValueError):             while True:                 yield (i := seq_index(value, i + 1, stop))\n1: def main():      array = [30, 35, 15, 5, 10, 20, 25]     n = len(array)      matrix, optimal_solution = matrix_chain_order(array)      print(\"No. of Operation required: \" + str(matrix[1][n - 1]))     print_optimal_solution(optimal_solution, 1, n - 1)\n2: def solution():     file_path = os.path.join(os.path.dirname(__file__), \"num.txt\")     with open(file_path) as file_hand:         return str(sum(int(line) for line in file_hand))[:10]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef sum_digit_factorials(n: int) -> int:\n    if n in CACHE_SUM_DIGIT_FACTORIALS:\n        return CACHE_SUM_DIGIT_FACTORIALS[n]\n    ret = sum(DIGIT_FACTORIALS[let] for let in str(n))\n    CACHE_SUM_DIGIT_FACTORIALS[n] = ret\n    return ret", "output": "Return the sum of the factorial of the digits of n."}
{"task": "repair", "input": "fix bug:\ndef calculate_waiting_times(burst_times: List[int]) -> List[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r", "output": "def calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r"}
{"task": "search", "input": "search code:\nA generator that produces numbers in the Fibonacci sequence\n\nChoices:\n0: def gamma_iterative(num: float) -> float:     if num <= 0:         raise ValueError(\"math domain error\")      return quad(integrand, 0, inf, args=(num))[0]\n1: def fibonacci_generator() -> Generator[int]:     a, b = 0, 1     while True:         a, b = b, a + b         yield b\n2: def subslices(iterable):     seq = list(iterable)     slices = starmap(slice, combinations(range(len(seq) + 1), 2))     return map(getitem, repeat(seq), slices)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n\n    >>> split(\";abbb;;c;\", separator=';')\n    ['', 'abbb', '', 'c', '']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 4000000) -> int:\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    getcontext().prec = 100\n    phi = (Decimal(5) ** Decimal(\"0.5\") + 1) / Decimal(2)\n\n    index = (math.floor(math.log(n * (phi + 2), phi) - 1) // 3) * 3 + 2\n    num = Decimal(round(phi ** Decimal(index + 1))) / (phi + 2)\n    total = num // 2\n    return int(total)", "output": "Returns the sum of all even fibonacci sequence elements that are lower"}
{"task": "detection", "input": "classify code:\ndef three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef xor(a, b):\n    \"\"\"\n    >>> xor(\"01010101\", \"00001111\")\n    '01011010'\n    \"\"\"\n    res = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            res += \"0\"\n        else:\n            res += \"1\"\n    return res", "output": "def xor(a, b):\n    \"\"\"\n    >>> xor(\"01010101\", \"00001111\")\n    '01011010'\n    \"\"\"\n    res = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            res += \"0\"\n        else:\n            res += \"1\"\n    return res"}
{"task": "summary", "input": "summarize code:\ndef integer_square_root(num: int) -> int:\n    if not isinstance(num, int) or num < 0:\n        raise ValueError(\"num must be non-negative integer\")\n\n    if num < 2:\n        return num\n\n    left_bound = 0\n    right_bound = num // 2\n\n    while left_bound <= right_bound:\n        mid = left_bound + (right_bound - left_bound) // 2\n        mid_squared = mid * mid\n        if mid_squared == num:\n            return mid\n\n        if mid_squared < num:\n            left_bound = mid + 1\n        else:\n            right_bound = mid - 1\n\n    return right_bound", "output": "Returns the integer square root of a non-negative integer num."}
{"task": "search", "input": "search code:\nInput Parameters:\n\nChoices:\n0: def first_effusion_rate(     effusion_rate: float, molar_mass_1: float, molar_mass_2: float ) -> float | ValueError:     return (         round(effusion_rate * sqrt(molar_mass_2 / molar_mass_1), 6)         if validate(effusion_rate, molar_mass_1, molar_mass_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )\n1: def main() -> None:     import seaborn as sns      mpg_data = sns.load_dataset(\"mpg\")      poly_reg = PolynomialRegression(degree=2)     poly_reg.fit(mpg_data.weight, mpg_data.mpg)      weight_sorted = np.sort(mpg_data.weight)     predictions = poly_reg.predict(weight_sorted)      plt.scatter(mpg_data.weight, mpg_data.mpg, color=\"gray\", alpha=0.5)     plt.plot(weight_sorted, predictions, color=\"red\", linewidth=3)     plt.title(\"Predicting Fuel Efficiency Using Polynomial Regression\")     plt.xlabel(\"Weight (lbs)\")     plt.ylabel(\"Fuel Efficiency (mpg)\")     plt.show()\n2: def find_python_set(node: Node) -> set:     sets = ({0, 1, 2}, {3, 4, 5})     for s in sets:         if node.data in s:             return s     msg = f\"{node.data} is not in {sets}\"     raise ValueError(msg)", "output": "0"}
{"task": "search", "input": "search code:\nA puzzle is solved if each unit is a permutation of the digits 1 to 9.\n\nChoices:\n0: def solved(values):      def unitsolved(unit):         return {values[s] for s in unit} == set(digits)      return values is not False and all(unitsolved(unit) for unit in unitlist)\n1: def pressure_conversion(value: float, from_type: str, to_type: str) -> float:     if from_type not in PRESSURE_CONVERSION:         raise ValueError(             f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"             + \", \".join(PRESSURE_CONVERSION)         )     if to_type not in PRESSURE_CONVERSION:         raise ValueError(             f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"             + \", \".join(PRESSURE_CONVERSION)         )     return (         value         * PRESSURE_CONVERSION[from_type].from_factor         * PRESSURE_CONVERSION[to_type].to_factor     )\n2: def sum_of_digits(num: int, base: int) -> str:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      num_str = int_to_base(num, base)     res = sum(int(char, base) for char in num_str)     res_str = int_to_base(res, base)     return res_str", "output": "0"}
{"task": "detection", "input": "classify code:\ndef generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef max_difference(a: List[int]) -> (int, int):\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second", "output": "def max_difference(a: list[int]) -> tuple[int, int]:\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second"}
{"task": "summary", "input": "summarize code:\ndef rotate_to_the_right(head: Node, places: int) -> Node:\n    # Check if the list is empty or has only one element\n    if not head:\n        raise ValueError(\"The linked list is empty.\")\n\n    if head.next_node is None:\n        return head\n\n    # Calculate the length of the linked list\n    length = 1\n    temp_node = head\n    while temp_node.next_node is not None:\n        length += 1\n        temp_node = temp_node.next_node\n\n    # Adjust the value of places to avoid places longer than the list.\n    places %= length\n\n    if places == 0:\n        return head  # As no rotation is needed.\n\n    # Find the new head position after rotation.\n    new_head_index = length - places\n\n    # Traverse to the new head position\n    temp_node = head\n    for _ in range(new_head_index - 1):\n        assert temp_node.next_node\n        temp_node = temp_node.next_node\n\n    # Update pointers to perform rotation\n    assert temp_node.next_node\n    new_head = temp_node.next_node\n    temp_node.next_node = None\n    temp_node = new_head\n    while temp_node.next_node:\n        temp_node = temp_node.next_node\n    temp_node.next_node = head\n\n    assert new_head\n    return new_head", "output": "Rotate a linked list to the right by places times."}
{"task": "summary", "input": "summarize code:\ndef get_citation(base_url: str, params: dict) -> str:\n    soup = BeautifulSoup(\n        httpx.get(base_url, params=params, timeout=10).content, \"html.parser\"\n    )\n    div = soup.find(\"div\", attrs={\"class\": \"gs_ri\"})\n    anchors = div.find(\"div\", attrs={\"class\": \"gs_fl\"}).find_all(\"a\")\n    return anchors[2].get_text()", "output": "Return the citation number."}
{"task": "detection", "input": "classify code:\ndef calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef reverse_letters(input_str: str) -> str:\n    \"\"\"\n    Reverses letters in a given string without adjusting the position of the words\n    >>> reverse_letters('The cat in the hat')\n    'ehT tac ni eht tah'\n    >>> reverse_letters('The quick brown fox jumped over the lazy dog.')\n    'ehT kciuq nworb xof depmuj revo eht yzal .god'\n    >>> reverse_letters('Is this true?')\n    'sI siht ?eurt'\n    >>> reverse_letters(\"I   love       Python\")\n    'I evol nohtyP'\n    \"\"\"\n    return \" \".join([word[::-1] for word in input_str.split()])", "output": "def reverse_letters(sentence: str, length: int = 0) -> str:\n    \"\"\"\n    Reverse all words that are longer than the given length of characters in a sentence.\n    If unspecified, length is taken as 0\n\n    >>> reverse_letters(\"Hey wollef sroirraw\", 3)\n    'Hey fellow warriors'\n    >>> reverse_letters(\"nohtyP is nohtyP\", 2)\n    'Python is Python'\n    >>> reverse_letters(\"1 12 123 1234 54321 654321\", 0)\n    '1 21 321 4321 12345 123456'\n    >>> reverse_letters(\"racecar\")\n    'racecar'\n    \"\"\"\n    return \" \".join(\n        \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()\n    )"}
{"task": "search", "input": "search code:\nConvert a frequency in the mel scale to Hertz.\n\nChoices:\n0: def mel_to_freq(mels: float) -> float:     # Use the formula to convert mel scale to frequency     return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)\n1: def split_into(iterable, sizes):     # convert the iterable argument into an iterator so its contents can     # be consumed by islice in case it is a generator     it = iter(iterable)      for size in sizes:         if size is None:             yield list(it)             return         else:             yield list(islice(it, size))\n2: def bitap_string_match(text: str, pattern: str) -> int:     if not pattern:         return 0     m = len(pattern)     if m > len(text):         return -1      # Initial state of bit string 1110     state = ~1     # Bit = 0 if character appears at index, and 1 otherwise     pattern_mask: list[int] = [~0] * 27  # 1111      for i, char in enumerate(pattern):         # For the pattern mask for this character, set the bit to 0 for each i         # the character appears.         pattern_index: int = ord(char) - ord(\"a\")         pattern_mask[pattern_index] &= ~(1 << i)      for i, char in enumerate(text):         text_index = ord(char) - ord(\"a\")         # If this character does not appear in pattern, it's pattern mask is 1111.         # Performing a bitwise OR between state and 1111 will reset the state to 1111         # and start searching the start of pattern again.         state |= pattern_mask[text_index]         state <<= 1          # If the mth bit (counting right to left) of the state is 0, then we have         # found pattern in text         if (state & (1 << m)) == 0:             return i - m + 1      return -1", "output": "0"}
{"task": "search", "input": "search code:\nConverts the given data to the appropriate number if it is indeed a number, else\n\nChoices:\n0: def generate_sum_of_subsets_solutions(nums: list[int], max_sum: int) -> list[list[int]]:      result: list[list[int]] = []     path: list[int] = []     num_index = 0     remaining_nums_sum = sum(nums)     create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)     return result\n1: def compress(source_path: str, destination_path: str) -> None:     data_bits = read_file_binary(source_path)     compressed = compress_data(data_bits)     compressed = add_file_length(source_path, compressed)     write_file_binary(destination_path, compressed)\n2: def parse_token(token: str | float) -> float | str:     if token in OPERATORS:         return token     try:         return float(token)     except ValueError:         msg = f\"{token} is neither a number nor a valid operator\"         raise ValueError(msg)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n\n    Args:\n        * `elements`: The list of elements from which combinations will be generated.\n        * `n`: The number of elements in each combination.\n\n    Returns:\n        A list of tuples, each representing a combination of `n` elements.\n\n    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n    >>> subset_combinations(elements=[1, 2, 3], n=1)\n    [(1,), (2,), (3,)]\n    >>> subset_combinations(elements=[1, 2, 3], n=3)\n    [(1, 2, 3)]\n    >>> subset_combinations(elements=[42], n=1)\n    [(42,)]\n    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n    [(6, 7, 8, 9)]\n    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n    [()]\n    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n    >>> subset_combinations(elements=['single'], n=0)\n    [()]\n    >>> subset_combinations(elements=[], n=9)\n    []\n    >>> from itertools import combinations\n    >>> all(subset_combinations(items, n) == list(combinations(items, n))\n    ...     for items, n in (\n    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n    True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef _gettext_noop(message):\n    return message", "output": "Mark a string as a translation string without translating it."}
{"task": "repair", "input": "fix bug:\ndef is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq", "output": "def is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq"}
{"task": "detection", "input": "classify code:\ndef move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n    \"\"\"\n    Simulates gravity in a specific column.\n\n    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n    [['-', '-'], ['-', 'A'], ['-', 'C']]\n    \"\"\"\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef get_squarefrees(unique_coefficients: set[int]) -> set[int]:\n    \"\"\"\n    Calculates the squarefree numbers inside unique_coefficients.\n\n    Based on the definition of a non-squarefree number, then any non-squarefree\n    n can be decomposed as n = p*p*r, where p is positive prime number and r\n    is a positive integer.\n\n    Under the previous formula, any coefficient that is lower than p*p is\n    squarefree as r cannot be negative. On the contrary, if any r exists such\n    that n = p*p*r, then the number is non-squarefree.\n\n    >>> get_squarefrees({1})\n    {1}\n    >>> get_squarefrees({1, 2})\n    {1, 2}\n    >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})\n    {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}\n    \"\"\"\n\n    non_squarefrees = set()\n    for number in unique_coefficients:\n        divisor = 2\n        copy_number = number\n        while divisor**2 <= copy_number:\n            multiplicity = 0\n            while copy_number % divisor == 0:\n                copy_number //= divisor\n                multiplicity += 1\n            if multiplicity >= 2:\n                non_squarefrees.add(number)\n                break\n            divisor += 1\n\n    return unique_coefficients.difference(non_squarefrees)", "output": "def get_squarefrees(unique_coefficients: set[int]) -> set[int]:\n    \"\"\"\n    Calculates the squarefree numbers inside unique_coefficients.\n\n    Based on the definition of a non-squarefree number, then any non-squarefree\n    n can be decomposed as n = p*p*r, where p is positive prime number and r\n    is a positive integer.\n\n    Under the previous formula, any coefficient that is lower than p*p is\n    squarefree as r cannot be negative. On the contrary, if any r exists such\n    that n = p*p*r, then the number is non-squarefree.\n\n    >>> get_squarefrees({1})\n    {1}\n    >>> get_squarefrees({1, 2})\n    {1, 2}\n    >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})\n    {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}\n    \"\"\"\n\n    non_squarefrees = set()\n    for number in unique_coefficients:\n        divisor = 2\n        copy_number = number\n        while divisor**2 <= copy_number:\n            multiplicity = 0\n            while copy_number % divisor == 0:\n                copy_number //= divisor\n                multiplicity += 1\n            if multiplicity >= 2:\n                non_squarefrees.add(number)\n                break\n            divisor += 1\n\n    return unique_coefficients.difference(non_squarefrees)"}
{"task": "summary", "input": "summarize code:\ndef resistor_series(resistors: list[float]) -> float:\n    sum_r = 0.00\n    for index, resistor in enumerate(resistors):\n        sum_r += resistor\n        if resistor < 0:\n            msg = f\"Resistor at index {index} has a negative value!\"\n            raise ValueError(msg)\n    return sum_r", "output": "Req = R1 + R2 + ... + Rn"}
{"task": "search", "input": "search code:\nThis function calculates the average of the waiting times\n\nChoices:\n0: def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:     right = right or len(list_data) - 1     if left > right:         return -1     elif list_data[left] == key:         return left     elif list_data[right] == key:         return right     else:         return search(list_data, key, left + 1, right - 1)\n1: def calculate_average_waiting_time(waiting_times: list[int]) -> float:     return sum(waiting_times) / len(waiting_times)\n2: def sum_of_squares(it):     return _sumprod(*tee(it))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]", "output": "Remove leading and trailing characters (whitespace by default) from a string."}
{"task": "search", "input": "search code:\nReturns ``True`` if all the elements are equal to each other.\n\nChoices:\n0: def all_equal(iterable, key=None):     iterator = groupby(iterable, key)     for first in iterator:         for second in iterator:             return False         return True     return True\n1: def consume(iterator, n=None):     # Use functions that consume iterators at C speed.     if n is None:         # feed the entire iterator into a zero-length deque         deque(iterator, maxlen=0)     else:         # advance to the empty slice starting at position n         next(islice(iterator, n, n), None)\n2: def is_collection(obj):     return is_iterable(obj) and not isinstance(obj, (str, bytes))", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef pigeon_sort(array):\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "def pigeon_sort(array):\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if(len(array) == 0):\n        return array\n\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array"}
{"task": "summary", "input": "summarize code:\ndef mkdir_p(path):\n    try:\n        os.makedirs(path)\n    except OSError as exc:\n        if exc.errno == errno.EEXIST and os.path.isdir(path):\n            return\n        raise\n    return", "output": "Creates a directory and any parent directories that may need to"}
{"task": "search", "input": "search code:\nParse the file, build the tree, then run through the file\n\nChoices:\n0: def huffman(file_path: str) -> None:     letters_list = parse_file(file_path)     root = build_tree(letters_list)     letters = {         k: v for letter in traverse_tree(root, \"\") for k, v in letter.bitstring.items()     }     print(f\"Huffman Coding  of {file_path}: \")     with open(file_path) as f:         while True:             c = f.read(1)             if not c:                 break             print(letters[c], end=\" \")     print()\n1: def narcissistic_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False     expo = len(str(n))  # the power that all digits will be raised to     # check if sum of each digit multiplied expo times is equal to number     return n == sum(int(i) ** expo for i in str(n))\n2: def solution() -> int:     limit = 7 * factorial(9) + 1     return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef split(string: str, seperator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values seperated by the seperator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",seperator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",seperator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",seperator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == seperator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words"}
{"task": "detection", "input": "classify code:\ndef calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef fib_recursive(n: int) -> list[int]:\n\n    def fib_recursive_term(i: int) -> int:\n        if i < 0:\n            raise ValueError(\"n is negative\")\n        if i < 2:\n            return i\n        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)\n\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    return [fib_recursive_term(i) for i in range(n + 1)]", "output": "Calculates the first n (0-indexed) Fibonacci numbers using recursion"}
{"task": "repair", "input": "fix bug:\ndef optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost", "output": "def optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost"}
{"task": "search", "input": "search code:\nRobustly parses a short text description of a time period into a\n\nChoices:\n0: def parse_timedelta(text):     td_kwargs = {}     for match in _PARSE_TD_RE.finditer(text):         value, unit = match.group('value'), match.group('unit')         try:             unit_key = _PARSE_TD_KW_MAP[unit]         except KeyError:             raise ValueError('invalid time unit %r, expected one of %r'                              % (unit, _PARSE_TD_KW_MAP.keys()))         try:             value = float(value)         except ValueError:             raise ValueError('invalid time value for unit %r: %r'                              % (unit, value))         td_kwargs[unit_key] = value     return timedelta(**td_kwargs)\n1: def liouville_lambda(number: int) -> int:     if not isinstance(number, int):         msg = f\"Input value of [number={number}] must be an integer\"         raise TypeError(msg)     if number < 1:         raise ValueError(\"Input must be a positive integer\")     return -1 if len(prime_factors(number)) % 2 else 1\n2: def binary_search(sorted_collection: list[int], item: int) -> int:     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     left = 0     right = len(sorted_collection) - 1      while left <= right:         midpoint = left + (right - left) // 2         current_item = sorted_collection[midpoint]         if current_item == item:             return midpoint         elif item < current_item:             right = midpoint - 1         else:             left = midpoint + 1     return -1", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)", "output": "Returns the sum of all the multiples of 3 or 5 below n."}
{"task": "detection", "input": "classify code:\ndef is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the string concatenated with the delimiter we provide.\n\nChoices:\n0: def lexical_order(max_number: int) -> Iterator[int]:      stack = [1]      while stack:         num = stack.pop()         if num > max_number:             continue          yield num         if (num % 10) != 9:             stack.append(num + 1)          stack.append(num * 10)\n1: def to_complex_case(text: str, upper: bool, separator: str) -> str:     try:         string_split = split_input(text)         if upper:             res_str = \"\".join(                 [                     separator.join([char.upper() for char in sub_str])                     for sub_str in string_split                 ]             )         else:             res_str = \"\".join(                 [                     separator.join([char.lower() for char in sub_str])                     for sub_str in string_split                 ]             )         return res_str     except IndexError:         return \"not valid string\"\n2: def decimal_to_ipv4(decimal_ipv4: int) -> str:      if not (0 <= decimal_ipv4 <= 4294967295):         raise ValueError(\"Invalid decimal IPv4 address\")      ip_parts = []     for _ in range(4):         ip_parts.append(str(decimal_ipv4 & 255))         decimal_ipv4 >>= 8      return \".\".join(reversed(ip_parts))", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef merge_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Time Complexity: O(n log n)\n    Space Complexity: O(n)\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def merge(left: list, right: list) -> list:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n\n        :param left: Left collection\n        :param right: Right collection\n        :return: Merged result\n        \"\"\"\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))", "output": "def merge_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Time Complexity: O(n log n)\n    Space Complexity: O(n)\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def merge(left: list, right: list) -> list:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n\n        :param left: Left collection\n        :param right: Right collection\n        :return: Merged result\n        \"\"\"\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))"}
{"task": "summary", "input": "summarize code:\ndef mobius(n: int) -> int:\n    factors = prime_factors(n)\n    if is_square_free(factors):\n        return -1 if len(factors) % 2 else 1\n    return 0", "output": "Mobius function"}
{"task": "repair", "input": "fix bug:\ndef stalin_sort(sequence: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Stalin sort algorithm.\n\n    >>> stalin_sort([4, 3, 5, 2, 1, 7])\n    [4, 5, 7]\n\n    >>> stalin_sort([1, 2, 3, 4])\n    [1, 2, 3, 4]\n\n    >>> stalin_sort([4, 5, 5, 2, 3])\n    [4, 5, 5]\n\n    >>> stalin_sort([6, 11, 12, 4, 1, 5])\n    [6, 11, 12]\n\n    >>> stalin_sort([5, 0, 4, 3])\n    [5]\n\n    >>> stalin_sort([5, 4, 3, 2, 1])\n    [5]\n\n    >>> stalin_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> stalin_sort([1, 2, 8, 7, 6])\n    [1, 2, 8]\n    \"\"\"\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result", "output": "def stalin_sort(sequence: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Stalin sort algorithm.\n\n    >>> stalin_sort([4, 3, 5, 2, 1, 7])\n    [4, 5, 7]\n\n    >>> stalin_sort([1, 2, 3, 4])\n    [1, 2, 3, 4]\n\n    >>> stalin_sort([4, 5, 5, 2, 3])\n    [4, 5, 5]\n\n    >>> stalin_sort([6, 11, 12, 4, 1, 5])\n    [6, 11, 12]\n\n    >>> stalin_sort([5, 0, 4, 3])\n    [5]\n\n    >>> stalin_sort([5, 4, 3, 2, 1])\n    [5]\n\n    >>> stalin_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> stalin_sort([1, 2, 8, 7, 6])\n    [1, 2, 8]\n    \"\"\"\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result"}
{"task": "detection", "input": "classify code:\ndef circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns a list of all left and right truncated numbers of n\n\nChoices:\n0: def list_truncated_nums(n: int) -> list[int]:     str_num = str(n)     list_nums = [n]     for i in range(1, len(str_num)):         list_nums.append(int(str_num[i:]))         list_nums.append(int(str_num[:-i]))     return list_nums\n1: def get_files_url() -> str:     with open(os.environ[\"GITHUB_EVENT_PATH\"]) as file:         event = json.load(file)     return event[\"pull_request\"][\"url\"] + \"/files\"\n2: def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:      try:         # Has user provided both inputs?         if not drug_name or not zip_code:             return None          request_url = BASE_URL.format(drug_name, zip_code)         response = httpx.get(request_url, timeout=10).raise_for_status()          # Scrape the data using bs4         soup = BeautifulSoup(response.text, \"html.parser\")          # This list will store the name and price.         pharmacy_price_list = []          # Fetch all the grids that contain the items.         grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})         if grid_list and len(grid_list) > 0:             for grid in grid_list:                 # Get the pharmacy price.                 pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text                  # Get the price of the drug.                 price = grid.find(\"span\", {\"p\", \"price price-large\"}).text                  pharmacy_price_list.append(                     {                         \"pharmacy_name\": pharmacy_name,                         \"price\": price,                     }                 )          return pharmacy_price_list      except (httpx.HTTPError, ValueError):         return None", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef args2sh(args, sep=' '):\n    ret_list = []\n\n    for arg in args:\n        if not arg:\n            ret_list.append(\"''\")\n            continue\n        if _find_sh_unsafe(arg) is None:\n            ret_list.append(arg)\n            continue\n        # use single quotes, and put single quotes into double quotes\n        # the string $'b is then quoted as '$'\"'\"'b'\n        ret_list.append(\"'\" + arg.replace(\"'\", \"'\\\"'\\\"'\") + \"'\")\n\n    return ' '.join(ret_list)", "output": "Return a shell-escaped string version of *args*, separated by"}
{"task": "repair", "input": "fix bug:\ndef prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result", "output": "def prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result"}
{"task": "search", "input": "search code:\nCalculate the score for a character pair based on whether they match or mismatch.\n\nChoices:\n0: def count_vowels(s: str) -> int:     if not isinstance(s, str):         raise ValueError(\"Input must be a string\")      vowels = \"aeiouAEIOU\"     return sum(1 for char in s if char in vowels)\n1: def score_function(     source_char: str,     target_char: str,     match: int = 1,     mismatch: int = -1,     gap: int = -2, ) -> int:     if \"-\" in (source_char, target_char):         return gap     return match if source_char == target_char else mismatch\n2: def solution():      return sum(         {             int(\"\".join(pandigital[5:9]))             for pandigital in itertools.permutations(\"123456789\")             if is_combination_valid(pandigital)         }     )", "output": "1"}
{"task": "detection", "input": "classify code:\ndef equilibrium_index(arr: list[int]) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5])\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1])\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3])\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i, value in enumerate(arr):\n        total_sum -= value\n        if left_sum == total_sum:\n            return i\n        left_sum += value\n\n    return -1", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef sieve() -> Generator[int]:\n    factor_map: dict[int, int] = {}\n    prime = 2\n    while True:\n        factor = factor_map.pop(prime, None)\n        if factor:\n            x = factor + prime\n            while x in factor_map:\n                x += factor\n            factor_map[x] = factor\n        else:\n            factor_map[prime * prime] = prime\n            yield prime\n        prime += 1", "output": "Returns a prime number generator using sieve method."}
{"task": "detection", "input": "classify code:\ndef solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares", "output": "BUGGY"}
{"task": "search", "input": "search code:\nA pure Python implementation of circle sort algorithm\n\nChoices:\n0: def simple_fibonacci(n, f1, f2):     # Trivial Cases     if n == 1:         return f1     elif n == 2:         return f2      n -= 2      while n > 0:         f2, f1 = f1 + f2, f2         n -= 1      return f2\n1: def circle_sort(collection: list) -> list:      if len(collection) < 2:         return collection      def circle_sort_util(collection: list, low: int, high: int) -> bool:          swapped = False          if low == high:             return swapped          left = low         right = high          while left < right:             if collection[left] > collection[right]:                 collection[left], collection[right] = (                     collection[right],                     collection[left],                 )                 swapped = True              left += 1             right -= 1          if left == right and collection[left] > collection[right + 1]:             collection[left], collection[right + 1] = (                 collection[right + 1],                 collection[left],             )              swapped = True          mid = low + int((high - low) / 2)         left_swap = circle_sort_util(collection, low, mid)         right_swap = circle_sort_util(collection, mid + 1, high)          return swapped or left_swap or right_swap      is_not_sorted = True      while is_not_sorted is True:         is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)      return collection\n2: def solution(n: int = 1000) -> int:      xmulti = []     zmulti = []     z = 3     x = 5     temp = 1     while True:         result = z * temp         if result < n:             zmulti.append(result)             temp += 1         else:             temp = 1             break     while True:         result = x * temp         if result < n:             xmulti.append(result)             temp += 1         else:             break     collection = list(set(xmulti + zmulti))     return sum(collection)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef decimal_to_binary(no_of_variable: int, minterms: List[float]) -> List[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp", "output": "def decimal_to_binary(no_of_variable: int, minterms: list[float]) -> list[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp"}
{"task": "search", "input": "search code:\nSimple implementation of Root Mean Squared Error\n\nChoices:\n0: def root_mean_square_error(original: np.ndarray, reference: np.ndarray) -> float:     return float(np.sqrt(((original - reference) ** 2).mean()))\n1: def solution(min_total: int = 10**12) -> int:      prev_numerator = 1     prev_denominator = 0      numerator = 1     denominator = 1      while numerator <= 2 * min_total - 1:         prev_numerator += 2 * numerator         numerator += 2 * prev_numerator          prev_denominator += 2 * denominator         denominator += 2 * prev_denominator      return (denominator + 1) // 2\n2: def binary_search_std_lib(sorted_collection: list[int], item: int) -> int:     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     index = bisect.bisect_left(sorted_collection, item)     if index != len(sorted_collection) and sorted_collection[index] == item:         return index     return -1", "output": "0"}
{"task": "detection", "input": "classify code:\ndef lomuto_partition(sorting: list, left: int, right: int) -> int:\n    \"\"\"\n    Example:\n    >>> lomuto_partition([1,5,7,6], 0, 3)\n    2\n    \"\"\"\n    pivot = sorting[right]\n    store_index = left\n    for i in range(left, right):\n        if sorting[i] < pivot:\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\n            store_index += 1\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\n    return store_index", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef double_linear_search(array: List[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r", "output": "def double_linear_search(array: list[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r"}
{"task": "summary", "input": "summarize code:\ndef smallest_range(nums: list[list[int]]) -> list[int]:\n\n    min_heap: list[tuple[int, int, int]] = []\n    current_max = -maxsize - 1\n\n    for i, items in enumerate(nums):\n        heappush(min_heap, (items[0], i, 0))\n        current_max = max(current_max, items[0])\n\n    # Initialize smallest_range with large integer values\n    smallest_range = [-maxsize - 1, maxsize]\n\n    while min_heap:\n        current_min, list_index, element_index = heappop(min_heap)\n\n        if current_max - current_min < smallest_range[1] - smallest_range[0]:\n            smallest_range = [current_min, current_max]\n\n        if element_index == len(nums[list_index]) - 1:\n            break\n\n        next_element = nums[list_index][element_index + 1]\n        heappush(min_heap, (next_element, list_index, element_index + 1))\n        current_max = max(current_max, next_element)\n\n    return smallest_range", "output": "Find the smallest range from each list in nums."}
{"task": "detection", "input": "classify code:\ndef split(string: str, seperator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values seperated by the seperator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",seperator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",seperator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",seperator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == seperator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef load_data() -> list[list[str]]:\n    \"\"\"\n    Returns a sample transaction dataset.\n\n    >>> load_data()\n    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]\n    \"\"\"\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]", "output": "def load_data() -> list[list[str]]:\n    \"\"\"\n    Returns a sample transaction dataset.\n\n    >>> load_data()\n    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]\n    \"\"\"\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]"}
{"task": "search", "input": "search code:\nFunction returns the right side view of binary tree.\n\nChoices:\n0: def solution(limit: float = 1e10) -> int:     primes = sieve()      n = 1     while True:         prime = next(primes)         if (2 * prime * n) > limit:             return n         # Ignore the next prime as the reminder will be 2.         next(primes)         n += 2\n1: def binary_tree_right_side_view(root: TreeNode) -> list[int]:      def depth_first_search(         root: TreeNode | None, depth: int, right_view: list[int]     ) -> None:         if not root:             return          if depth == len(right_view):             right_view.append(root.val)          depth_first_search(root.right, depth + 1, right_view)         depth_first_search(root.left, depth + 1, right_view)      right_view: list = []     if not root:         return right_view      depth_first_search(root, 0, right_view)     return right_view\n2: def solution() -> float:      peter_totals_frequencies = total_frequency_distribution(         sides_number=4, dice_number=9     )     colin_totals_frequencies = total_frequency_distribution(         sides_number=6, dice_number=6     )      peter_wins_count = 0     min_peter_total = 9     max_peter_total = 4 * 9     min_colin_total = 6     for peter_total in range(min_peter_total, max_peter_total + 1):         peter_wins_count += peter_totals_frequencies[peter_total] * sum(             colin_totals_frequencies[min_colin_total:peter_total]         )      total_games_number = (4**9) * (6**6)     peter_win_probability = peter_wins_count / total_games_number      rounded_peter_win_probability = round(peter_win_probability, ndigits=7)      return rounded_peter_win_probability", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_significant_digits(colors: list) -> str:\n    digit = \"\"\n    for color in colors:\n        if color not in significant_figures_color_values:\n            msg = f\"{color} is not a valid color for significant figure bands\"\n            raise ValueError(msg)\n        digit = digit + str(significant_figures_color_values[color])\n    return str(digit)", "output": "Function returns the digit associated with the color. Function takes a"}
{"task": "repair", "input": "fix bug:\ndef selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection", "output": "def selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection"}
{"task": "detection", "input": "classify code:\ndef split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef huffman(file_path: str) -> None:\n    letters_list = parse_file(file_path)\n    root = build_tree(letters_list)\n    letters = {\n        k: v for letter in traverse_tree(root, \"\") for k, v in letter.bitstring.items()\n    }\n    print(f\"Huffman Coding  of {file_path}: \")\n    with open(file_path) as f:\n        while True:\n            c = f.read(1)\n            if not c:\n                break\n            print(letters[c], end=\" \")\n    print()", "output": "Parse the file, build the tree, then run through the file"}
{"task": "search", "input": "search code:\nFind the maximum prize fund that should be allocated to a single game in which\n\nChoices:\n0: def solution(num_turns: int = 15) -> int:     total_prob: float = 0.0     prob: float     num_blue: int     num_red: int     ind: int     col: int     series: tuple[int, ...]      for series in product(range(2), repeat=num_turns):         num_blue = series.count(1)         num_red = num_turns - num_blue         if num_red >= num_blue:             continue         prob = 1.0         for ind, col in enumerate(series, 2):             if col == 0:                 prob *= (ind - 1) / ind             else:                 prob *= 1 / ind          total_prob += prob      return int(1 / total_prob)\n1: def height(root: Node | None) -> int:     return (max(height(root.left), height(root.right)) + 1) if root else 0\n2: def continuous_fraction_period(n: int) -> int:     numerator = 0.0     denominator = 1.0     root = int(sqrt(n))     integer_part = root     period = 0     while integer_part != 2 * root:         numerator = denominator * integer_part - numerator         denominator = (n - numerator**2) / denominator         integer_part = int((root + numerator) / denominator)         period += 1     return period", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef is_complete(board: list[list[int]]) -> bool:\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "Check if the board (matrix) has been completely filled with non-zero values."}
{"task": "detection", "input": "classify code:\ndef prime_sieve(n: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFlatten a binary tree into a linked list in-place, where the linked list is\n\nChoices:\n0: def solution(n: int = 1000) -> int:     triplets = pythagorean_triple(n)     return triplets.most_common(1)[0][0]\n1: def find_winner(num_people: int, step_size: int) -> int:     return josephus_recursive(num_people, step_size) + 1\n2: def flatten(root: TreeNode | None) -> None:     if not root:         return      # Flatten the left subtree     flatten(root.left)      # Save the right subtree     right_subtree = root.right      # Make the left subtree the new right subtree     root.right = root.left     root.left = None      # Find the end of the new right subtree     current = root     while current.right:         current = current.right      # Append the original right subtree to the end     current.right = right_subtree      # Flatten the updated right subtree     flatten(right_subtree)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef selection(chart: List[List[int]], prime_implicants: List[str]) -> List[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0", "output": "def selection(chart: list[list[int]], prime_implicants: list[str]) -> list[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0"}
{"task": "detection", "input": "classify code:\ndef extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFinds the sum of all the positive integers which cannot be written as\n\nChoices:\n0: def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:      y, x = position     positions = [         (y + 1, x + 2),         (y - 1, x + 2),         (y + 1, x - 2),         (y - 1, x - 2),         (y + 2, x + 1),         (y + 2, x - 1),         (y - 2, x + 1),         (y - 2, x - 1),     ]     permissible_positions = []      for inner_position in positions:         y_test, x_test = inner_position         if 0 <= y_test < n and 0 <= x_test < n:             permissible_positions.append(inner_position)      return permissible_positions\n1: def solution(limit=28123):     sum_divs = [1] * (limit + 1)      for i in range(2, int(limit**0.5) + 1):         sum_divs[i * i] += i         for k in range(i + 1, limit // i + 1):             sum_divs[k * i] += k + i      abundants = set()     res = 0      for n in range(1, limit + 1):         if sum_divs[n] > n:             abundants.add(n)          if not any((n - a in abundants) for a in abundants):             res += n      return res\n2: def count_vowels(s: str) -> int:     if not isinstance(s, str):         raise ValueError(\"Input must be a string\")      vowels = \"aeiouAEIOU\"     return sum(1 for char in s if char in vowels)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef naive_pattern_search(s: str, pattern: str) -> list:\n    \"\"\"\n    >>> naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\")\n    [4, 10, 18]\n    >>> naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\")\n    []\n    >>> naive_pattern_search(\"\", \"ABC\")\n    []\n    >>> naive_pattern_search(\"TEST\", \"TEST\")\n    [0]\n    >>> naive_pattern_search(\"ABCDEGFTEST\", \"TEST\")\n    [7]\n    \"\"\"\n    pat_len = len(pattern)\n    position = []\n    for i in range(len(s) - pat_len + 1):\n        match_found = True\n        for j in range(pat_len):\n            if s[i + j] != pattern[j]:\n                match_found = False\n                break\n        if match_found:\n            position.append(i)\n    return position", "output": "def naive_pattern_search(s: str, pattern: str) -> list:\n    \"\"\"\n    >>> naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\")\n    [4, 10, 18]\n    >>> naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\")\n    []\n    >>> naive_pattern_search(\"\", \"ABC\")\n    []\n    >>> naive_pattern_search(\"TEST\", \"TEST\")\n    [0]\n    >>> naive_pattern_search(\"ABCDEGFTEST\", \"TEST\")\n    [7]\n    \"\"\"\n    pat_len = len(pattern)\n    position = []\n    for i in range(len(s) - pat_len + 1):\n        match_found = True\n        for j in range(pat_len):\n            if s[i + j] != pattern[j]:\n                match_found = False\n                break\n        if match_found:\n            position.append(i)\n    return position"}
{"task": "summary", "input": "summarize code:\ndef is_safe_prime(number: int) -> bool:\n    if not isinstance(number, int) or number < 1:\n        msg = f\"Input value must be a positive integer. Input value: {number}\"\n        raise TypeError(msg)\n\n    return (number - 1) % 2 == 0 and is_prime(number) and is_prime((number - 1) // 2)", "output": "Checks if input number and (number - 1)/2 are prime."}
{"task": "detection", "input": "classify code:\ndef sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    \"\"\"\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPrint Pascal's triangle for different number of rows\n\nChoices:\n0: def print_pascal_triangle(num_rows: int) -> None:     triangle = generate_pascal_triangle(num_rows)     for row_idx in range(num_rows):         # Print left spaces         for _ in range(num_rows - row_idx - 1):             print(end=\" \")         # Print row values         for col_idx in range(row_idx + 1):             if col_idx != row_idx:                 print(triangle[row_idx][col_idx], end=\" \")             else:                 print(triangle[row_idx][col_idx], end=\"\")         print()\n1: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)\n2: def solution(n: int = 1000000) -> int:      result = max((collatz_sequence_length(i), i) for i in range(1, n))     return result[1]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef reactive_power(apparent_power: float, power_factor: float) -> float:\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * math.sqrt(1 - power_factor**2)", "output": "Calculate reactive power from apparent power and power factor."}
{"task": "repair", "input": "fix bug:\ndef search(target: int, prime_list: list) -> bool:\n    \"\"\"\n    function to search a number in a list using Binary Search.\n    >>> search(3, [1, 2, 3])\n    True\n    >>> search(4, [1, 2, 3])\n    False\n    >>> search(101, list(range(-100, 100)))\n    False\n    \"\"\"\n\n    left, right = 0, len(prime_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if prime_list[middle] == target:\n            return True\n        elif prime_list[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return False", "output": "def search(target: int, prime_list: list) -> bool:\n    \"\"\"\n    function to search a number in a list using Binary Search.\n    >>> search(3, [1, 2, 3])\n    True\n    >>> search(4, [1, 2, 3])\n    False\n    >>> search(101, list(range(-100, 100)))\n    False\n    \"\"\"\n\n    left, right = 0, len(prime_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if prime_list[middle] == target:\n            return True\n        elif prime_list[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return False"}
{"task": "repair", "input": "fix bug:\ndef find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n    \"\"\"\n    n = len(nums)\n    missing_number = n\n\n    for i in range(n):\n        missing_number ^= i ^ nums[i]\n\n    return missing_number", "output": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n\n    for i in range(low, high):\n        missing_number ^= i ^ nums[i - low]\n\n    return missing_number"}
{"task": "search", "input": "search code:\nReturns the total of all the name scores in the file.\n\nChoices:\n0: def solution():     with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:         names = str(file.readlines()[0])         names = names.replace('\"', \"\").split(\",\")      names.sort()      name_score = 0     total_score = 0      for i, name in enumerate(names):         for letter in name:             name_score += ord(letter) - 64          total_score += (i + 1) * name_score         name_score = 0     return total_score\n1: def actual_power(a: int, b: int) -> int:     if b == 0:         return 1     half = actual_power(a, b // 2)      if (b % 2) == 0:         return half * half     else:         return a * half * half\n2: def abs_val(num: float) -> float:     return -num if num < 0 else num", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 10) -> str:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Invalid input\")\n    modulus = 10**n\n    number = 28433 * (pow(2, 7830457, modulus)) + 1\n    return str(number % modulus)", "output": "Returns the last n digits of NUMBER."}
{"task": "detection", "input": "classify code:\ndef calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCompute high-dimensional affinities (P matrix) using a Gaussian kernel.\n\nChoices:\n0: def vol_cuboid(width: float, height: float, length: float) -> float:     if width < 0 or height < 0 or length < 0:         raise ValueError(\"vol_cuboid() only accepts non-negative values\")     return float(width * height * length)\n1: def compute_pairwise_affinities(data_matrix: ndarray, sigma: float = 1.0) -> ndarray:     n_samples = data_matrix.shape[0]     squared_sum = np.sum(np.square(data_matrix), axis=1)     squared_distance = np.add(         np.add(-2 * np.dot(data_matrix, data_matrix.T), squared_sum).T, squared_sum     )      affinity_matrix = np.exp(-squared_distance / (2 * sigma**2))     np.fill_diagonal(affinity_matrix, 0)      affinity_matrix /= np.sum(affinity_matrix)     return (affinity_matrix + affinity_matrix.T) / (2 * n_samples)\n2: def validate_initial_digits(credit_card_number: str) -> bool:     return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in xrange(m)] for _ in xrange(m + 1)]\n    for i in xrange(m + 1):\n        memo[i][0] = 1\n\n    for n in xrange(m + 1):\n        for k in xrange(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )", "output": "def question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )"}
{"task": "summary", "input": "summarize code:\ndef windowed_iter(src, size, fill=_UNSET):\n    tees = itertools.tee(src, size)\n    if fill is _UNSET:\n        try:\n            for i, t in enumerate(tees):\n                for _ in range(i):\n                    next(t)\n        except StopIteration:\n            return zip([])\n        return zip(*tees)\n\n    for i, t in enumerate(tees):\n        for _ in range(i):\n            try:\n                next(t)\n            except StopIteration:\n                continue\n    return zip_longest(*tees, fillvalue=fill)", "output": "Returns tuples with length *size* which represent a sliding"}
{"task": "summary", "input": "summarize code:\ndef subslices(iterable):\n    seq = list(iterable)\n    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n    return map(getitem, repeat(seq), slices)", "output": "Return all contiguous non-empty subslices of *iterable*."}
{"task": "detection", "input": "classify code:\ndef least_divisible_repunit(divisor: int) -> int:\n    \"\"\"\n    Return the least value k such that the Repunit of length k is divisible by divisor.\n    >>> least_divisible_repunit(7)\n    6\n    >>> least_divisible_repunit(41)\n    5\n    >>> least_divisible_repunit(1234567)\n    34020\n    \"\"\"\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCompute the first derivative of a polynomial.\n\nChoices:\n0: def polynomial_derivative(coefficients):     n = len(coefficients)     powers = reversed(range(1, n))     return list(map(mul, coefficients, powers))\n1: def matrix_pow_np(m: ndarray, power: int) -> ndarray:     result = np.array([[1, 0], [0, 1]], dtype=int)  # Identity Matrix     base = m     if power < 0:  # Negative power is not allowed         raise ValueError(\"power is negative\")     while power:         if power % 2 == 1:             result = np.dot(result, base)         base = np.dot(base, base)         power //= 2     return result\n2: def knapsack(     weights: list, values: list, number_of_items: int, max_weight: int, index: int ) -> int:     if index == number_of_items:         return 0     ans1 = 0     ans2 = 0     ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)     if weights[index] <= max_weight:         ans2 = values[index] + knapsack(             weights, values, number_of_items, max_weight - weights[index], index + 1         )     return max(ans1, ans2)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - ord(\"a\")] = True\n    return all(flag)", "output": "def check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)"}
{"task": "detection", "input": "classify code:\ndef is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef collect_dataset():\n    response = httpx.get(\n        \"https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/\"\n        \"master/Week1/ADRvsRating.csv\",\n        timeout=10,\n    )\n    lines = response.text.splitlines()\n    data = []\n    for item in lines:\n        item = item.split(\",\")\n        data.append(item)\n    data.pop(0)  # This is for removing the labels from the list\n    dataset = np.matrix(data)\n    return dataset", "output": "Collect dataset of CSGO"}
{"task": "search", "input": "search code:\nCalculate the variance\n\nChoices:\n0: def is_safe(board: list[list[int]], row: int, column: int) -> bool:      n = len(board)  # Size of the board      # Check if there is any queen in the same upper column,     # left upper diagonal and right upper diagonal     return (         all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))         )         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))         )     )\n1: def calculate_variance(items: list, means: list, total_count: int) -> float:     squared_diff = []  # An empty list to store all squared differences     # iterate over number of elements in items     for i in range(len(items)):         # for loop iterates over number of elements in inner layer of items         for j in range(len(items[i])):             # appending squared differences to 'squared_diff' list             squared_diff.append((items[i][j] - means[i]) ** 2)      # one divided by (the number of all instances - number of classes) multiplied by     # sum of all squared differences     n_classes = len(means)  # Number of classes in dataset     return 1 / (total_count - n_classes) * sum(squared_diff)\n2: def partition(pred, iterable):     if pred is None:         pred = bool      t1, t2, p = tee(iterable, 3)     p1, p2 = tee(map(pred, p))     return (compress(t1, map(not_, p1)), compress(t2, p2))", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef actual_power(a: int, b: int) -> int:\n    \"\"\"\n    Function using divide and conquer to calculate a^b.\n    It only works for integer a,b.\n\n    :param a: The base of the power operation, an integer.\n    :param b: The exponent of the power operation, a non-negative integer.\n    :return: The result of a^b.\n\n    Examples:\n    >>> actual_power(3, 2)\n    9\n    >>> actual_power(5, 3)\n    125\n    >>> actual_power(2, 5)\n    32\n    >>> actual_power(7, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    half = actual_power(a, b // 2)\n\n    if (b % 2) == 0:\n        return half * half\n    else:\n        return a * half * half", "output": "def actual_power(a: int, b: int) -> int:\n    \"\"\"\n    Function using divide and conquer to calculate a^b.\n    It only works for integer a,b.\n\n    :param a: The base of the power operation, an integer.\n    :param b: The exponent of the power operation, a non-negative integer.\n    :return: The result of a^b.\n\n    Examples:\n    >>> actual_power(3, 2)\n    9\n    >>> actual_power(5, 3)\n    125\n    >>> actual_power(2, 5)\n    32\n    >>> actual_power(7, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    half = actual_power(a, b // 2)\n\n    if (b % 2) == 0:\n        return half * half\n    else:\n        return a * half * half"}
{"task": "search", "input": "search code:\nReturn circular primes below limit.\n\nChoices:\n0: def find_circular_primes(limit: int = 1000000) -> list[int]:     result = [2]  # result already includes the number 2.     for num in range(3, limit + 1, 2):         if is_prime(num) and not contains_an_even_digit(num):             str_num = str(num)             list_nums = [int(str_num[j:] + str_num[:j]) for j in range(len(str_num))]             if all(is_prime(i) for i in list_nums):                 result.append(num)     return result\n1: def zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):      def is_scalar(obj):         if scalar_types and isinstance(obj, scalar_types):             return True         try:             iter(obj)         except TypeError:             return True         else:             return False      size = len(objects)     if not size:         return      new_item = [None] * size     iterables, iterable_positions = [], []     for i, obj in enumerate(objects):         if is_scalar(obj):             new_item[i] = obj         else:             iterables.append(iter(obj))             iterable_positions.append(i)      if not iterables:         yield tuple(objects)         return      for item in zip(*iterables, strict=strict):         for i, new_item[i] in zip(iterable_positions, item):             pass         yield tuple(new_item)\n2: def solution(limit: int = 50) -> int:     return sum(         1         for pt1, pt2 in combinations(product(range(limit + 1), repeat=2), 2)         if is_right(*pt1, *pt2)     )", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(numerator: int = 1, digit: int = 1000) -> int:\n    the_digit = 1\n    longest_list_length = 0\n\n    for divide_by_number in range(numerator, digit + 1):\n        has_been_divided: list[int] = []\n        now_divide = numerator\n        for _ in range(1, digit + 1):\n            if now_divide in has_been_divided:\n                if longest_list_length < len(has_been_divided):\n                    longest_list_length = len(has_been_divided)\n                    the_digit = divide_by_number\n            else:\n                has_been_divided.append(now_divide)\n                now_divide = now_divide * 10 % divide_by_number\n\n    return the_digit", "output": "Considering any range can be provided,"}
{"task": "repair", "input": "fix bug:\ndef shell_sort(collection: list) -> list:\n    \"\"\"Implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([3, 2, 1])\n    [1, 2, 3]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([1])\n    [1]\n    \"\"\"\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection", "output": "def shell_sort(collection: list) -> list:\n    \"\"\"Implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([3, 2, 1])\n    [1, 2, 3]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([1])\n    [1]\n    \"\"\"\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection"}
{"task": "detection", "input": "classify code:\ndef newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    Calculates force from `mass` and `acceleration`\n\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef recursive_imply_list(input_list: list[int]) -> int:\n    if len(input_list) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n    first_implication = imply_gate(input_list[0], input_list[1])\n    if len(input_list) == 2:\n        return first_implication\n    new_list = [first_implication, *input_list[2:]]\n    return recursive_imply_list(new_list)", "output": "Recursively calculates the implication of a list."}
{"task": "search", "input": "search code:\nActivate internationalisation.\n\nChoices:\n0: def activate(locale, path=None):     if path is None:         path = _get_default_locale_path()      if path is None:         raise Exception(             \"Humanize cannot determinate the default location of the 'locale' folder. \"             \"You need to pass the path explicitly.\"         )     if locale not in _TRANSLATIONS:         translation = gettext_module.translation(\"humanize\", path, [locale])         _TRANSLATIONS[locale] = translation     _CURRENT.locale = locale     return _TRANSLATIONS[locale]\n1: def _modexpt(base: int, exponent: int, modulo_value: int) -> int:      if exponent == 1:         return base     if exponent % 2 == 0:         x = _modexpt(base, exponent // 2, modulo_value) % modulo_value         return (x * x) % modulo_value     else:         return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value\n2: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef cycle_sort(array):\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return ans", "output": "def cycle_sort(array: list) -> list:\n    \"\"\"\n    >>> cycle_sort([4, 3, 2, 1])\n    [1, 2, 3, 4]\n\n    >>> cycle_sort([-4, 20, 0, -50, 100, -1])\n    [-50, -4, -1, 0, 20, 100]\n\n    >>> cycle_sort([-.1, -.2, 1.3, -.8])\n    [-0.8, -0.2, -0.1, 1.3]\n\n    >>> cycle_sort([])\n    []\n    \"\"\"\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return array"}
{"task": "search", "input": "search code:\nYield duplicate elements after their first appearance.\n\nChoices:\n0: def is_palindrome_stack(head: ListNode | None) -> bool:     if not head or not head.next_node:         return True      # 1. Get the midpoint (slow)     slow: ListNode | None = head     fast: ListNode | None = head     while fast and fast.next_node:         fast = fast.next_node.next_node         slow = slow.next_node if slow else None      # slow will always be defined,     # adding this check to resolve mypy static check     if slow:         stack = [slow.val]          # 2. Push the second half into the stack         while slow.next_node:             slow = slow.next_node             stack.append(slow.val)          # 3. Comparison         cur: ListNode | None = head         while stack and cur:             if stack.pop() != cur.val:                 return False             cur = cur.next_node      return True\n1: def breadth_first_search(graph: dict, start: str) -> list[str]:     explored = {start}     result = [start]     queue: Queue = Queue()     queue.put(start)     while not queue.empty():         v = queue.get()         for w in graph[v]:             if w not in explored:                 explored.add(w)                 result.append(w)                 queue.put(w)     return result\n2: def duplicates_everseen(iterable, key=None):     seen_set = set()     seen_list = []     use_key = key is not None      for element in iterable:         k = key(element) if use_key else element         try:             if k not in seen_set:                 seen_set.add(k)             else:                 yield element         except TypeError:             if k not in seen_list:                 seen_list.append(k)             else:                 yield element", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef recur_fibo(n):\n    if n <= 1:\n        return n\n    else:\n        (recur_fibo(n - 1) + recur_fibo(n - 2))", "output": "def recur_fibo(n):\n    \"\"\"\n    >>> [recur_fibo(i) for i in range(12)]\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n    \"\"\"\n    return n if n <= 1 else recur_fibo(n-1) + recur_fibo(n-2)"}
{"task": "summary", "input": "summarize code:\ndef generate_formula() -> Formula:\n    clauses: set[Clause] = set()\n    no_of_clauses = random.randint(1, 10)\n    while len(clauses) < no_of_clauses:\n        clauses.add(generate_clause())\n    return Formula(clauses)", "output": "Randomly generate a formula."}
{"task": "detection", "input": "classify code:\ndef moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to pressure.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_pressure(0.82, 3, 300)\n      90\n      >>> moles_to_pressure(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (volume)))", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times", "output": "def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times"}
{"task": "detection", "input": "classify code:\ndef kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is Â½mvÂ²\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef binary_exp_mod_iterative(base: float, exponent: int, modulus: int) -> float:\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer\")\n\n    res: int | float = 1\n    while exponent > 0:\n        if exponent & 1:\n            res = ((res % modulus) * (base % modulus)) % modulus\n\n        base *= base\n        exponent >>= 1\n\n    return res", "output": "Computes a^b % c iteratively, where a is the base, b is the exponent, and c is the"}
{"task": "search", "input": "search code:\nWrap an iterator-returning callable to make its iterators thread-safe.\n\nChoices:\n0: def synchronized(func):      @wraps(func)     def inner(*args, **kwargs):         iterator = func(*args, **kwargs)         return serialize(iterator)      return inner\n1: def decimal_to_ipv4(decimal_ipv4: int) -> str:      if not (0 <= decimal_ipv4 <= 4294967295):         raise ValueError(\"Invalid decimal IPv4 address\")      ip_parts = []     for _ in range(4):         ip_parts.append(str(decimal_ipv4 & 255))         decimal_ipv4 >>= 8      return \".\".join(reversed(ip_parts))\n2: def from_file(filename, sep=\"\\n\"):     \"Parse a file into a list of strings, separated by sep.\"     with open(filename) as file:         return file.read().strip().split(sep)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculates euclidean distance between two data.\n\nChoices:\n0: def couloumbs_law(     force: float, charge1: float, charge2: float, distance: float ) -> dict[str, float]:      charge_product = abs(charge1 * charge2)      if (force, charge1, charge2, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if distance < 0:         raise ValueError(\"Distance cannot be negative\")     if force == 0:         force = COULOMBS_CONSTANT * charge_product / (distance**2)         return {\"force\": force}     elif charge1 == 0:         charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)         return {\"charge1\": charge1}     elif charge2 == 0:         charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)         return {\"charge2\": charge2}     elif distance == 0:         distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5         return {\"distance\": distance}     raise ValueError(\"Exactly one argument must be 0\")\n1: def jaccard_similarity(     set_a: set[str] | list[str] | tuple[str],     set_b: set[str] | list[str] | tuple[str],     alternative_union=False, ):      if isinstance(set_a, set) and isinstance(set_b, set):         intersection_length = len(set_a.intersection(set_b))          if alternative_union:             union_length = len(set_a) + len(set_b)         else:             union_length = len(set_a.union(set_b))          return intersection_length / union_length      elif isinstance(set_a, (list, tuple)) and isinstance(set_b, (list, tuple)):         intersection = [element for element in set_a if element in set_b]          if alternative_union:             return len(intersection) / (len(set_a) + len(set_b))         else:             # Cast set_a to list because tuples cannot be mutated             union = list(set_a) + [element for element in set_b if element not in set_a]             return len(intersection) / len(union)     raise ValueError(         \"Set a and b must either both be sets or be either a list or a tuple.\"     )\n2: def euclidean(input_a: np.ndarray, input_b: np.ndarray) -> float:     return math.sqrt(sum(pow(a - b, 2) for a, b in zip(input_a, input_b)))", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid's Algorithm\n\n    >>> greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    >>> greatest_common_divisor(121, 11)\n    11\n\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while a % b != 0:\n        a, b = b, a % b\n\n    return b", "output": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid's Algorithm\n\n    >>> greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    >>> greatest_common_divisor(121, 11)\n    11\n\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while a % b != 0:\n        a, b = b, a % b\n\n    return b"}
{"task": "summary", "input": "summarize code:\ndef _extract_labels(f, one_hot=False, num_classes=10):\n    print(\"Extracting\", f.name)\n    with gzip.GzipFile(fileobj=f) as bytestream:\n        magic = _read32(bytestream)\n        if magic != 2049:\n            msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"\n            raise ValueError(msg)\n        num_items = _read32(bytestream)\n        buf = bytestream.read(num_items)\n        labels = np.frombuffer(buf, dtype=np.uint8)\n        if one_hot:\n            return _dense_to_one_hot(labels, num_classes)\n        return labels", "output": "Extract the labels into a 1D uint8 numpy array [index]."}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 50000000) -> int:\n    ret = set()\n    prime_square_limit = int((limit - 24) ** (1 / 2))\n\n    primes = set(range(3, prime_square_limit + 1, 2))\n    primes.add(2)\n    for p in range(3, prime_square_limit + 1, 2):\n        if p not in primes:\n            continue\n        primes.difference_update(set(range(p * p, prime_square_limit + 1, p)))\n\n    for prime1 in primes:\n        square = prime1 * prime1\n        for prime2 in primes:\n            cube = prime2 * prime2 * prime2\n            if square + cube >= limit - 16:\n                break\n            for prime3 in primes:\n                tetr = prime3 * prime3 * prime3 * prime3\n                total = square + cube + tetr\n                if total >= limit:\n                    break\n                ret.add(total)\n\n    return len(ret)", "output": "Return the number of integers less than limit which can be expressed as the sum"}
{"task": "repair", "input": "fix bug:\ndef p_series(nth_term: int, power: int) -> list:\n    \"\"\"Pure Python implementation of P-Series algorithm\n\n    :return: The P-Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> p_series(5, 2)\n    [1, '1/4', '1/9', '1/16', '1/25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    [1, '1/0.25', '1/0.1111111111111111', '1/0.0625', '1/0.04']\n    >>> p_series(\"\", 1000)\n    ''\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    [1]\n    \"\"\"\n    if nth_term == \"\":\n        return nth_term\n    nth_term = int(nth_term)\n    power = int(power)\n    series = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1/{pow(temp + 1, int(power))}\" if series else 1)\n    return series", "output": "def p_series(nth_term: int | float | str, power: int | float | str) -> list[str]:\n    \"\"\"\n    Pure Python implementation of P-Series algorithm\n    :return: The P-Series starting from 1 to last (nth) term\n    Examples:\n    >>> p_series(5, 2)\n    ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']\n    >>> p_series(\"\", 1000)\n    ['']\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    ['1']\n    \"\"\"\n    if nth_term == \"\":\n        return [\"\"]\n    nth_term = int(nth_term)\n    power = int(power)\n    series: list[str] = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")\n    return series"}
{"task": "search", "input": "search code:\nFind inductor current at any nth second after initiating its charging.\n\nChoices:\n0: def charging_inductor(     source_voltage: float,  # source_voltage should be in volts.     resistance: float,  # resistance should be in ohms.     inductance: float,  # inductance should be in henrys.     time: float,  # time should in seconds. ) -> float:      if source_voltage <= 0:         raise ValueError(\"Source voltage must be positive.\")     if resistance <= 0:         raise ValueError(\"Resistance must be positive.\")     if inductance <= 0:         raise ValueError(\"Inductance must be positive.\")     return round(         source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3     )\n1: def multi_replace(text, sub_map, **kwargs):     m = MultiReplace(sub_map, **kwargs)     return m.sub(text)\n2: def decipher(message: str, cipher_map: dict[str, str]) -> str:     # Reverse our cipher mappings     rev_cipher_map = {v: k for k, v in cipher_map.items()}     return \"\".join(rev_cipher_map.get(ch, ch) for ch in message.upper())", "output": "0"}
{"task": "detection", "input": "classify code:\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times", "output": "def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times"}
{"task": "summary", "input": "summarize code:\ndef in_reverse(linked_list: LinkedList) -> str:\n    return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))", "output": "Prints the elements of the given Linked List in reverse order"}
{"task": "search", "input": "search code:\nFunction checks the all possible combinations, and returns the count\n\nChoices:\n0: def transformation_matrix(velocity: float) -> np.ndarray:     return np.array(         [             [gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],             [-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],             [0, 0, 1, 0],             [0, 0, 0, 1],         ]     )\n1: def newton_raphson(     f: RealFunc,     x0: float = 0,     max_iter: int = 100,     step: float = 1e-6,     max_error: float = 1e-6,     log_steps: bool = False, ) -> tuple[float, float, list[float]]:      def f_derivative(x: float) -> float:         return calc_derivative(f, x, step)      a = x0  # Set initial guess     steps = []     for _ in range(max_iter):         if log_steps:  # Log intermediate steps             steps.append(a)          error = abs(f(a))         if error < max_error:             return a, error, steps          if f_derivative(a) == 0:             raise ZeroDivisionError(\"No converging solution found, zero derivative\")         a -= f(a) / f_derivative(a)  # Calculate next estimate     raise ArithmeticError(\"No converging solution found, iteration limit reached\")\n2: def combination_sum_iv_dp_array(array: list[int], target: int) -> int:      def count_of_possible_combinations_with_dp_array(         target: int, dp_array: list[int]     ) -> int:         if target < 0:             return 0         if target == 0:             return 1         if dp_array[target] != -1:             return dp_array[target]         answer = sum(             count_of_possible_combinations_with_dp_array(target - item, dp_array)             for item in array         )         dp_array[target] = answer         return answer      dp_array = [-1] * (target + 1)     return count_of_possible_combinations_with_dp_array(target, dp_array)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef scalar_multiply(matrix: List[list], n: int) -> List[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef get_pascal_triangle_unique_coefficients(depth: int) -> Set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients", "output": "def get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients"}
{"task": "summary", "input": "summarize code:\ndef calculate_span(price: list[int]) -> list[int]:\n    n = len(price)\n    s = [0] * n\n    # Create a stack and push index of fist element to it\n    st = []\n    st.append(0)\n\n    # Span value of first element is always 1\n    s[0] = 1\n\n    # Calculate span values for rest of the elements\n    for i in range(1, n):\n        # Pop elements from stack while stack is not\n        # empty and top of stack is smaller than price[i]\n        while len(st) > 0 and price[st[-1]] <= price[i]:\n            st.pop()\n\n        # If stack becomes empty, then price[i] is greater\n        # than all elements on left of it, i.e. price[0],\n        # price[1], ..price[i-1]. Else the price[i]  is\n        # greater than elements after top of stack\n        s[i] = i + 1 if len(st) <= 0 else (i - st[-1])\n\n        # Push this element to stack\n        st.append(i)\n\n    return s", "output": "Calculate the span values for a given list of stock prices."}
{"task": "search", "input": "search code:\nIt is similar iterative bubble sort but recursive.\n\nChoices:\n0: def postorder(root: Node | None) -> Generator[int]:     if not root:         return     yield from postorder(root.left)     yield from postorder(root.right)     yield root.data\n1: def solution() -> int:     return compute_nums(1)[0]\n2: def bubble_sort_recursive(collection: list[Any]) -> list[Any]:     length = len(collection)     swapped = False     for i in range(length - 1):         if collection[i] > collection[i + 1]:             collection[i], collection[i + 1] = collection[i + 1], collection[i]             swapped = True      return collection if not swapped else bubble_sort_recursive(collection)", "output": "2"}
{"task": "search", "input": "search code:\nConverts an underscored string to camelcased. Useful for turning a\n\nChoices:\n0: def ugly_numbers(n: int) -> int:     ugly_nums = [1]      i2, i3, i5 = 0, 0, 0     next_2 = ugly_nums[i2] * 2     next_3 = ugly_nums[i3] * 3     next_5 = ugly_nums[i5] * 5      for _ in range(1, n):         next_num = min(next_2, next_3, next_5)         ugly_nums.append(next_num)         if next_num == next_2:             i2 += 1             next_2 = ugly_nums[i2] * 2         if next_num == next_3:             i3 += 1             next_3 = ugly_nums[i3] * 3         if next_num == next_5:             i5 += 1             next_5 = ugly_nums[i5] * 5     return ugly_nums[-1]\n1: def under2camel(under_string):     return ''.join(w.capitalize() or '_' for w in under_string.split('_'))\n2: def nearest_neighbour_search(     root: KDNode | None, query_point: list[float] ) -> tuple[list[float] | None, float, int]:     nearest_point: list[float] | None = None     nearest_dist: float = float(\"inf\")     nodes_visited: int = 0      def search(node: KDNode | None, depth: int = 0) -> None:         nonlocal nearest_point, nearest_dist, nodes_visited         if node is None:             return          nodes_visited += 1          # Calculate the current distance (squared distance)         current_point = node.point         current_dist = sum(             (query_coord - point_coord) ** 2             for query_coord, point_coord in zip(query_point, current_point)         )          # Update nearest point if the current node is closer         if nearest_point is None or current_dist < nearest_dist:             nearest_point = current_point             nearest_dist = current_dist          # Determine which subtree to search first (based on axis and query point)         k = len(query_point)  # Dimensionality of points         axis = depth % k          if query_point[axis] <= current_point[axis]:             nearer_subtree = node.left             further_subtree = node.right         else:             nearer_subtree = node.right             further_subtree = node.left          # Search the nearer subtree first         search(nearer_subtree, depth + 1)          # If the further subtree has a closer point         if (query_point[axis] - current_point[axis]) ** 2 < nearest_dist:             search(further_subtree, depth + 1)      search(root, 0)     return nearest_point, nearest_dist, nodes_visited", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef longest_subsequence(array: List[int]) -> List[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq"}
{"task": "detection", "input": "classify code:\ndef find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n    \"\"\"\n    n = len(nums)\n    missing_number = n\n\n    for i in range(n):\n        missing_number ^= i ^ nums[i]\n\n    return missing_number", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef unique_prime_factors(n: int) -> list[int]:\n    i = 2\n    factors = []\n    while i * i <= n:\n        if not n % i:\n            while not n % i:\n                n //= i\n            factors.append(i)\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "output": "Returns unique prime factors of n as a list."}
{"task": "repair", "input": "fix bug:\ndef is_palindrome(n: Union[int, str]) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False", "output": "def is_palindrome(n: int | str) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False"}
{"task": "search", "input": "search code:\nUnion of two sets.\n\nChoices:\n0: def union_set(x: Node, y: Node) -> None:     x, y = find_set(x), find_set(y)     if x == y:         return      elif x.rank > y.rank:         y.parent = x     else:         x.parent = y         if x.rank == y.rank:             y.rank += 1\n1: def mark_ends(iterable):     it = iter(iterable)     for a in it:         first = True         for b in it:             yield first, False, a             a = b             first = False         yield first, True, a\n2: def bogo_sort(collection):      def is_sorted(collection):         for i in range(len(collection) - 1):             if collection[i] > collection[i + 1]:                 return False         return True      while not is_sorted(collection):         random.shuffle(collection)     return collection", "output": "0"}
{"task": "detection", "input": "classify code:\ndef vernam_encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_encrypt(\"HELLO\",\"KEY\")\n    'RIJVS'\n    \"\"\"\n    ciphertext = \"\"\n    for i in range(len(plaintext)):\n        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65\n        while ct > 25:\n            ct = ct - 26\n        ciphertext += chr(65 + ct)\n    return ciphertext", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef change_contrast(img: Image, level: int) -> Image:\n    factor = (259 * (level + 255)) / (255 * (259 - level))\n\n    def contrast(c: int) -> int:\n        return int(128 + factor * (c - 128))\n\n    return img.point(contrast)", "output": "Function to change contrast"}
{"task": "repair", "input": "fix bug:\ndef binary_search_insertion(sorted_list, item):\n    \"\"\"\n    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)\n    [1, 2, 4, 7, 9, 10]\n    \"\"\"\n    left = 0\n    right = len(sorted_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if left == right:\n            if sorted_list[middle] < item:\n                left = middle + 1\n            break\n        elif sorted_list[middle] < item:\n            left = middle + 1\n        else:\n            right = middle - 1\n    sorted_list.insert(left, item)\n    return sorted_list", "output": "def binary_search_insertion(sorted_list, item):\n    \"\"\"\n    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)\n    [1, 2, 4, 7, 9, 10]\n    \"\"\"\n    left = 0\n    right = len(sorted_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if left == right:\n            if sorted_list[middle] < item:\n                left = middle + 1\n            break\n        elif sorted_list[middle] < item:\n            left = middle + 1\n        else:\n            right = middle - 1\n    sorted_list.insert(left, item)\n    return sorted_list"}
{"task": "summary", "input": "summarize code:\ndef check_partition_perfect(positive_integer: int) -> bool:\n\n    exponent = math.log2(math.sqrt(4 * positive_integer + 1) / 2 + 1 / 2)\n\n    return exponent == int(exponent)", "output": "Check if t = f(positive_integer) = log2(sqrt(4*positive_integer+1)/2 + 1/2) is a"}
{"task": "search", "input": "search code:\nReturn a randomly shuffled copy of the input sequence.\n\nChoices:\n0: def shuffled(seq):     seq = list(seq)     random.shuffle(seq)     return seq\n1: def parse_token(token: str | float) -> float | str:     if token in OPERATORS:         return token     try:         return float(token)     except ValueError:         msg = f\"{token} is neither a number nor a valid operator\"         raise ValueError(msg)\n2: def apnumber(value):     try:         value = int(value)     except (TypeError, ValueError):         return value     if not 0 <= value < 10:         return str(value)     return (         _(\"zero\"),         _(\"one\"),         _(\"two\"),         _(\"three\"),         _(\"four\"),         _(\"five\"),         _(\"six\"),         _(\"seven\"),         _(\"eight\"),         _(\"nine\"),     )[value]", "output": "0"}
{"task": "detection", "input": "classify code:\ndef format_ruleset(ruleset: int) -> List[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same row, column,\n    # left upper diagonal, and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, n)))\n        and all(\n            board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, -1, -1))\n        )\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, n)))\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, -1, -1)))\n    )", "output": "def is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same upper column,\n    # left upper diagonal and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))\n        )\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))\n        )\n    )"}
{"task": "detection", "input": "classify code:\ndef get_pascal_triangle_unique_coefficients(depth: int) -> Set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef benchmark() -> None:\n    from collections.abc import Callable\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        print(f\"{call}: {func(value)} -- {timing} seconds\")\n\n    for value in (262144, 1125899906842624, 1267650600228229401496703205376):\n        for func in (num_digits, num_digits_fast, num_digits_faster):\n            benchmark_a_function(func, value)\n        print()", "output": "Benchmark multiple functions, with three different length int values."}
{"task": "search", "input": "search code:\nCreates a state space tree to iterate through each branch using DFS.\n\nChoices:\n0: def mbd(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     numerator = np.sum(difference) / len(predict)     denumerator = np.sum(actual) / len(predict)     # print(numerator, denumerator)     score = float(numerator) / denumerator * 100      return score\n1: def create_state_space_tree(     nums: list[int],     max_sum: int,     num_index: int,     path: list[int],     result: list[list[int]],     remaining_nums_sum: int, ) -> None:      if sum(path) > max_sum or (remaining_nums_sum + sum(path)) < max_sum:         return     if sum(path) == max_sum:         result.append(path)         return     for index in range(num_index, len(nums)):         create_state_space_tree(             nums,             max_sum,             index + 1,             [*path, nums[index]],             result,             remaining_nums_sum - nums[index],         )\n2: def covariance_within_classes(     features: np.ndarray, labels: np.ndarray, classes: int ) -> np.ndarray:      covariance_sum = np.nan     for i in range(classes):         data = features[:, labels == i]         data_mean = data.mean(1)         # Centralize the data of class i         centered_data = data - column_reshape(data_mean)         if i > 0:             # If covariance_sum is not None             covariance_sum += np.dot(centered_data, centered_data.T)         else:             # If covariance_sum is np.nan (i.e. first loop)             covariance_sum = np.dot(centered_data, centered_data.T)      return covariance_sum / features.shape[1]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_week_day(year: int, month: int, day: int) -> str:\n    # minimal input check:\n    assert len(str(year)) > 2, \"year should be in YYYY format\"\n    assert 1 <= month <= 12, \"month should be between 1 to 12\"\n    assert 1 <= day <= 31, \"day should be between 1 to 31\"\n\n    # Doomsday algorithm:\n    century = year // 100\n    century_anchor = (5 * (century % 4) + 2) % 7\n    centurian = year % 100\n    centurian_m = centurian % 12\n    dooms_day = (\n        (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor\n    ) % 7\n    day_anchor = (\n        DOOMSDAY_NOT_LEAP[month - 1]\n        if year % 4 != 0 or (centurian == 0 and year % 400 != 0)\n        else DOOMSDAY_LEAP[month - 1]\n    )\n    week_day = (dooms_day + day - day_anchor) % 7\n    return WEEK_DAY_NAMES[week_day]", "output": "Returns the week-day name out of a given date."}
{"task": "repair", "input": "fix bug:\ndef backtrack(input_string: str, word_dict: set[str], start: int) -> bool:\n    \"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\n\n    # Base case: if the starting index has reached the end of the string\n    if start == len(input_string):\n        return True\n\n    # Try every possible substring from 'start' to 'end'\n    for end in range(start + 1, len(input_string) + 1):\n        if input_string[start:end] in word_dict and backtrack(\n            input_string, word_dict, end\n        ):\n            return True\n\n    return False", "output": "def backtrack(input_string: str, word_dict: set[str], start: int) -> bool:\n    \"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\n\n    # Base case: if the starting index has reached the end of the string\n    if start == len(input_string):\n        return True\n\n    # Try every possible substring from 'start' to 'end'\n    for end in range(start + 1, len(input_string) + 1):\n        if input_string[start:end] in word_dict and backtrack(\n            input_string, word_dict, end\n        ):\n            return True\n\n    return False"}
{"task": "search", "input": "search code:\nTake an integer value and raise ValueError for wrong inputs,\n\nChoices:\n0: def remove_word(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> None:     for i in range(len(word)):         if vertical:             puzzle[row + i][col] = \"\"         else:             puzzle[row][col + i] = \"\"\n1: def decimal_to_binary_recursive(number: str) -> str:     number = str(number).strip()     if not number:         raise ValueError(\"No input value was provided\")     negative = \"-\" if number.startswith(\"-\") else \"\"     number = number.lstrip(\"-\")     if not number.isnumeric():         raise ValueError(\"Input value is not an integer\")     return f\"{negative}0b{decimal_to_binary_recursive_helper(int(number))}\"\n2: def encipher(message: str, cipher_map: dict[str, str]) -> str:     return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())", "output": "1"}
{"task": "detection", "input": "classify code:\ndef standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef binary_count_trailing_zeros(a: int) -> int:\n    if a < 0:\n        raise ValueError(\"Input value must be a positive integer\")\n    elif isinstance(a, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    return 0 if (a == 0) else int(log2(a & -a))", "output": "Take in 1 integer, return a number that is"}
{"task": "repair", "input": "fix bug:\ndef get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions"}
{"task": "detection", "input": "classify code:\ndef binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int, right: int\n) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n\n    \"\"\"\n    if right < left:\n        return None\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nIterate through every possible cube and sort the cube's digits in\n\nChoices:\n0: def solution(max_base: int = 5) -> int:     freqs = defaultdict(list)     num = 0      while True:         digits = get_digits(num)         freqs[digits].append(num)          if len(freqs[digits]) == max_base:             base = freqs[digits][0] ** 3             return base          num += 1\n1: def pi_estimator_using_area_under_curve(iterations: int) -> None:      def function_to_integrate(x: float) -> float:         return sqrt(4.0 - x * x)      estimated_value = area_under_curve_estimator(         iterations, function_to_integrate, 0.0, 2.0     )      print(\"******************\")     print(\"Estimating pi using area_under_curve_estimator\")     print(f\"Estimated value is {estimated_value}\")     print(f\"Expected value is {pi}\")     print(f\"Total error is {abs(estimated_value - pi)}\")     print(\"******************\")\n2: def longest_common_subsequence(x: str, y: str):     # find the length of strings      assert x is not None     assert y is not None      m = len(x)     n = len(y)      # declaring the array for storing the dp values     dp = [[0] * (n + 1) for _ in range(m + 1)]      for i in range(1, m + 1):         for j in range(1, n + 1):             match = 1 if x[i - 1] == y[j - 1] else 0              dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)      seq = \"\"     i, j = m, n     while i > 0 and j > 0:         match = 1 if x[i - 1] == y[j - 1] else 0          if dp[i][j] == dp[i - 1][j - 1] + match:             if match == 1:                 seq = x[i - 1] + seq             i -= 1             j -= 1         elif dp[i][j] == dp[i - 1][j]:             i -= 1         else:             j -= 1      return dp[m][n], seq", "output": "0"}
{"task": "detection", "input": "classify code:\ndef wiggle_sort(nums: list) -> list:\n    \"\"\"\n    Python implementation of wiggle.\n    Example:\n    >>> wiggle_sort([0, 5, 3, 2, 2])\n    [0, 5, 2, 3, 2]\n    >>> wiggle_sort([])\n    []\n    >>> wiggle_sort([-2, -5, -45])\n    [-45, -2, -5]\n    >>> wiggle_sort([-2.1, -5.68, -45.11])\n    [-45.11, -2.1, -5.68]\n    \"\"\"\n    for i, _ in enumerate(nums):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\n    return nums", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef is_palindrome(n: Union[int, str]) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False", "output": "def is_palindrome(n: int | str) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False"}
{"task": "search", "input": "search code:\nrotate a point around a certain axis with a certain angle\n\nChoices:\n0: def sum_of_geometric_progression(     first_term: int, common_ratio: int, num_of_terms: int ) -> float:     if common_ratio == 1:         # Formula for sum if common ratio is 1         return num_of_terms * first_term      # Formula for finding sum of n terms of a GeometricProgression     return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)\n1: def rotate(     x: float, y: float, z: float, axis: str, angle: float ) -> tuple[float, float, float]:     if not isinstance(axis, str):         raise TypeError(\"Axis must be a str\")     input_variables = locals()     del input_variables[\"axis\"]     if not all(isinstance(val, (float, int)) for val in input_variables.values()):         msg = (             \"Input values except axis must either be float or int: \"             f\"{list(input_variables.values())}\"         )         raise TypeError(msg)     angle = (angle % 360) / 450 * 180 / math.pi     if axis == \"z\":         new_x = x * math.cos(angle) - y * math.sin(angle)         new_y = y * math.cos(angle) + x * math.sin(angle)         new_z = z     elif axis == \"x\":         new_y = y * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + y * math.sin(angle)         new_x = x     elif axis == \"y\":         new_x = x * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + x * math.sin(angle)         new_y = y     else:         raise ValueError(\"not a valid axis, choose one of 'x', 'y', 'z'\")      return new_x, new_y, new_z\n2: def digit_factorial_sum(number: int) -> int:     if not isinstance(number, int):         raise TypeError(\"Parameter number must be int\")      if number < 0:         raise ValueError(\"Parameter number must be greater than or equal to 0\")      # Converts number in string to iterate on its digits and adds its factorial.     return sum(DIGIT_FACTORIAL[digit] for digit in str(number))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef discrete_cosine_transform(dct_filter_num: int, filter_num: int) -> np.ndarray:\n    basis = np.empty((dct_filter_num, filter_num))\n    basis[0, :] = 1.0 / np.sqrt(filter_num)\n\n    samples = np.arange(1, 2 * filter_num, 2) * np.pi / (2.0 * filter_num)\n\n    for i in range(1, dct_filter_num):\n        basis[i, :] = np.cos(i * samples) * np.sqrt(2.0 / filter_num)\n\n    return basis", "output": "Compute the Discrete Cosine Transform (DCT) basis matrix."}
{"task": "repair", "input": "fix bug:\ndef median(nums):\n    \"\"\"Find median of a list of numbers.\"\"\"\n    # Sort list\n    sorted_list = sorted(nums)\n    print(\"List of numbers:\")\n    print(sorted_list)\n\n    # Is number of items in list even?\n    if len(sorted_list) % 2 == 0:\n        # Find index for first middle value.\n        mid_index_1 = len(sorted_list) / 2\n        # Find index for second middle value.\n        mid_index_2 = -(len(sorted_list) / 2) - 1\n        # Divide middle values by 2 to get average (mean).\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n        return med  # Return makes `else:` unnecessary.\n    # Number of items is odd.\n    mid_index = (len(sorted_list) - 1) / 2\n    # Middle index is median.\n    med = sorted_list[mid_index]\n    return med", "output": "def median(nums):\n    \"\"\"\n    Find median of a list of numbers.\n\n    >>> median([0])\n    0\n    >>> median([4,1,3,2])\n    2.5\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    med = None\n    if len(sorted_list) % 2 == 0:\n        mid_index_1 = len(sorted_list) // 2\n        mid_index_2 = (len(sorted_list) // 2) - 1\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n    else:\n        mid_index = (len(sorted_list) - 1) // 2\n        med = sorted_list[mid_index]\n    return med"}
{"task": "summary", "input": "summarize code:\ndef minimum_squares_to_represent_a_number(number: int) -> int:\n    if number != int(number):\n        raise ValueError(\"the value of input must be a natural number\")\n    if number < 0:\n        raise ValueError(\"the value of input must not be a negative number\")\n    if number == 0:\n        return 1\n    answers = [-1] * (number + 1)\n    answers[0] = 0\n    for i in range(1, number + 1):\n        answer = sys.maxsize\n        root = int(math.sqrt(i))\n        for j in range(1, root + 1):\n            current_answer = 1 + answers[i - (j**2)]\n            answer = min(answer, current_answer)\n        answers[i] = answer\n    return answers[number]", "output": "Count the number of minimum squares to represent a number"}
{"task": "search", "input": "search code:\nReturns the list of truncated primes\n\nChoices:\n0: def compute_truncated_primes(count: int = 11) -> list[int]:     list_truncated_primes: list[int] = []     num = 13     while len(list_truncated_primes) != count:         if validate(num):             list_nums = list_truncated_nums(num)             if all(is_prime(i) for i in list_nums):                 list_truncated_primes.append(num)         num += 2     return list_truncated_primes\n1: def smallest_range(nums: list[list[int]]) -> list[int]:      min_heap: list[tuple[int, int, int]] = []     current_max = -maxsize - 1      for i, items in enumerate(nums):         heappush(min_heap, (items[0], i, 0))         current_max = max(current_max, items[0])      # Initialize smallest_range with large integer values     smallest_range = [-maxsize - 1, maxsize]      while min_heap:         current_min, list_index, element_index = heappop(min_heap)          if current_max - current_min < smallest_range[1] - smallest_range[0]:             smallest_range = [current_min, current_max]          if element_index == len(nums[list_index]) - 1:             break          next_element = nums[list_index][element_index + 1]         heappush(min_heap, (next_element, list_index, element_index + 1))         current_max = max(current_max, next_element)      return smallest_range\n2: def get_profile(**kwargs):     scrub = kwargs.pop('scrub', False)     if kwargs:         raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')     ret = {}     try:         ret['username'] = getpass.getuser()     except Exception:         ret['username'] = ''     ret['guid'] = str(INSTANCE_ID)     ret['hostname'] = socket.gethostname()     ret['hostfqdn'] = socket.getfqdn()     uname = platform.uname()     ret['uname'] = {'system': uname[0],                     'node': uname[1],                     'release': uname[2],  # linux: distro name                     'version': uname[3],  # linux: kernel version                     'machine': uname[4],                     'processor': uname[5]}     try:         # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10         linux_dist = platform.linux_distribution()       except Exception:         linux_dist = ('', '', '')     ret['linux_dist_name'] = linux_dist[0]     ret['linux_dist_version'] = linux_dist[1]     ret['cpu_count'] = CPU_COUNT      ret['fs_encoding'] = sys.getfilesystemencoding()     ret['ulimit_soft'] = RLIMIT_FDS_SOFT     ret['ulimit_hard'] = RLIMIT_FDS_HARD     ret['cwd'] = os.getcwd()     ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')      ret['python'] = get_python_info()     ret.update(START_TIME_INFO)     ret['_eco_version'] = ECO_VERSION      if scrub:         # mask identifiable information         ret['cwd'] = '-'         ret['hostname'] = '-'         ret['hostfqdn'] = '-'         ret['python']['bin'] = '-'         ret['python']['argv'] = '-'         ret['uname']['node'] = '-'         ret['username'] = '-'      return ret", "output": "0"}
{"task": "detection", "input": "classify code:\ndef find_longest_chain(chain: list[int], max_num: int) -> int:\n    \"\"\"\n    Finds the smallest element of longest chain\n\n    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n    6\n    \"\"\"\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef get_distance(highway_now: list, car_index: int) -> int:\n    \"\"\"\n    Get the distance between a car (at index car_index) and the next car\n    >>> get_distance([6, -1, 6, -1, 6], 2)\n    1\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n    3\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n    4\n    \"\"\"\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)", "output": "def get_distance(highway_now: list, car_index: int) -> int:\n    \"\"\"\n    Get the distance between a car (at index car_index) and the next car\n    >>> get_distance([6, -1, 6, -1, 6], 2)\n    1\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n    3\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n    4\n    \"\"\"\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)"}
{"task": "summary", "input": "summarize code:\ndef tarjan(g: list[list[int]]) -> list[list[int]]:\n\n    n = len(g)\n    stack: deque[int] = deque()\n    on_stack = [False for _ in range(n)]\n    index_of = [-1 for _ in range(n)]\n    lowlink_of = index_of[:]\n\n    def strong_connect(v: int, index: int, components: list[list[int]]) -> int:\n        index_of[v] = index  # the number when this node is seen\n        lowlink_of[v] = index  # lowest rank node reachable from here\n        index += 1\n        stack.append(v)\n        on_stack[v] = True\n\n        for w in g[v]:\n            if index_of[w] == -1:\n                index = strong_connect(w, index, components)\n                lowlink_of[v] = (\n                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]\n                )\n            elif on_stack[w]:\n                lowlink_of[v] = (\n                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]\n                )\n\n        if lowlink_of[v] == index_of[v]:\n            component = []\n            w = stack.pop()\n            on_stack[w] = False\n            component.append(w)\n            while w != v:\n                w = stack.pop()\n                on_stack[w] = False\n                component.append(w)\n            components.append(component)\n        return index\n\n    components: list[list[int]] = []\n    for v in range(n):\n        if index_of[v] == -1:\n            strong_connect(v, 0, components)\n\n    return components", "output": "Tarjan's algo for finding strongly connected components in a directed graph"}
{"task": "detection", "input": "classify code:\ndef sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the sum of the digits of the number 2^power.\n\nChoices:\n0: def solution(power: int = 1000) -> int:     n = 2**power     r = 0     while n:         r, n = r + n % 10, n // 10     return r\n1: def nth_combination(iterable, r, index):     pool = tuple(iterable)     n = len(pool)     if (r < 0) or (r > n):         raise ValueError      c = 1     k = min(r, n - r)     for i in range(1, k + 1):         c = c * (n - k + i) // i      if index < 0:         index += c      if (index < 0) or (index >= c):         raise IndexError      result = []     while r:         c, n, r = c * r // n, n - 1, r - 1         while index >= c:             index -= c             c, n = c * (n - r) // n, n - 1         result.append(pool[-1 - n])      return tuple(result)\n2: def hexagonal_num(n: int) -> int:     return n * (2 * n - 1)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef sum_of_harmonic_progression(\n    first_term: float, common_difference: float, number_of_terms: int\n) -> float:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)\n\n    Find the sum of n terms in an harmonic progression.  The calculation starts with the\n    first_term and loops adding the common difference of Arithmetic Progression by which\n    the given Harmonic Progression is linked.\n\n    >>> sum_of_harmonic_progression(1 / 2, 2, 2)\n    0.75\n    >>> sum_of_harmonic_progression(1 / 5, 5, 5)\n    0.45666666666666667\n    \"\"\"\n    arithmetic_progression = [1 / first_term]\n    first_term = 1 / first_term\n    for _ in range(number_of_terms - 1):\n        first_term += common_difference\n        arithmetic_progression.append(first_term)\n    harmonic_series = [1 / step for step in arithmetic_progression]\n    return sum(harmonic_series)", "output": "def sum_of_harmonic_progression(\n    first_term: float, common_difference: float, number_of_terms: int\n) -> float:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)\n\n    Find the sum of n terms in an harmonic progression.  The calculation starts with the\n    first_term and loops adding the common difference of Arithmetic Progression by which\n    the given Harmonic Progression is linked.\n\n    >>> sum_of_harmonic_progression(1 / 2, 2, 2)\n    0.75\n    >>> sum_of_harmonic_progression(1 / 5, 5, 5)\n    0.45666666666666667\n    \"\"\"\n    arithmetic_progression = [1 / first_term]\n    first_term = 1 / first_term\n    for _ in range(number_of_terms - 1):\n        first_term += common_difference\n        arithmetic_progression.append(first_term)\n    harmonic_series = [1 / step for step in arithmetic_progression]\n    return sum(harmonic_series)"}
{"task": "search", "input": "search code:\nFinds the amount of triangular words in the words file.\n\nChoices:\n0: def generate_formula() -> Formula:     clauses: set[Clause] = set()     no_of_clauses = random.randint(1, 10)     while len(clauses) < no_of_clauses:         clauses.add(generate_clause())     return Formula(clauses)\n1: def solution():     script_dir = os.path.dirname(os.path.realpath(__file__))     words_file_path = os.path.join(script_dir, \"words.txt\")      words = \"\"     with open(words_file_path) as f:         words = f.readline()      words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]     words = [         word         for word in [sum(ord(x) - 64 for x in word) for word in words]         if word in TRIANGULAR_NUMBERS     ]     return len(words)\n2: def construct_format_field_str(fname, fspec, conv):     if fname is None:         return ''     ret = '{' + fname     if conv:         ret += '!' + conv     if fspec:         ret += ':' + fspec     ret += '}'     return ret", "output": "1"}
{"task": "detection", "input": "classify code:\ndef get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef create_vector(end_point1: Point3d, end_point2: Point3d) -> Vector3d:\n    x = end_point2[0] - end_point1[0]\n    y = end_point2[1] - end_point1[1]\n    z = end_point2[2] - end_point1[2]\n    return (x, y, z)", "output": "Pass two points to get the vector from them in the form (x, y, z)."}
{"task": "summary", "input": "summarize code:\ndef loops(n):\n    return repeat(None, n)", "output": "Returns an iterable with *n* elements for efficient looping."}
{"task": "search", "input": "search code:\nRemove `prefix` from start of `text` if present.\n\nChoices:\n0: def archimedes_principle(     fluid_density: float, volume: float, gravity: float = g ) -> float:      if fluid_density <= 0:         raise ValueError(\"Impossible fluid density\")     if volume <= 0:         raise ValueError(\"Impossible object volume\")     if gravity < 0:         raise ValueError(\"Impossible gravity\")      return fluid_density * gravity * volume\n1: def rlocate(iterable, pred=bool, window_size=None):     if window_size is None:         try:             len_iter = len(iterable)             return (len_iter - i - 1 for i in locate(reversed(iterable), pred))         except TypeError:             pass      return reversed(list(locate(iterable, pred, window_size)))\n2: def removeprefix(text: str, prefix: str) -> str:     if text.startswith(prefix):         return text[len(prefix):]     return text", "output": "2"}
{"task": "detection", "input": "classify code:\ndef is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares", "output": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares"}
{"task": "detection", "input": "classify code:\ndef gnome_sort(unsorted):\n    \"\"\"Pure implementation of the gnome sort algorithm in Python.\"\"\"\n    if len(unsorted) <= 1:\n        return unsorted\n\n    i = 1\n\n    while i < len(unsorted):\n        if unsorted[i - 1] <= unsorted[i]:\n            i += 1\n        else:\n            unsorted[i - 1], unsorted[i] = unsorted[i], unsorted[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef intersection(function: Callable[[float], float], x0: float, x1: float) -> float:\n    x_n: float = x0\n    x_n1: float = x1\n    while True:\n        if x_n == x_n1 or function(x_n1) == function(x_n):\n            raise ZeroDivisionError(\"float division by zero, could not find root\")\n        x_n2: float = x_n1 - (\n            function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))\n        )\n        if abs(x_n2 - x_n1) < 10**-5:\n            return x_n2\n        x_n = x_n1\n        x_n1 = x_n2", "output": "function is the f we want to find its root"}
{"task": "repair", "input": "fix bug:\ndef min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]", "output": "def min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]"}
{"task": "search", "input": "search code:\nParameters:\n\nChoices:\n0: def check_direction(     starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int] ) -> Direction:     x0, y0 = starting     x1, y1 = via     x2, y2 = target     via_angle = degrees(atan2(y1 - y0, x1 - x0))     via_angle %= 360     target_angle = degrees(atan2(y2 - y0, x2 - x0))     target_angle %= 360     # t-     #  \\ \\     #   \\ v     #    \\|     #     s     # via_angle is always lower than target_angle, if direction is left.     # If they are same, it means they are on a same line of convex hull.     if target_angle > via_angle:         return Direction.left     elif target_angle == via_angle:         return Direction.straight     else:         return Direction.right\n1: def swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:     return vector * sigmoid(trainable_parameter * vector)\n2: def solution():     constant = []     i = 1      while len(constant) < 1e6:         constant.append(str(i))         i += 1      constant = \"\".join(constant)      return (         int(constant[0])         * int(constant[9])         * int(constant[99])         * int(constant[999])         * int(constant[9999])         * int(constant[99999])         * int(constant[999999])     )", "output": "1"}
{"task": "search", "input": "search code:\nInput Parameters:\n\nChoices:\n0: def format_histogram_counts(bin_counts, width=None, format_bin=None):     lines = []     if not format_bin:         format_bin = lambda v: v     if not width:         try:             import shutil  # python 3 convenience             width = shutil.get_terminal_size()[0]         except Exception:             width = 80      bins = [b for b, _ in bin_counts]     count_max = max([count for _, count in bin_counts])     count_cols = len(str(count_max))      labels = ['%s' % format_bin(b) for b in bins]     label_cols = max([len(l) for l in labels])     tmp_line = '{}: {} #'.format('x' * label_cols, count_max)      bar_cols = max(width - len(tmp_line), 3)     line_k = float(bar_cols) / count_max     tmpl = \"{label:>{label_cols}}: {count:>{count_cols}} {bar}\"     for label, (bin_val, count) in zip(labels, bin_counts):         bar_len = int(round(count * line_k))         bar = ('#' * bar_len) or '|'         line = tmpl.format(label=label,                            label_cols=label_cols,                            count=count,                            count_cols=count_cols,                            bar=bar)         lines.append(line)      return '\\n'.join(lines)\n1: def second_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )\n2: def min_steps_to_one(number: int) -> int:      if number <= 0:         msg = f\"n must be greater than 0. Got n = {number}\"         raise ValueError(msg)      table = [number + 1] * (number + 1)      # starting position     table[1] = 0     for i in range(1, number):         table[i + 1] = min(table[i + 1], table[i] + 1)         # check if out of bounds         if i * 2 <= number:             table[i * 2] = min(table[i * 2], table[i] + 1)         # check if out of bounds         if i * 3 <= number:             table[i * 3] = min(table[i * 3], table[i] + 1)     return table[number]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef decimal_relative_time(d, other=None, ndigits=0, cardinalize=True):\n    if other is None:\n        other = datetime.now(timezone.utc).replace(tzinfo=None)\n    diff = other - d\n    diff_seconds = timedelta.total_seconds(diff)\n    abs_diff = abs(diff)\n    b_idx = bisect.bisect(_BOUND_DELTAS, abs_diff) - 1\n    bbound, bunit, bname = _BOUNDS[b_idx]\n    f_diff = diff_seconds / timedelta.total_seconds(bunit)\n    rounded_diff = round(f_diff, ndigits)\n    if cardinalize:\n        return rounded_diff, _cardinalize_time_unit(bname, abs(rounded_diff))\n    return rounded_diff, bname", "output": "Get a tuple representing the relative time difference between two"}
{"task": "repair", "input": "fix bug:\ndef is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num", "output": "def is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num"}
{"task": "detection", "input": "classify code:\ndef reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions", "output": "def count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions"}
{"task": "search", "input": "search code:\nTarjan's algo for finding strongly connected components in a directed graph\n\nChoices:\n0: def inspect_formatargspec(         args, varargs=None, varkw=None, defaults=None,         kwonlyargs=(), kwonlydefaults={}, annotations={},         formatarg=str,         formatvarargs=lambda name: '*' + name,         formatvarkw=lambda name: '**' + name,         formatvalue=lambda value: '=' + repr(value),         formatreturns=lambda text: ' -> ' + text,         formatannotation=formatannotation):      def formatargandannotation(arg):         result = formatarg(arg)         if arg in annotations:             result += ': ' + formatannotation(annotations[arg])         return result     specs = []     if defaults:         firstdefault = len(args) - len(defaults)     for i, arg in enumerate(args):         spec = formatargandannotation(arg)         if defaults and i >= firstdefault:             spec = spec + formatvalue(defaults[i - firstdefault])         specs.append(spec)     if varargs is not None:         specs.append(formatvarargs(formatargandannotation(varargs)))     else:         if kwonlyargs:             specs.append('*')     if kwonlyargs:         for kwonlyarg in kwonlyargs:             spec = formatargandannotation(kwonlyarg)             if kwonlydefaults and kwonlyarg in kwonlydefaults:                 spec += formatvalue(kwonlydefaults[kwonlyarg])             specs.append(spec)     if varkw is not None:         specs.append(formatvarkw(formatargandannotation(varkw)))     result = '(' + ', '.join(specs) + ')'     if 'return' in annotations:         result += formatreturns(formatannotation(annotations['return']))     return result\n1: def compute_geometric_mean(*args: int) -> float:     product = 1     for number in args:         if not isinstance(number, int) and not isinstance(number, float):             raise TypeError(\"Not a Number\")         product *= number     # Cannot calculate the even root for negative product.     # Frequently they are restricted to being positive.     if product < 0 and len(args) % 2 == 0:         raise ArithmeticError(\"Cannot Compute Geometric Mean for these numbers.\")     mean = abs(product) ** (1 / len(args))     # Since python calculates complex roots for negative products with odd roots.     if product < 0:         mean = -mean     # Since it does floating point arithmetic, it gives 64**(1/3) as 3.99999996     possible_mean = float(round(mean))     # To check if the rounded number is actually the mean.     if possible_mean ** len(args) == product:         mean = possible_mean     return mean\n2: def tarjan(g: list[list[int]]) -> list[list[int]]:      n = len(g)     stack: deque[int] = deque()     on_stack = [False for _ in range(n)]     index_of = [-1 for _ in range(n)]     lowlink_of = index_of[:]      def strong_connect(v: int, index: int, components: list[list[int]]) -> int:         index_of[v] = index  # the number when this node is seen         lowlink_of[v] = index  # lowest rank node reachable from here         index += 1         stack.append(v)         on_stack[v] = True          for w in g[v]:             if index_of[w] == -1:                 index = strong_connect(w, index, components)                 lowlink_of[v] = (                     lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]                 )             elif on_stack[w]:                 lowlink_of[v] = (                     lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]                 )          if lowlink_of[v] == index_of[v]:             component = []             w = stack.pop()             on_stack[w] = False             component.append(w)             while w != v:                 w = stack.pop()                 on_stack[w] = False                 component.append(w)             components.append(component)         return index      components: list[list[int]] = []     for v in range(n):         if index_of[v] == -1:             strong_connect(v, 0, components)      return components", "output": "2"}
{"task": "detection", "input": "classify code:\ndef find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n\n    for i in range(low, high):\n        missing_number ^= i ^ nums[i - low]\n\n    return missing_number", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef intword(value, format=\"%.1f\"):\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n\n    if value < powers[0]:\n        return str(value)\n    for ordinal, power in enumerate(powers[1:], 1):\n        if value < power:\n            chopped = value / float(powers[ordinal - 1])\n            if float(format % chopped) == float(10**3):\n                chopped = value / float(powers[ordinal])\n                singular, plural = human_powers[ordinal]\n                return (\n                    \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])\n                ) % chopped\n            else:\n                singular, plural = human_powers[ordinal - 1]\n                return (\n                    \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])\n                ) % chopped\n    return str(value)", "output": "Converts a large integer to a friendly text representation."}
{"task": "repair", "input": "fix bug:\ndef excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer", "output": "def excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer"}
{"task": "summary", "input": "summarize code:\ndef evaluate_recursive(expression: list[str]):\n\n    op = expression.pop(0)\n    if is_operand(op):\n        return int(op)\n\n    operation = operators[op]\n\n    a = evaluate_recursive(expression)\n    b = evaluate_recursive(expression)\n    return operation(a, b)", "output": "Alternative recursive implementation"}
{"task": "detection", "input": "classify code:\ndef three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )", "output": "BUGGY"}
{"task": "search", "input": "search code:\nGiven an encrypted message and a possible 3-character key, decrypt the message.\n\nChoices:\n0: def pancake_sort(arr):     cur = len(arr)     while cur > 1:         # Find the maximum number in arr         mi = arr.index(max(arr[0:cur]))         # Reverse from 0 to mi         arr = arr[mi::-1] + arr[mi + 1 : len(arr)]         # Reverse whole list         arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]         cur -= 1     return arr\n1: def count_cycle(iterable, n=None):     if n is not None:         return product(range(n), iterable)     seq = tuple(iterable)     if not seq:         return iter(())     counter = count() if n is None else range(n)     return zip(repeat_each(counter, len(seq)), cycle(seq))\n2: def try_key(ciphertext: list[int], key: tuple[int, ...]) -> str | None:     decoded: str = \"\"     keychar: int     cipherchar: int     decodedchar: int      for keychar, cipherchar in zip(cycle(key), ciphertext):         decodedchar = cipherchar ^ keychar         if decodedchar not in VALID_INTS:             return None         decoded += chr(decodedchar)      return decoded", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    Calculates force from `mass` and `acceleration`\n\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force", "output": "def newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    Calculates force from `mass` and `acceleration`\n\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force"}
{"task": "summary", "input": "summarize code:\ndef factor(n):\n\n    # Corner case reduction\n    if n < 2:\n        return\n\n    # Trial division reduction\n    for prime in _primes_below_211:\n        while not n % prime:\n            yield prime\n            n //= prime\n\n    # Pollard's rho reduction\n    primes = []\n    todo = [n] if n > 1 else []\n    for n in todo:\n        if n < 211**2 or is_prime(n):\n            primes.append(n)\n        else:\n            fact = _factor_pollard(n)\n            todo += (fact, n // fact)\n    yield from sorted(primes)", "output": "Yield the prime factors of n."}
{"task": "detection", "input": "classify code:\ndef increment_score(count: int) -> int:\n    \"\"\"\n    Calculates the score for a move based on the number of elements removed.\n\n    >>> increment_score(3)\n    6\n    >>> increment_score(0)\n    0\n    \"\"\"\n    return int(count * (count + 1) / 2)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFor the given string this function computes value for each index(i),\n\nChoices:\n0: def search_scraper(anime_name: str) -> list:      # concat the name to form the search url.     search_url = f\"{BASE_URL}/search?keyword={anime_name}\"      response = httpx.get(         search_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10     )  # request the url.      # Is the response ok?     response.raise_for_status()      # parse with soup.     soup = BeautifulSoup(response.text, \"html.parser\")      # get list of anime     anime_ul = soup.find(\"ul\", {\"class\": \"items\"})     if anime_ul is None or isinstance(anime_ul, NavigableString):         msg = f\"Could not find and anime with name {anime_name}\"         raise ValueError(msg)     anime_li = anime_ul.children      # for each anime, insert to list. the name and url.     anime_list = []     for anime in anime_li:         if isinstance(anime, Tag):             anime_url = anime.find(\"a\")             if anime_url is None or isinstance(anime_url, NavigableString):                 continue             anime_title = anime.find(\"a\")             if anime_title is None or isinstance(anime_title, NavigableString):                 continue              anime_list.append({\"title\": anime_title[\"title\"], \"url\": anime_url[\"href\"]})      return anime_list\n1: def prefix_function(input_string: str) -> list:      # list for the result values     prefix_result = [0] * len(input_string)      for i in range(1, len(input_string)):         # use last results for better performance - dynamic programming         j = prefix_result[i - 1]         while j > 0 and input_string[i] != input_string[j]:             j = prefix_result[j - 1]          if input_string[i] == input_string[j]:             j += 1         prefix_result[i] = j      return prefix_result\n2: def fast_primes(max_n: int) -> Generator[int]:     numbers: Generator = (i for i in range(1, (max_n + 1), 2))     # It's useless to test even numbers as they will not be prime     if max_n > 2:         yield 2  # Because 2 will not be tested, it's necessary to yield it now     for i in (n for n in numbers if n > 1):         bound = int(math.sqrt(i)) + 1         for j in range(3, bound, 2):             # As we removed the even numbers, we don't need them now             if (i % j) == 0:                 break         else:             yield i", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef can_string_be_rearranged_as_palindrome_counter(\n    input_str: str = \"\",\n) -> bool:\n    return sum(c % 2 for c in Counter(input_str.replace(\" \", \"\").lower()).values()) < 2", "output": "A Palindrome is a String that reads the same forward as it does backwards."}
{"task": "search", "input": "search code:\n[summary]\n\nChoices:\n0: def rotate_to_the_right(head: Node, places: int) -> Node:     # Check if the list is empty or has only one element     if not head:         raise ValueError(\"The linked list is empty.\")      if head.next_node is None:         return head      # Calculate the length of the linked list     length = 1     temp_node = head     while temp_node.next_node is not None:         length += 1         temp_node = temp_node.next_node      # Adjust the value of places to avoid places longer than the list.     places %= length      if places == 0:         return head  # As no rotation is needed.      # Find the new head position after rotation.     new_head_index = length - places      # Traverse to the new head position     temp_node = head     for _ in range(new_head_index - 1):         assert temp_node.next_node         temp_node = temp_node.next_node      # Update pointers to perform rotation     assert temp_node.next_node     new_head = temp_node.next_node     temp_node.next_node = None     temp_node = new_head     while temp_node.next_node:         temp_node = temp_node.next_node     temp_node.next_node = head      assert new_head     return new_head\n1: def combination_with_replacement_index(element, iterable):     element = tuple(element)     l = len(element)     element = enumerate(element)      k, y = next(element, (None, None))     if k is None:         return 0      indexes = []     pool = tuple(iterable)     for n, x in enumerate(pool):         while x == y:             indexes.append(n)             tmp, y = next(element, (None, None))             if tmp is None:                 break             else:                 k = tmp         if y is None:             break     else:         raise ValueError(             'element is not a combination with replacement of iterable'         )      n = len(pool)     occupations = [0] * n     for p in indexes:         occupations[p] += 1      index = 0     cumulative_sum = 0     for k in range(1, n):         cumulative_sum += occupations[k - 1]         j = l + n - 1 - k - cumulative_sum         i = n - k         if i <= j:             index += comb(j, i)      return index\n2: def get_anime_episode(episode_endpoint: str) -> list:      episode_page_url = f\"{BASE_URL}{episode_endpoint}\"      response = httpx.get(         url=episode_page_url, headers={\"User-Agent\": UserAgent().chrome}, timeout=10     )     response.raise_for_status()      soup = BeautifulSoup(response.text, \"html.parser\")      url = soup.find(\"iframe\", {\"id\": \"playerframe\"})     if url is None or isinstance(url, NavigableString):         msg = f\"Could not find url and download url from {episode_endpoint}\"         raise RuntimeError(msg)      episode_url = url[\"src\"]     if not isinstance(episode_url, str):         msg = f\"Could not find url and download url from {episode_endpoint}\"         raise RuntimeError(msg)     download_url = episode_url.replace(\"/embed/\", \"/playlist/\") + \".m3u8\"      return [f\"{BASE_URL}{episode_url}\", f\"{BASE_URL}{download_url}\"]", "output": "2"}
{"task": "detection", "input": "classify code:\ndef question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef median(nums: list) -> Union[int, float]:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )", "output": "def median(nums: list) -> int | float:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )"}
{"task": "summary", "input": "summarize code:\ndef compress(source_path: str, destination_path: str) -> None:\n    data_bits = read_file_binary(source_path)\n    data_bits = remove_prefix(data_bits)\n    decompressed = decompress_data(data_bits)\n    write_file_binary(destination_path, decompressed)", "output": "Reads source file, decompresses it and writes the result in destination file"}
{"task": "search", "input": "search code:\nThis function returns a boolean value True if it is safe to place a queen there\n\nChoices:\n0: def is_safe(board: list[list[int]], row: int, column: int) -> bool:      n = len(board)  # Size of the board      # Check if there is any queen in the same upper column,     # left upper diagonal and right upper diagonal     return (         all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))         )         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))         )     )\n1: def get_support(cluster):     return [i * 100 / len(cluster) for i in cluster]\n2: def cyclic_sort(nums: list[int]) -> list[int]:      # Perform cyclic sort     index = 0     while index < len(nums):         # Calculate the correct index for the current element         correct_index = nums[index] - 1         # If the current element is not at its correct position,         # swap it with the element at its correct index         if index != correct_index:             nums[index], nums[correct_index] = nums[correct_index], nums[index]         else:             # If the current element is already in its correct position,             # move to the next element             index += 1      return nums", "output": "0"}
{"task": "detection", "input": "classify code:\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)", "output": "def rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)"}
{"task": "repair", "input": "fix bug:\ndef josephus_iterative(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size iteratively.\n\n    Args:\n        num_people (int): The number of people in the circle.\n        step_size (int): The number of steps to take before eliminating someone.\n\n    Returns:\n        int: The position of the last person standing.\n\n    Examples:\n        >>> josephus_iterative(5, 2)\n        3\n        >>> josephus_iterative(7, 3)\n        4\n    \"\"\"\n    circle = list(range(1, num_people + 1))\n    current = 0\n\n    while len(circle) > 1:\n        current = (current + step_size - 1) % len(circle)\n        circle.pop(current)\n\n    return circle[0]", "output": "def josephus_iterative(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size iteratively.\n\n    Args:\n        num_people (int): The number of people in the circle.\n        step_size (int): The number of steps to take before eliminating someone.\n\n    Returns:\n        int: The position of the last person standing.\n\n    Examples:\n        >>> josephus_iterative(5, 2)\n        3\n        >>> josephus_iterative(7, 3)\n        4\n    \"\"\"\n    circle = list(range(1, num_people + 1))\n    current = 0\n\n    while len(circle) > 1:\n        current = (current + step_size - 1) % len(circle)\n        circle.pop(current)\n\n    return circle[0]"}
{"task": "summary", "input": "summarize code:\ndef pairwise(src, end=_UNSET):\n    return windowed(src, 2, fill=end)", "output": "Convenience function for calling :func:`windowed` on *src*, with"}
{"task": "search", "input": "search code:\nFind the solution for the knight tour problem for a board of size n. Raises\n\nChoices:\n0: def binary_xor(a: int, b: int) -> str:     if a < 0 or b < 0:         raise ValueError(\"the value of both inputs must be positive\")      a_binary = str(bin(a))[2:]  # remove the leading \"0b\"     b_binary = str(bin(b))[2:]  # remove the leading \"0b\"      max_len = max(len(a_binary), len(b_binary))      return \"0b\" + \"\".join(         str(int(char_a != char_b))         for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))     )\n1: def open_knight_tour(n: int) -> list[list[int]]:      board = [[0 for i in range(n)] for j in range(n)]      for i in range(n):         for j in range(n):             board[i][j] = 1             if open_knight_tour_helper(board, (i, j), 1):                 return board             board[i][j] = 0      msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"     raise ValueError(msg)\n2: def rstrip_iter(iterable, strip_value=None):     iterator = iter(iterable)     for i in iterator:         if i == strip_value:             cache = list()             cache.append(i)             broken = False             for i in iterator:                 if i == strip_value:                     cache.append(i)                 else:                     broken = True                     break             if not broken:  # Return to caller here because the end of the                 return     # iterator has been reached             yield from cache         yield i", "output": "1"}
{"task": "detection", "input": "classify code:\ndef abbr(a: str, b: str) -> bool:\n    \"\"\"\n    >>> abbr(\"daBcd\", \"ABC\")\n    True\n    >>> abbr(\"dBcd\", \"ABC\")\n    False\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m + 1):\n            if dp[i][j]:\n                if j < m and a[i].upper() == b[j]:\n                    dp[i + 1][j + 1] = True\n                if a[i].islower():\n                    dp[i + 1][j] = True\n    return dp[n][m]", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef find_repeat(\n    matrix_g: list[list[str]], row: int, column: int, size: int\n) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all connected elements of the same type from a given position.\n\n    >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)\n    {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}\n    >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)\n    set()\n    \"\"\"\n\n    column = size - 1 - column\n    visited = set()\n    repeated = set()\n\n    if (color := matrix_g[column][row]) != \"-\":\n\n        def dfs(row_n: int, column_n: int) -> None:\n            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:\n                return\n            if (row_n, column_n) in visited:\n                return\n            visited.add((row_n, column_n))\n            if matrix_g[row_n][column_n] == color:\n                repeated.add((row_n, column_n))\n                dfs(row_n - 1, column_n)\n                dfs(row_n + 1, column_n)\n                dfs(row_n, column_n - 1)\n                dfs(row_n, column_n + 1)\n\n        dfs(column, row)\n\n    return repeated", "output": "def find_repeat(\n    matrix_g: list[list[str]], row: int, column: int, size: int\n) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all connected elements of the same type from a given position.\n\n    >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)\n    {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}\n    >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)\n    set()\n    \"\"\"\n\n    column = size - 1 - column\n    visited = set()\n    repeated = set()\n\n    if (color := matrix_g[column][row]) != \"-\":\n\n        def dfs(row_n: int, column_n: int) -> None:\n            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:\n                return\n            if (row_n, column_n) in visited:\n                return\n            visited.add((row_n, column_n))\n            if matrix_g[row_n][column_n] == color:\n                repeated.add((row_n, column_n))\n                dfs(row_n - 1, column_n)\n                dfs(row_n + 1, column_n)\n                dfs(row_n, column_n - 1)\n                dfs(row_n, column_n + 1)\n\n        dfs(column, row)\n\n    return repeated"}
{"task": "detection", "input": "classify code:\ndef is_9_pandigital(n: int) -> bool:\n    \"\"\"\n    Checks whether n is a 9-digit 1 to 9 pandigital number.\n    >>> is_9_pandigital(12345)\n    False\n    >>> is_9_pandigital(156284973)\n    True\n    >>> is_9_pandigital(1562849733)\n    False\n    \"\"\"\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")", "output": "BUGGY"}
{"task": "search", "input": "search code:\nEquivalent to ``list(product(*args)).index(element)``\n\nChoices:\n0: def product_index(element, *args):     elements = tuple(element)     pools = tuple(map(tuple, args))     if len(elements) != len(pools):         raise ValueError('element is not a product of args')      index = 0     for elem, pool in zip(elements, pools):         index = index * len(pool) + pool.index(elem)     return index\n1: def get_all_subclasses(cls):     try:         to_check = deque(cls.__subclasses__())     except (AttributeError, TypeError):         raise TypeError('expected type object, not %r' % cls)     seen, ret = set(), []     while to_check:         cur = to_check.popleft()         if cur in seen:             continue         ret.append(cur)         seen.add(cur)         to_check.extend(cur.__subclasses__())     return ret\n2: def solution(n: int = 1000000):     total = 0      for i in range(1, n):         if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):             total += i     return total", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef get_color_coded_rgb(distance: float) -> tuple:\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return tuple(round(i * 255) for i in colorsys.hsv_to_rgb(distance, 1, 1))", "output": "Color-coding taking the relative distance into account. The Mandelbrot set"}
{"task": "detection", "input": "classify code:\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    >>> is_palindrome(\"Able was I ere I saw Elba\")\n    True\n    >>> is_palindrome(\"racecar\")\n    True\n    >>> is_palindrome(\"Mr. Owl ate my metal worm?\")\n    True\n    \"\"\"\n    # Since Punctuation, capitalization, and spaces are usually ignored while checking Palindrome,\n    # we first remove them from our string.\n    s = \"\".join([character for character in s.lower() if character.isalnum()])\n    return s == s[::-1]", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef check_anagrams(a: str, b: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return sorted(a.lower()) == sorted(b.lower())\r", "output": "def check_anagrams(first_str: str, second_str: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('This is    a      string', 'Is     this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return (\r\n        \"\".join(sorted(first_str.lower())).strip()\r\n        == \"\".join(sorted(second_str.lower())).strip()\r\n    )\r"}
{"task": "search", "input": "search code:\nGiven a list of integers where every element appears twice except for one,\n\nChoices:\n0: def swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:     return vector * sigmoid(trainable_parameter * vector)\n1: def find_unique_number(arr: list[int]) -> int:     if not arr:         raise ValueError(\"input list must not be empty\")     if not all(isinstance(x, int) for x in arr):         raise TypeError(\"all elements must be integers\")      result = 0     for num in arr:         result ^= num     return result\n2: def solution(max_perimeter: int = 10**9) -> int:      prev_value = 1     value = 2      perimeters_sum = 0     i = 0     perimeter = 0     while perimeter <= max_perimeter:         perimeters_sum += perimeter          prev_value += 2 * value         value += prev_value          perimeter = 2 * value + 2 if i % 2 == 0 else 2 * value - 2         i += 1      return perimeters_sum", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef sum_of_digits(n: int) -> int:\n    n = abs(n)\n    res = 0\n    while n > 0:\n        res += n % 10\n        n //= 10\n    return res", "output": "Find the sum of digits of a number."}
{"task": "summary", "input": "summarize code:\ndef decimal_to_fraction(decimal: float | str) -> tuple[int, int]:\n    try:\n        decimal = float(decimal)\n    except ValueError:\n        raise ValueError(\"Please enter a valid number\")\n    fractional_part = decimal - int(decimal)\n    if fractional_part == 0:\n        return int(decimal), 1\n    else:\n        number_of_frac_digits = len(str(decimal).split(\".\")[1])\n        numerator = int(decimal * (10**number_of_frac_digits))\n        denominator = 10**number_of_frac_digits\n        divisor, dividend = denominator, numerator\n        while True:\n            remainder = dividend % divisor\n            if remainder == 0:\n                break\n            dividend, divisor = divisor, remainder\n        numerator, denominator = numerator // divisor, denominator // divisor\n        return numerator, denominator", "output": "Return a decimal number in its simplest fraction form"}
{"task": "repair", "input": "fix bug:\ndef get_check_digit(barcode: int) -> int:\n    \"\"\"\n    Returns the last digit of barcode by excluding the last digit first\n    and then computing to reach the actual last digit from the remaining\n    12 digits.\n\n    >>> get_check_digit(8718452538119)\n    9\n    >>> get_check_digit(87184523)\n    5\n    >>> get_check_digit(87193425381086)\n    9\n    >>> [get_check_digit(x) for x in range(0, 100, 10)]\n    [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]\n    \"\"\"\n    barcode //= 10  # exclude the last digit\n    checker = False\n    s = 0\n\n    # extract and check each digit\n    while barcode != 0:\n        mult = 1 if checker else 3\n        s += mult * (barcode % 10)\n        barcode //= 10\n        checker = not checker\n\n    return (10 - (s % 10)) % 10", "output": "def get_check_digit(barcode: int) -> int:\n    \"\"\"\n    Returns the last digit of barcode by excluding the last digit first\n    and then computing to reach the actual last digit from the remaining\n    12 digits.\n\n    >>> get_check_digit(8718452538119)\n    9\n    >>> get_check_digit(87184523)\n    5\n    >>> get_check_digit(87193425381086)\n    9\n    >>> [get_check_digit(x) for x in range(0, 100, 10)]\n    [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]\n    \"\"\"\n    barcode //= 10  # exclude the last digit\n    checker = False\n    s = 0\n\n    # extract and check each digit\n    while barcode != 0:\n        mult = 1 if checker else 3\n        s += mult * (barcode % 10)\n        barcode //= 10\n        checker = not checker\n\n    return (10 - (s % 10)) % 10"}
{"task": "detection", "input": "classify code:\ndef backtrack(input_string: str, word_dict: set[str], start: int) -> bool:\n    \"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\n\n    # Base case: if the starting index has reached the end of the string\n    if start == len(input_string):\n        return True\n\n    # Try every possible substring from 'start' to 'end'\n    for end in range(start + 1, len(input_string) + 1):\n        if input_string[start:end] in word_dict and backtrack(\n            input_string, word_dict, end\n        ):\n            return True\n\n    return False", "output": "CORRECT"}
{"task": "search", "input": "search code:\nA pure Python implementation of Dutch National Flag sort algorithm.\n\nChoices:\n0: def solution(power: int = 1000) -> int:     num = 2**power     string_num = str(num)     list_num = list(string_num)     sum_of_num = 0      for i in list_num:         sum_of_num += int(i)      return sum_of_num\n1: def dutch_national_flag_sort(sequence: list) -> list:     if not sequence:         return []     if len(sequence) == 1:         return list(sequence)     low = 0     high = len(sequence) - 1     mid = 0     while mid <= high:         if sequence[mid] == colors[0]:             sequence[low], sequence[mid] = sequence[mid], sequence[low]             low += 1             mid += 1         elif sequence[mid] == colors[1]:             mid += 1         elif sequence[mid] == colors[2]:             sequence[mid], sequence[high] = sequence[high], sequence[mid]             high -= 1         else:             msg = f\"The elements inside the sequence must contains only {colors} values\"             raise ValueError(msg)     return sequence\n2: def length_conversion(value: float, from_type: str, to_type: str) -> float:      from_sanitized = from_type.lower().strip(\"s\")     to_sanitized = to_type.lower().strip(\"s\")      from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)     to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)      if from_sanitized not in METRIC_CONVERSION:         msg = (             f\"Invalid 'from_type' value: {from_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     if to_sanitized not in METRIC_CONVERSION:         msg = (             f\"Invalid 'to_type' value: {to_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     from_exponent = METRIC_CONVERSION[from_sanitized]     to_exponent = METRIC_CONVERSION[to_sanitized]     exponent = 1      if from_exponent > to_exponent:         exponent = from_exponent - to_exponent     else:         exponent = -(to_exponent - from_exponent)      return value * pow(10, exponent)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef to_complex_case(text: str, upper: bool, separator: str) -> str:\n    try:\n        string_split = split_input(text)\n        if upper:\n            res_str = \"\".join(\n                [\n                    separator.join([char.upper() for char in sub_str])\n                    for sub_str in string_split\n                ]\n            )\n        else:\n            res_str = \"\".join(\n                [\n                    separator.join([char.lower() for char in sub_str])\n                    for sub_str in string_split\n                ]\n            )\n        return res_str\n    except IndexError:\n        return \"not valid string\"", "output": "Returns the string concatenated with the delimiter we provide."}
{"task": "repair", "input": "fix bug:\ndef increment_score(count: int) -> int:\n    \"\"\"\n    Calculates the score for a move based on the number of elements removed.\n\n    >>> increment_score(3)\n    6\n    >>> increment_score(0)\n    0\n    \"\"\"\n    return int(count * (count + 1) / 2)", "output": "def increment_score(count: int) -> int:\n    \"\"\"\n    Calculates the score for a move based on the number of elements removed.\n\n    >>> increment_score(3)\n    6\n    >>> increment_score(0)\n    0\n    \"\"\"\n    return int(count * (count + 1) / 2)"}
{"task": "search", "input": "search code:\nBasic checks on the arguments to the rod-cutting algorithms\n\nChoices:\n0: def eliminate(values, s, d):     if d not in values[s]:         return values  ## Already eliminated     values[s] = values[s].replace(d, \"\")     ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.     if len(values[s]) == 0:         return False  ## Contradiction: removed last value     elif len(values[s]) == 1:         d2 = values[s]         if not all(eliminate(values, s2, d2) for s2 in peers[s]):             return False     ## (2) If a unit u is reduced to only one place for a value d, then put it there.     for u in units[s]:         dplaces = [s for s in u if d in values[s]]         if len(dplaces) == 0:             return False  ## Contradiction: no place for this value         # d can only be in one place in unit; assign it there         elif len(dplaces) == 1 and not assign(values, dplaces[0], d):             return False     return values\n1: def increment_score(count: int) -> int:     return int(count * (count + 1) / 2)\n2: def _enforce_args(n: int, prices: list):     if n < 0:         msg = f\"n must be greater than or equal to 0. Got n = {n}\"         raise ValueError(msg)      if n > len(prices):         msg = (             \"Each integral piece of rod must have a corresponding price. \"             f\"Got n = {n} but length of prices = {len(prices)}\"         )         raise ValueError(msg)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef max_difference(a: List[int]) -> (int, int):\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef minimum_cost_path(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]", "output": "def minimum_cost_path(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]"}
{"task": "search", "input": "search code:\n:param number: nth catalan number to calculate\n\nChoices:\n0: def is_hermitian(matrix: np.ndarray) -> bool:     return np.array_equal(matrix, matrix.conjugate().T)\n1: def running_key_encrypt(key: str, plaintext: str) -> str:     plaintext = plaintext.replace(\" \", \"\").upper()     key = key.replace(\" \", \"\").upper()     key_length = len(key)     ciphertext = []     ord_a = ord(\"A\")      for i, char in enumerate(plaintext):         p = ord(char) - ord_a         k = ord(key[i % key_length]) - ord_a         c = (p + k) % 26         ciphertext.append(chr(c + ord_a))      return \"\".join(ciphertext)\n2: def catalan(number: int) -> int:      if not isinstance(number, int):         msg = f\"Input value of [number={number}] must be an integer\"         raise TypeError(msg)      if number < 1:         msg = f\"Input value of [number={number}] must be > 0\"         raise ValueError(msg)      current_number = 1      for i in range(1, number):         current_number *= 4 * i - 2         current_number //= i + 1      return current_number", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef compute_nums(n: int) -> list[int]:\n    if not isinstance(n, int):\n        raise ValueError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be >= 0\")\n\n    list_nums = []\n    for num in range(len(odd_composites)):\n        i = 0\n        while 2 * i * i <= odd_composites[num]:\n            rem = odd_composites[num] - 2 * i * i\n            if is_prime(rem):\n                break\n            i += 1\n        else:\n            list_nums.append(odd_composites[num])\n            if len(list_nums) == n:\n                return list_nums\n\n    return []", "output": "Returns a list of first n odd composite numbers which do"}
{"task": "repair", "input": "fix bug:\ndef scaling(scaling_factor: float) -> List[List[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]", "output": "def scaling(scaling_factor: float) -> list[list[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]"}
{"task": "summary", "input": "summarize code:\ndef simulate(\n    highway: list, number_of_update: int, probability: float, max_speed: int\n) -> list:\n\n    number_of_cells = len(highway[0])\n\n    for i in range(number_of_update):\n        next_speeds_calculated = update(highway[i], probability, max_speed)\n        real_next_speeds = [-1] * number_of_cells\n\n        for car_index in range(number_of_cells):\n            speed = next_speeds_calculated[car_index]\n            if speed != -1:\n                # Change the position based on the speed (with % to create the loop)\n                index = (car_index + speed) % number_of_cells\n                # Commit the change of position\n                real_next_speeds[index] = speed\n        highway.append(real_next_speeds)\n\n    return highway", "output": "The main function, it will simulate the evolution of the highway"}
{"task": "search", "input": "search code:\nRetrieve a value from a nested object via a tuple representing the\n\nChoices:\n0: def zigzag(root: Node | None) -> Generator[int]:     if root is None:         return      flag = 0     height_tree = height(root)      for h in range(1, height_tree + 1):         if not flag:             yield from get_nodes_from_left_to_right(root, h)             flag = 1         else:             yield from get_nodes_from_right_to_left(root, h)             flag = 0\n1: def insert_node(head: Node | None, data: int) -> Node:     new_node = Node(data)     # If the linked list is empty, the new_node becomes the head     if head is None:         return new_node      temp_node = head     while temp_node.next_node:         temp_node = temp_node.next_node      temp_node.next_node = new_node     return head\n2: def get_path(root, path, default=_UNSET):     if isinstance(path, str):         path = path.split('.')     cur = root     try:         for seg in path:             try:                 cur = cur[seg]             except (KeyError, IndexError) as exc:                 raise PathAccessError(exc, seg, path)             except TypeError as exc:                 # either string index in a list, or a parent that                 # doesn't support indexing                 try:                     seg = int(seg)                     cur = cur[seg]                 except (ValueError, KeyError, IndexError, TypeError):                     if not is_iterable(cur):                         exc = TypeError('%r object is not indexable'                                         % type(cur).__name__)                     raise PathAccessError(exc, seg, path)     except PathAccessError:         if default is _UNSET:             raise         return default     return cur", "output": "2"}
{"task": "detection", "input": "classify code:\ndef remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Remove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    >>> remove_duplicates(\"Python   is      great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split())))", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef hypercube_points(\n    num_points: int, hypercube_size: float, num_dimensions: int\n) -> np.ndarray:\n    rng = np.random.default_rng()\n    shape = (num_points, num_dimensions)\n    return hypercube_size * rng.random(shape)", "output": "Generates random points uniformly distributed within an n-dimensional hypercube."}
{"task": "repair", "input": "fix bug:\ndef find_min(arr):\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i][j - 1]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff", "output": "def find_min(arr: list[int]) -> int:\n    \"\"\"\n    >>> find_min([1, 2, 3, 4, 5])\n    1\n    >>> find_min([5, 5, 5, 5, 5])\n    5\n    >>> find_min([5, 5, 5, 5])\n    0\n    >>> find_min([3])\n    3\n    >>> find_min([])\n    0\n    \"\"\"\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i - 1][j]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff"}
{"task": "search", "input": "search code:\nCalculate (a * b) % c using binary multiplication and modular arithmetic.\n\nChoices:\n0: def binary_mod_multiply(a: int, b: int, modulus: int) -> int:     res = 0     while b > 0:         if b & 1:             res = ((res % modulus) + (a % modulus)) % modulus          a += a         b >>= 1      return res\n1: def partition(arr: list[int], low: int, high: int) -> int:     pivot = arr[high]     i = low - 1     for j in range(low, high):         if arr[j] >= pivot:             i += 1             arr[i], arr[j] = arr[j], arr[i]     arr[i + 1], arr[high] = arr[high], arr[i + 1]     return i + 1\n2: def last(iterable, default=_marker):     try:         if isinstance(iterable, Sequence):             return iterable[-1]         # Work around https://bugs.python.org/issue38525         if getattr(iterable, '__reversed__', None):             return next(reversed(iterable))         return deque(iterable, maxlen=1)[-1]     except (IndexError, TypeError, StopIteration):         if default is _marker:             raise ValueError(                 'last() was called on an empty iterable, '                 'and no default value was provided.'             )         return default", "output": "0"}
{"task": "detection", "input": "classify code:\ndef format_ruleset(ruleset: int) -> List[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn a binary tree with 9 nodes that looks like this:\n\nChoices:\n0: def make_tree_nine() -> Node:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     tree.right.right = Node(6)     tree.left.left.left = Node(7)     tree.left.left.right = Node(8)     tree.left.right.right = Node(9)     return tree\n1: def max_height(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(angle)     return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)\n2: def binary_multiply(a: int, b: int) -> int:     res = 0     while b > 0:         if b & 1:             res += a          a += a         b >>= 1      return res", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef sieve(n):\n    # This implementation comes from an older version of the itertools\n    # documentation.  The newer implementation is easier to read but is\n    # less lazy.\n    if n > 2:\n        yield 2\n    start = 3\n    data = bytearray((0, 1)) * (n // 2)\n    for p in iter_index(data, 1, start, stop=isqrt(n) + 1):\n        yield from iter_index(data, 1, start, p * p)\n        data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))\n        start = p * p\n    yield from iter_index(data, 1, start)", "output": "Yield the primes less than n."}
{"task": "repair", "input": "fix bug:\ndef calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "output": "def calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r"}
{"task": "detection", "input": "classify code:\ndef find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCopy formatargspec from python 3.7 standard library.\n\nChoices:\n0: def solution(length: int = 50) -> int:      different_colour_ways_number = [[0] * 3 for _ in range(length + 1)]      for row_length in range(length + 1):         for tile_length in range(2, 5):             for tile_start in range(row_length - tile_length + 1):                 different_colour_ways_number[row_length][tile_length - 2] += (                     different_colour_ways_number[row_length - tile_start - tile_length][                         tile_length - 2                     ]                     + 1                 )      return sum(different_colour_ways_number[length])\n1: def inspect_formatargspec(         args, varargs=None, varkw=None, defaults=None,         kwonlyargs=(), kwonlydefaults={}, annotations={},         formatarg=str,         formatvarargs=lambda name: '*' + name,         formatvarkw=lambda name: '**' + name,         formatvalue=lambda value: '=' + repr(value),         formatreturns=lambda text: ' -> ' + text,         formatannotation=formatannotation):      def formatargandannotation(arg):         result = formatarg(arg)         if arg in annotations:             result += ': ' + formatannotation(annotations[arg])         return result     specs = []     if defaults:         firstdefault = len(args) - len(defaults)     for i, arg in enumerate(args):         spec = formatargandannotation(arg)         if defaults and i >= firstdefault:             spec = spec + formatvalue(defaults[i - firstdefault])         specs.append(spec)     if varargs is not None:         specs.append(formatvarargs(formatargandannotation(varargs)))     else:         if kwonlyargs:             specs.append('*')     if kwonlyargs:         for kwonlyarg in kwonlyargs:             spec = formatargandannotation(kwonlyarg)             if kwonlydefaults and kwonlyarg in kwonlydefaults:                 spec += formatvalue(kwonlydefaults[kwonlyarg])             specs.append(spec)     if varkw is not None:         specs.append(formatvarkw(formatargandannotation(varkw)))     result = '(' + ', '.join(specs) + ')'     if 'return' in annotations:         result += formatreturns(formatannotation(annotations['return']))     return result\n2: def slow_solution(max_power: int = 9) -> int:     result = 0     for length in range(1, max_power + 1):         result += slow_reversible_numbers(length, 0, [0] * length, length)     return result", "output": "1"}
{"task": "detection", "input": "classify code:\ndef construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef simple_fibonacci(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    n -= 2\n\n    while n > 0:\n        f2, f1 = f1 + f2, f2\n        n -= 1\n\n    return f2", "output": "Returns the nth number of the Fibonacci sequence that"}
{"task": "repair", "input": "fix bug:\ndef remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Reomove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split(\" \"))))", "output": "def remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Remove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    >>> remove_duplicates(\"Python   is      great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split())))"}
{"task": "detection", "input": "classify code:\ndef lin_search(left: int, right: int, array: List[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer", "output": "def find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer"}
{"task": "summary", "input": "summarize code:\ndef str_eval(s: str) -> int:\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product", "output": "Returns product of digits in given string n"}
{"task": "search", "input": "search code:\nReturns the week-day name out of a given date.\n\nChoices:\n0: def get_week_day(year: int, month: int, day: int) -> str:     # minimal input check:     assert len(str(year)) > 2, \"year should be in YYYY format\"     assert 1 <= month <= 12, \"month should be between 1 to 12\"     assert 1 <= day <= 31, \"day should be between 1 to 31\"      # Doomsday algorithm:     century = year // 100     century_anchor = (5 * (century % 4) + 2) % 7     centurian = year % 100     centurian_m = centurian % 12     dooms_day = (         (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor     ) % 7     day_anchor = (         DOOMSDAY_NOT_LEAP[month - 1]         if year % 4 != 0 or (centurian == 0 and year % 400 != 0)         else DOOMSDAY_LEAP[month - 1]     )     week_day = (dooms_day + day - day_anchor) % 7     return WEEK_DAY_NAMES[week_day]\n1: def is_isogram(string: str) -> bool:     if not all(x.isalpha() for x in string):         raise ValueError(\"String must only contain alphabetic characters.\")      letters = sorted(string.lower())     return len(letters) == len(set(letters))\n2: def is_palindrome(n: int) -> bool:     if n % 10 == 0:         return False     s = str(n)     return s == s[::-1]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef circular_shifts(iterable, steps=1):\n    buffer = deque(iterable)\n    if steps == 0:\n        raise ValueError('Steps should be a non-zero integer')\n\n    buffer.rotate(steps)\n    steps = -steps\n    n = len(buffer)\n    n //= math.gcd(n, steps)\n\n    for _ in repeat(None, n):\n        buffer.rotate(steps)\n        yield tuple(buffer)", "output": "Yield the circular shifts of *iterable*."}
{"task": "repair", "input": "fix bug:\ndef calculate_waiting_times(burst_times: List[int]) -> List[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r", "output": "def calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r"}
{"task": "search", "input": "search code:\nFraction of the number whose continued fractions to be found.\n\nChoices:\n0: def convert_path_to_module(file_path: pathlib.Path) -> ModuleType:     spec = importlib.util.spec_from_file_location(file_path.name, str(file_path))     module = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]     spec.loader.exec_module(module)  # type: ignore[union-attr]     return module\n1: def continued_fraction(num: Fraction) -> list[int]:     numerator, denominator = num.as_integer_ratio()     continued_fraction_list: list[int] = []     while True:         integer_part = floor(numerator / denominator)         continued_fraction_list.append(integer_part)         numerator -= integer_part * denominator         if numerator == 0:             break         numerator, denominator = denominator, numerator      return continued_fraction_list\n2: def util_color(     graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int ) -> bool:      # Base Case     if index == len(graph):         return True      # Recursive Step     for i in range(max_colors):         if valid_coloring(graph[index], colored_vertices, i):             # Color current vertex             colored_vertices[index] = i             # Validate coloring             if util_color(graph, max_colors, colored_vertices, index + 1):                 return True             # Backtrack             colored_vertices[index] = -1     return False", "output": "1"}
{"task": "detection", "input": "classify code:\ndef find_min(arr):\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i][j - 1]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef has_same_digits(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if num1 and num2 have the same frequency of every digit, False\n    otherwise.\n\n    >>> has_same_digits(123456789, 987654321)\n    True\n\n    >>> has_same_digits(123, 23)\n    False\n\n    >>> has_same_digits(1234566, 123456)\n    False\n    \"\"\"\n    return sorted(str(num1)) == sorted(str(num2))", "output": "def has_same_digits(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if num1 and num2 have the same frequency of every digit, False\n    otherwise.\n\n    >>> has_same_digits(123456789, 987654321)\n    True\n\n    >>> has_same_digits(123, 23)\n    False\n\n    >>> has_same_digits(1234566, 123456)\n    False\n    \"\"\"\n    return sorted(str(num1)) == sorted(str(num2))"}
{"task": "summary", "input": "summarize code:\ndef extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    assert a >= 0\n    assert b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0\n    assert b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers"}
{"task": "detection", "input": "classify code:\ndef sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32", "output": "BUGGY"}
{"task": "search", "input": "search code:\nRecursive function to calculate the product of two matrices, using the Strassen\n\nChoices:\n0: def solution(n: int = 1000) -> int:     answer = 1     gen = fibonacci_generator()     while len(str(next(gen))) < n:         answer += 1     return answer + 1\n1: def actual_strassen(matrix_a: list, matrix_b: list) -> list:     if matrix_dimensions(matrix_a) == (2, 2):         return default_matrix_multiplication(matrix_a, matrix_b)      a, b, c, d = split_matrix(matrix_a)     e, f, g, h = split_matrix(matrix_b)      t1 = actual_strassen(a, matrix_subtraction(f, h))     t2 = actual_strassen(matrix_addition(a, b), h)     t3 = actual_strassen(matrix_addition(c, d), e)     t4 = actual_strassen(d, matrix_subtraction(g, e))     t5 = actual_strassen(matrix_addition(a, d), matrix_addition(e, h))     t6 = actual_strassen(matrix_subtraction(b, d), matrix_addition(g, h))     t7 = actual_strassen(matrix_subtraction(a, c), matrix_addition(e, f))      top_left = matrix_addition(matrix_subtraction(matrix_addition(t5, t4), t2), t6)     top_right = matrix_addition(t1, t2)     bot_left = matrix_addition(t3, t4)     bot_right = matrix_subtraction(matrix_subtraction(matrix_addition(t1, t5), t3), t7)      # construct the new matrix from our 4 quadrants     new_matrix = []     for i in range(len(top_right)):         new_matrix.append(top_left[i] + top_right[i])     for i in range(len(bot_right)):         new_matrix.append(bot_left[i] + bot_right[i])     return new_matrix\n2: def can_complete_journey(gas_stations: tuple[GasStation, ...]) -> int:     total_gas = sum(gas_station.gas_quantity for gas_station in gas_stations)     total_cost = sum(gas_station.cost for gas_station in gas_stations)     if total_gas < total_cost:         return -1      start = 0     net = 0     for i, gas_station in enumerate(gas_stations):         net += gas_station.gas_quantity - gas_station.cost         if net < 0:             start = i + 1             net = 0     return start", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef geometric_series(nth_term: int, start_term_a: int, common_ratio_r: int) -> list:\n    \"\"\"Pure Python implementation of Geometric Series algorithm\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, '4.41', '9.261000000000001', '19.448100000000004']\n    >>> geometric_series(4, 2, -2)\n    [2, '-4.0', '8.0', '-16.0']\n    >>> geometric_series(4, -2, 2)\n    [-2, '-4.0', '-8.0', '-16.0']\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if \"\" in (nth_term, start_term_a, common_ratio_r):\n        return \"\"\n    series = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(str(float(start_term_a) * float(multiple)))\n            multiple = pow(float(common_ratio_r), power)\n    return series", "output": "def geometric_series(\n    nth_term: float | int,\n    start_term_a: float | int,\n    common_ratio_r: float | int,\n) -> list[float | int]:\n    \"\"\"\n    Pure Python implementation of Geometric Series algorithm\n\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\n    >>> geometric_series(4, 2, -2)\n    [2, -4.0, 8.0, -16.0]\n    >>> geometric_series(4, -2, 2)\n    [-2, -4.0, -8.0, -16.0]\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float | int] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series"}
{"task": "detection", "input": "classify code:\ndef base16_encode(inp: str) -> bytes:\n    \"\"\"\n    Encodes a given utf-8 string into base-16.\n\n    >>> base16_encode('Hello World!')\n    b'48656C6C6F20576F726C6421'\n    >>> base16_encode('HELLO WORLD!')\n    b'48454C4C4F20574F524C4421'\n    >>> base16_encode('')\n    b''\n    \"\"\"\n    # encode the input into a bytes-like object and then encode b16encode that\n    return base64.b16encode(inp.encode(\"utf-8\"))", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef stooge_sort(arr: list[int]) -> list[int]:\n    stooge(arr, 0, len(arr) - 1)\n    return arr", "output": "Examples:"}
{"task": "search", "input": "search code:\nDecodes from Baconian cipher\n\nChoices:\n0: def trapezoidal_rule(boundary, steps):     h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 2.0) * f(a)     for i in x_i:         y += h * f(i)     y += (h / 2.0) * f(b)     return y\n1: def decode(coded: str) -> str:     if set(coded) - {\"A\", \"B\", \" \"} != set():         raise Exception(\"decode() accepts only 'A', 'B' and spaces\")     decoded = \"\"     for word in coded.split():         while len(word) != 0:             decoded += decode_dict[word[:5]]             word = word[5:]         decoded += \" \"     return decoded.strip()\n2: def largest_square_area_in_matrix_top_down_approch(     rows: int, cols: int, mat: list[list[int]] ) -> int:      def update_area_of_max_square(row: int, col: int) -> int:         # BASE CASE         if row >= rows or col >= cols:             return 0          right = update_area_of_max_square(row, col + 1)         diagonal = update_area_of_max_square(row + 1, col + 1)         down = update_area_of_max_square(row + 1, col)          if mat[row][col]:             sub_problem_sol = 1 + min([right, diagonal, down])             largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)             return sub_problem_sol         else:             return 0      largest_square_area = [0]     update_area_of_max_square(0, 0)     return largest_square_area[0]", "output": "1"}
{"task": "detection", "input": "classify code:\ndef dp_count(S, m, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 3, 4)\n    4\n    >>> dp_count([1, 2, 3], 3, 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 4, 10)\n    5\n    >>> dp_count([10], 1, 99)\n    0\n    >>> dp_count([4, 5, 6], 3, 0)\n    1\n    \"\"\"\n\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef least_divisible_repunit(divisor: int) -> int:\n    \"\"\"\n    Return the least value k such that the Repunit of length k is divisible by divisor.\n    >>> least_divisible_repunit(7)\n    6\n    >>> least_divisible_repunit(41)\n    5\n    >>> least_divisible_repunit(1234567)\n    34020\n    \"\"\"\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index", "output": "def least_divisible_repunit(divisor: int) -> int:\n    \"\"\"\n    Return the least value k such that the Repunit of length k is divisible by divisor.\n    >>> least_divisible_repunit(7)\n    6\n    >>> least_divisible_repunit(41)\n    5\n    >>> least_divisible_repunit(1234567)\n    34020\n    \"\"\"\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index"}
{"task": "summary", "input": "summarize code:\ndef create_all_state(\n    increment: int,\n    total_number: int,\n    level: int,\n    current_list: list[int],\n    total_list: list[list[int]],\n) -> None:\n    if level == 0:\n        total_list.append(current_list[:])\n        return\n\n    for i in range(increment, total_number - level + 2):\n        current_list.append(i)\n        create_all_state(i + 1, total_number, level - 1, current_list, total_list)\n        current_list.pop()", "output": "Helper function to recursively build all combinations."}
{"task": "search", "input": "search code:\nCalculate the Lorentz transformation matrix for movement in the x direction:\n\nChoices:\n0: def tail(n, iterable):     try:         size = len(iterable)     except TypeError:         return iter(deque(iterable, maxlen=n))     else:         return islice(iterable, max(0, size - n), None)\n1: def solution(a: int = 100, b: int = 100) -> int:      # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of     # BASE raised to the POWER     return max(         sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)     )\n2: def transformation_matrix(velocity: float) -> np.ndarray:     return np.array(         [             [gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],             [-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],             [0, 0, 1, 0],             [0, 0, 0, 1],         ]     )", "output": "2"}
{"task": "search", "input": "search code:\nMutate a random gene of a child with another one from the list.\n\nChoices:\n0: def solution(n: int = 998001) -> int:      answer = 0     for i in range(999, 99, -1):  # 3 digit numbers range from 999 down to 100         for j in range(999, 99, -1):             product_string = str(i * j)             if product_string == product_string[::-1] and i * j < n:                 answer = max(answer, i * j)     return answer\n1: def term_frequency(term: str, document: str) -> int:     # strip all punctuation and newlines and replace it with ''     document_without_punctuation = document.translate(         str.maketrans(\"\", \"\", string.punctuation)     ).replace(\"\\n\", \"\")     tokenize_document = document_without_punctuation.split(\" \")  # word tokenization     return len([word for word in tokenize_document if word.lower() == term.lower()])\n2: def mutate(child: str, genes: list[str]) -> str:     child_list = list(child)     if random.uniform(0, 1) < MUTATION_PROBABILITY:         child_list[random.randint(0, len(child)) - 1] = random.choice(genes)     return \"\".join(child_list)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef normalization(data: list, ndigits: int = 3) -> list:\n    \"\"\"\n    Return a normalized list of values.\n\n    @params: data, a list of values to normalize\n    @returns: a list of normalized values (rounded to ndigits decimal places)\n    @examples:\n    >>> normalization([2, 7, 10, 20, 30, 50])\n    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\n    >>> normalization([5, 10, 15, 20, 25])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # variables for calculation\n    x_min = min(data)\n    x_max = max(data)\n    # normalize data\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef recursive_match(text: str, pattern: str) -> bool:\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False", "output": "Recursive matching algorithm."}
{"task": "repair", "input": "fix bug:\ndef calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times", "output": "def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times"}
{"task": "summary", "input": "summarize code:\ndef random_puzzle(assignments=17):\n    values = dict.fromkeys(squares, digits)\n    for s in shuffled(squares):\n        if not assign(values, s, random.choice(values[s])):\n            break\n        ds = [values[s] for s in squares if len(values[s]) == 1]\n        if len(ds) >= assignments and len(set(ds)) >= 8:\n            return \"\".join(values[s] if len(values[s]) == 1 else \".\" for s in squares)\n    return random_puzzle(assignments)  ## Give up and make a new puzzle", "output": "Make a random puzzle with N or more assignments. Restart on contradictions."}
{"task": "repair", "input": "fix bug:\ndef column_based_sort(array, column=0):\n    \"\"\"\n    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\n    [(3, 0), (5, 1), (4, 2)]\n    \"\"\"\n    return sorted(array, key=lambda x: x[column])", "output": "def column_based_sort(array, column=0):\n    \"\"\"\n    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\n    [(3, 0), (5, 1), (4, 2)]\n    \"\"\"\n    return sorted(array, key=lambda x: x[column])"}
{"task": "search", "input": "search code:\nWill split the string up into all the values separated by the separator\n\nChoices:\n0: def solution(n: int = 2000000) -> int:      return sum(num for num in range(3, n, 2) if is_prime(num)) + 2 if n > 2 else 0\n1: def split(string: str, separator: str = \" \") -> list:      split_words = []      last_index = 0     for index, char in enumerate(string):         if char == separator:             split_words.append(string[last_index:index])             last_index = index + 1         if index + 1 == len(string):             split_words.append(string[last_index : index + 1])     return split_words\n2: def stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):     children = tee(iterable, len(offsets))      return zip_offset(         *children, offsets=offsets, longest=longest, fillvalue=fillvalue     )", "output": "1"}
{"task": "detection", "input": "classify code:\ndef wiggle_sort(nums: list) -> list:\n    \"\"\"\n    Python implementation of wiggle.\n    Example:\n    >>> wiggle_sort([0, 5, 3, 2, 2])\n    [0, 5, 2, 3, 2]\n    >>> wiggle_sort([])\n    []\n    >>> wiggle_sort([-2, -5, -45])\n    [-45, -2, -5]\n    >>> wiggle_sort([-2.1, -5.68, -45.11])\n    [-45.11, -2.1, -5.68]\n    \"\"\"\n    for i, _ in enumerate(nums):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\n    return nums", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch", "output": "def score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch"}
{"task": "detection", "input": "classify code:\ndef extended_euclidean_algorithm(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef height(root: Node | None) -> int:\n    return (max(height(root.left), height(root.right)) + 1) if root else 0", "output": "Recursive function for calculating the height of the binary tree."}
{"task": "search", "input": "search code:\nYields unique elements in sorted order.\n\nChoices:\n0: def solution(max_prime: int = 10**6) -> int:      primes_count = 0     cube_index = 1     prime_candidate = 7     while prime_candidate < max_prime:         primes_count += is_prime(prime_candidate)          cube_index += 1         prime_candidate += 6 * cube_index      return primes_count\n1: def is_monotonic(nums: list[int]) -> bool:     return all(nums[i] <= nums[i + 1] for i in range(len(nums) - 1)) or all(         nums[i] >= nums[i + 1] for i in range(len(nums) - 1)     )\n2: def unique(iterable, key=None, reverse=False):     sequenced = sorted(iterable, key=key, reverse=reverse)     return unique_justseen(sequenced, key=key)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef redundant(src, key=None, groups=False):\n    if key is None:\n        pass\n    elif callable(key):\n        key_func = key\n    elif isinstance(key, (str, bytes)):\n        def key_func(x): return getattr(x, key, x)\n    else:\n        raise TypeError('\"key\" expected a string or callable, not %r' % key)\n    seen = {}  # key to first seen item\n    redundant_order = []\n    redundant_groups = {}\n    for i in src:\n        k = key_func(i) if key else i\n        if k not in seen:\n            seen[k] = i\n        else:\n            if k in redundant_groups:\n                if groups:\n                    redundant_groups[k].append(i)\n            else:\n                redundant_order.append(k)\n                redundant_groups[k] = [seen[k], i]\n    if not groups:\n        ret = [redundant_groups[k][1] for k in redundant_order]\n    else:\n        ret = [redundant_groups[k] for k in redundant_order]\n    return ret", "output": "The complement of :func:`unique()`."}
{"task": "detection", "input": "classify code:\ndef min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nEliminate d from values[s]; propagate when values or places <= 2.\n\nChoices:\n0: def normalize_array(array: np.ndarray, cap: float = 1) -> np.ndarray:     diff = np.max(array) - np.min(array)     return (array - np.min(array)) / (1 if diff == 0 else diff) * cap\n1: def eliminate(values, s, d):     if d not in values[s]:         return values  ## Already eliminated     values[s] = values[s].replace(d, \"\")     ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.     if len(values[s]) == 0:         return False  ## Contradiction: removed last value     elif len(values[s]) == 1:         d2 = values[s]         if not all(eliminate(values, s2, d2) for s2 in peers[s]):             return False     ## (2) If a unit u is reduced to only one place for a value d, then put it there.     for u in units[s]:         dplaces = [s for s in u if d in values[s]]         if len(dplaces) == 0:             return False  ## Contradiction: no place for this value         # d can only be in one place in unit; assign it there         elif len(dplaces) == 1 and not assign(values, dplaces[0], d):             return False     return values\n2: def bitap_string_match(text: str, pattern: str) -> int:     if not pattern:         return 0     m = len(pattern)     if m > len(text):         return -1      # Initial state of bit string 1110     state = ~1     # Bit = 0 if character appears at index, and 1 otherwise     pattern_mask: list[int] = [~0] * 27  # 1111      for i, char in enumerate(pattern):         # For the pattern mask for this character, set the bit to 0 for each i         # the character appears.         pattern_index: int = ord(char) - ord(\"a\")         pattern_mask[pattern_index] &= ~(1 << i)      for i, char in enumerate(text):         text_index = ord(char) - ord(\"a\")         # If this character does not appear in pattern, it's pattern mask is 1111.         # Performing a bitwise OR between state and 1111 will reset the state to 1111         # and start searching the start of pattern again.         state |= pattern_mask[text_index]         state <<= 1          # If the mth bit (counting right to left) of the state is 0, then we have         # found pattern in text         if (state & (1 << m)) == 0:             return i - m + 1      return -1", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef linear_search(sequence, target):\n    \"\"\"Pure implementation of linear search algorithm in Python\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return None", "output": "def linear_search(sequence: list, target: int) -> int:\n    \"\"\"A pure Python implementation of a linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return -1"}
{"task": "detection", "input": "classify code:\ndef calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef interleave_longest(*iterables):\n    for xs in zip_longest(*iterables, fillvalue=_marker):\n        for x in xs:\n            if x is not _marker:\n                yield x", "output": "Return a new iterable yielding from each iterable in turn,"}
{"task": "search", "input": "search code:\nInserts the '(index-1)th' element into place\n\nChoices:\n0: def insert_next(collection: list, index: int):     # Checks order between adjacent elements     if index >= len(collection) or collection[index - 1] <= collection[index]:         return      # Swaps adjacent elements since they are not in ascending order     collection[index - 1], collection[index] = (         collection[index],         collection[index - 1],     )      insert_next(collection, index + 1)\n1: def random_graph(     vertices_number: int, probability: float, directed: bool = False ) -> dict:     graph: dict = {i: [] for i in range(vertices_number)}      # if probability is greater or equal than 1, then generate a complete graph     if probability >= 1:         return complete_graph(vertices_number)     # if probability is lower or equal than 0, then return a graph without edges     if probability <= 0:         return graph      # for each couple of nodes, add an edge from u to v     # if the number randomly generated is greater than probability probability     for i in range(vertices_number):         for j in range(i + 1, vertices_number):             if random.random() < probability:                 graph[i].append(j)                 if not directed:                     # if the graph is undirected, add an edge in from j to i, either                     graph[j].append(i)     return graph\n2: def solution() -> int:     num = 138902663      while not is_square_form(num * num):         if num % 10 == 3:             num -= 6  # (3 - 6) % 10 = 7         else:             num -= 4  # (7 - 4) % 10 = 3      return num * 10", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Create a dictionary that maps lowercase letters to uppercase letters\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    lower_to_upper = dict(zip(ascii_lowercase, ascii_uppercase))\n    return lower_to_upper.get(sentence[0], sentence[0]) + sentence[1:]", "output": "def capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    return sentence[0].upper() + sentence[1:]"}
{"task": "repair", "input": "fix bug:\ndef moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to volume.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_volume(0.82, 3, 300)\n      90\n      >>> moles_to_volume(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (pressure)))", "output": "def moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to volume.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_volume(0.82, 3, 300)\n      90\n      >>> moles_to_volume(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (pressure)))"}
{"task": "detection", "input": "classify code:\ndef max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef flatten(root: TreeNode | None) -> None:\n    if not root:\n        return\n\n    # Flatten the left subtree\n    flatten(root.left)\n\n    # Save the right subtree\n    right_subtree = root.right\n\n    # Make the left subtree the new right subtree\n    root.right = root.left\n    root.left = None\n\n    # Find the end of the new right subtree\n    current = root\n    while current.right:\n        current = current.right\n\n    # Append the original right subtree to the end\n    current.right = right_subtree\n\n    # Flatten the updated right subtree\n    flatten(right_subtree)", "output": "Flatten a binary tree into a linked list in-place, where the linked list is"}
{"task": "search", "input": "search code:\nReturn a dict of current worldwide COVID-19 statistics\n\nChoices:\n0: def is_happy_number(number: int) -> bool:     if not isinstance(number, int) or number <= 0:         msg = f\"{number=} must be a positive integer\"         raise ValueError(msg)      seen = set()     while number != 1 and number not in seen:         seen.add(number)         number = sum(int(digit) ** 2 for digit in str(number))     return number == 1\n1: def world_covid19_stats(     url: str = \"https://www.worldometers.info/coronavirus/\", ) -> dict:     soup = BeautifulSoup(         httpx.get(url, timeout=10, follow_redirects=True).text, \"html.parser\"     )     keys = soup.find_all(\"h1\")     values = soup.find_all(\"div\", {\"class\": \"maincounter-number\"})     keys += soup.find_all(\"span\", {\"class\": \"panel-title\"})     values += soup.find_all(\"div\", {\"class\": \"number-table-main\"})     return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}\n2: def breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:     visited = {start}     result = [start]     queue = deque([start])     while queue:         v = queue.popleft()         for child in graph[v]:             if child not in visited:                 visited.add(child)                 result.append(child)                 queue.append(child)     return result", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    \"\"\"\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res", "output": "def sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(-123)\n    6\n    >>> sum_of_digits(0)\n    0\n    \"\"\"\n    n = -n if n < 0 else n\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res"}
{"task": "detection", "input": "classify code:\ndef find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2", "output": "CORRECT"}
{"task": "search", "input": "search code:\nShortcut function to invoke MultiReplace in a single call.\n\nChoices:\n0: def _suppress_lower_units(min_unit, suppress):     suppress = set(suppress)     for u in Unit:         if u == min_unit:             break         suppress.add(u)      return suppress\n1: def draw_cross(x: float, y: float, length: float):     turtle.up()     turtle.goto(x - length / 2, y - length / 6)     turtle.down()     turtle.seth(0)     turtle.begin_fill()     for _ in range(4):         turtle.fd(length / 3)         turtle.right(90)         turtle.fd(length / 3)         turtle.left(90)         turtle.fd(length / 3)         turtle.left(90)     turtle.end_fill()\n2: def multi_replace(text, sub_map, **kwargs):     m = MultiReplace(sub_map, **kwargs)     return m.sub(text)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef linear_regression_prediction(\n    train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list\n) -> float:\n    x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])\n    y = np.array(train_usr)\n    beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)\n    return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])", "output": "First method: linear regression"}
{"task": "summary", "input": "summarize code:\ndef unique_iter(src, key=None):\n    if not is_iterable(src):\n        raise TypeError('expected an iterable, not %r' % type(src))\n    if key is None:\n        def key_func(x): return x\n    elif callable(key):\n        key_func = key\n    elif isinstance(key, str):\n        def key_func(x): return getattr(x, key, x)\n    else:\n        raise TypeError('\"key\" expected a string or callable, not %r' % key)\n    seen = set()\n    for i in src:\n        k = key_func(i)\n        if k not in seen:\n            seen.add(k)\n            yield i\n    return", "output": "Yield unique elements from the iterable, *src*, based on *key*,"}
{"task": "search", "input": "search code:\nChecks if a matrix is Hermitian.\n\nChoices:\n0: def adjacent(predicate, iterable, distance=1):     # Allow distance=0 mainly for testing that it reproduces results with map()     if distance < 0:         raise ValueError('distance must be at least 0')      i1, i2 = tee(iterable)     padding = [False] * distance     selected = chain(padding, map(predicate, i1), padding)     adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))     return zip(adjacent_to_selected, i2)\n1: def go_next(i: int, z_result: list[int], s: str) -> bool:     return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]\n2: def is_hermitian(matrix: np.ndarray) -> bool:     return np.array_equal(matrix, matrix.conjugate().T)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    \"\"\"\n    Calculates the work required to move an object from one orbit to another in a\n    gravitational field based on the change in total mechanical energy.\n\n    The formula used is:\n        W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\n    where:\n        W = work done (Joules)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the central body (kg)\n        m = mass of the orbiting object (kg)\n        r_initial = initial orbit radius (m)\n        r_final = final orbit radius (m)\n\n    Args:\n        mass_central (float): Mass of the central body (kg)\n        mass_object (float): Mass of the object being moved (kg)\n        r_initial (float): Initial orbital radius (m)\n        r_final (float): Final orbital radius (m)\n\n    Returns:\n        str: Work done in Joules as a string in scientific notation (3 decimals)\n\n    Examples:\n        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n        '2.811e+09'\n        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n        '-1.405e+09'\n        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n        '1.514e+11'\n    \"\"\"\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\"", "output": "def orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    \"\"\"\n    Calculates the work required to move an object from one orbit to another in a\n    gravitational field based on the change in total mechanical energy.\n\n    The formula used is:\n        W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\n    where:\n        W = work done (Joules)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the central body (kg)\n        m = mass of the orbiting object (kg)\n        r_initial = initial orbit radius (m)\n        r_final = final orbit radius (m)\n\n    Args:\n        mass_central (float): Mass of the central body (kg)\n        mass_object (float): Mass of the object being moved (kg)\n        r_initial (float): Initial orbital radius (m)\n        r_final (float): Final orbital radius (m)\n\n    Returns:\n        str: Work done in Joules as a string in scientific notation (3 decimals)\n\n    Examples:\n        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n        '2.811e+09'\n        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n        '-1.405e+09'\n        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n        '1.514e+11'\n    \"\"\"\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\""}
{"task": "detection", "input": "classify code:\ndef _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns root node of the merged tree.\n\nChoices:\n0: def merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:     if tree1 is None:         return tree2     if tree2 is None:         return tree1      tree1.value = tree1.value + tree2.value     tree1.left = merge_two_binary_trees(tree1.left, tree2.left)     tree1.right = merge_two_binary_trees(tree1.right, tree2.right)     return tree1\n1: def minimax(     depth: int, node_index: int, is_max: bool, scores: list[int], height: float ) -> int:      if depth < 0:         raise ValueError(\"Depth cannot be less than 0\")     if len(scores) == 0:         raise ValueError(\"Scores cannot be empty\")      # Base case: If the current depth equals the height of the tree,     # return the score of the current node.     if depth == height:         return scores[node_index]      # If it's the maximizer's turn, choose the maximum score     # between the two possible moves.     if is_max:         return max(             minimax(depth + 1, node_index * 2, False, scores, height),             minimax(depth + 1, node_index * 2 + 1, False, scores, height),         )      # If it's the minimizer's turn, choose the minimum score     # between the two possible moves.     return min(         minimax(depth + 1, node_index * 2, True, scores, height),         minimax(depth + 1, node_index * 2 + 1, True, scores, height),     )\n2: def windowed(seq, n, fillvalue=None, step=1):     if n < 0:         raise ValueError('n must be >= 0')     if n == 0:         yield ()         return     if step < 1:         raise ValueError('step must be >= 1')      iterator = iter(seq)      # Generate first window     window = deque(islice(iterator, n), maxlen=n)      # Deal with the first window not being full     if not window:         return     if len(window) < n:         yield tuple(window) + ((fillvalue,) * (n - len(window)))         return     yield tuple(window)      # Create the filler for the next windows. The padding ensures     # we have just enough elements to fill the last window.     padding = (fillvalue,) * (n - 1 if step >= n else step - 1)     filler = map(window.append, chain(iterator, padding))      # Generate the rest of the windows     for _ in islice(filler, step - 1, None, step):         yield tuple(window)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef kth_permutation(k, n):\n    \"\"\"\n    Finds k'th lexicographic permutation (in increasing order) of\n    0,1,2,...n-1 in O(n^2) time.\n\n    Examples:\n    First permutation is always 0,1,2,...n\n    >>> kth_permutation(0,5)\n    [0, 1, 2, 3, 4]\n\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n    [1,2,3,0], [1,3,0,2]\n    >>> kth_permutation(10,4)\n    [1, 3, 0, 2]\n    \"\"\"\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation", "output": "def kth_permutation(k, n):\n    \"\"\"\n    Finds k'th lexicographic permutation (in increasing order) of\n    0,1,2,...n-1 in O(n^2) time.\n\n    Examples:\n    First permutation is always 0,1,2,...n\n    >>> kth_permutation(0,5)\n    [0, 1, 2, 3, 4]\n\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n    [1,2,3,0], [1,3,0,2]\n    >>> kth_permutation(10,4)\n    [1, 3, 0, 2]\n    \"\"\"\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation"}
{"task": "summary", "input": "summarize code:\ndef compute_transform_tables(\n    source_string: str,\n    destination_string: str,\n    copy_cost: int,\n    replace_cost: int,\n    delete_cost: int,\n    insert_cost: int,\n) -> tuple[list[list[int]], list[list[str]]]:\n    source_seq = list(source_string)\n    destination_seq = list(destination_string)\n    len_source_seq = len(source_seq)\n    len_destination_seq = len(destination_seq)\n    costs = [\n        [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n    ops = [\n        [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n\n    for i in range(1, len_source_seq + 1):\n        costs[i][0] = i * delete_cost\n        ops[i][0] = f\"D{source_seq[i - 1]}\"\n\n    for i in range(1, len_destination_seq + 1):\n        costs[0][i] = i * insert_cost\n        ops[0][i] = f\"I{destination_seq[i - 1]}\"\n\n    for i in range(1, len_source_seq + 1):\n        for j in range(1, len_destination_seq + 1):\n            if source_seq[i - 1] == destination_seq[j - 1]:\n                costs[i][j] = costs[i - 1][j - 1] + copy_cost\n                ops[i][j] = f\"C{source_seq[i - 1]}\"\n            else:\n                costs[i][j] = costs[i - 1][j - 1] + replace_cost\n                ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])\n\n            if costs[i - 1][j] + delete_cost < costs[i][j]:\n                costs[i][j] = costs[i - 1][j] + delete_cost\n                ops[i][j] = f\"D{source_seq[i - 1]}\"\n\n            if costs[i][j - 1] + insert_cost < costs[i][j]:\n                costs[i][j] = costs[i][j - 1] + insert_cost\n                ops[i][j] = f\"I{destination_seq[j - 1]}\"\n\n    return costs, ops", "output": "Finds the most cost efficient sequence"}
{"task": "detection", "input": "classify code:\ndef combination_sum_iv(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef count_vowels(s: str) -> int:\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)", "output": "Count the number of vowels in a given string."}
{"task": "repair", "input": "fix bug:\ndef bisect_right(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "def bisect_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo"}
{"task": "search", "input": "search code:\nclosest pair of points in strip\n\nChoices:\n0: def run_length_encode(text: str) -> list:     encoded = []     count = 1      for i in range(len(text)):         if i + 1 < len(text) and text[i] == text[i + 1]:             count += 1         else:             encoded.append((text[i], count))             count = 1      return encoded\n1: def dis_between_closest_in_strip(points, points_counts, min_dis=float(\"inf\")):      for i in range(min(6, points_counts - 1), points_counts):         for j in range(max(0, i - 6), i):             current_dis = euclidean_distance_sqr(points[i], points[j])             min_dis = min(min_dis, current_dis)     return min_dis\n2: def main():     num = int(input(\"Enter an integer to see if it is an Armstrong number: \").strip())     print(f\"{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number.\")     print(f\"{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number.\")     print(f\"{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number.\")", "output": "1"}
{"task": "detection", "input": "classify code:\ndef solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef example(wav_file_path: str = \"./path-to-file/sample.wav\") -> np.ndarray:\n    from scipy.io import wavfile\n\n    # Load the audio from the WAV file\n    sample_rate, audio = wavfile.read(wav_file_path)\n\n    # Calculate MFCCs\n    return mfcc(audio, sample_rate)", "output": "Example function to calculate Mel Frequency Cepstral Coefficients"}
{"task": "search", "input": "search code:\nReturn the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi\n\nChoices:\n0: def find_winner(num_people: int, step_size: int) -> int:     return josephus_recursive(num_people, step_size) + 1\n1: def compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:      id_ = 0     n = len(graph)  # No of vertices in graph     low = [0] * n     visited = [False] * n      def dfs(at, parent, bridges, id_):         visited[at] = True         low[at] = id_         id_ += 1         for to in graph[at]:             if to == parent:                 pass             elif not visited[to]:                 dfs(to, at, bridges, id_)                 low[at] = min(low[at], low[to])                 if id_ <= low[to]:                     bridges.append((at, to) if at < to else (to, at))             else:                 # This edge is a back edge and cannot be a bridge                 low[at] = min(low[at], low[to])      bridges: list[tuple[int, int]] = []     for i in range(n):         if not visited[i]:             dfs(i, -1, bridges, id_)     return bridges\n2: def fibonacci_generator() -> Generator[int]:     a, b = 0, 1     while True:         a, b = b, a + b         yield b", "output": "1"}
{"task": "detection", "input": "classify code:\ndef calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef list_truncated_nums(n: int) -> List[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r", "output": "def list_truncated_nums(n: int) -> list[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r"}
{"task": "search", "input": "search code:\nA version of :func:`zip` that \"broadcasts\" any scalar\n\nChoices:\n0: def zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):      def is_scalar(obj):         if scalar_types and isinstance(obj, scalar_types):             return True         try:             iter(obj)         except TypeError:             return True         else:             return False      size = len(objects)     if not size:         return      new_item = [None] * size     iterables, iterable_positions = [], []     for i, obj in enumerate(objects):         if is_scalar(obj):             new_item[i] = obj         else:             iterables.append(iter(obj))             iterable_positions.append(i)      if not iterables:         yield tuple(objects)         return      for item in zip(*iterables, strict=strict):         for i, new_item[i] in zip(iterable_positions, item):             pass         yield tuple(new_item)\n1: def calculate_turn_around_time(     process_name: list, arrival_time: list, burst_time: list, no_of_process: int ) -> list:      current_time = 0     # Number of processes finished     finished_process_count = 0     # Displays the finished process.     # If it is 0, the performance is completed if it is 1, before the performance.     finished_process = [0] * no_of_process     # List to include calculation results     turn_around_time = [0] * no_of_process      # Sort by arrival time.     burst_time = [burst_time[i] for i in np.argsort(arrival_time)]     process_name = [process_name[i] for i in np.argsort(arrival_time)]     arrival_time.sort()      while no_of_process > finished_process_count:         i = 0         while finished_process[i] == 1:             i += 1         current_time = max(current_time, arrival_time[i])          response_ratio = 0         # Index showing the location of the process being performed         loc = 0         # Saves the current response ratio.         temp = 0         for i in range(no_of_process):             if finished_process[i] == 0 and arrival_time[i] <= current_time:                 temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[                     i                 ]             if response_ratio < temp:                 response_ratio = temp                 loc = i          # Calculate the turn around time         turn_around_time[loc] = current_time + burst_time[loc] - arrival_time[loc]         current_time += burst_time[loc]         # Indicates that the process has been performed.         finished_process[loc] = 1         # Increase finished_process_count by 1         finished_process_count += 1      return turn_around_time\n2: def shear_stress(     stress: float,     tangential_force: float,     area: float, ) -> tuple[str, float]:     if (stress, tangential_force, area).count(0) != 1:         raise ValueError(\"You cannot supply more or less than 2 values\")     elif stress < 0:         raise ValueError(\"Stress cannot be negative\")     elif tangential_force < 0:         raise ValueError(\"Tangential Force cannot be negative\")     elif area < 0:         raise ValueError(\"Area cannot be negative\")     elif stress == 0:         return (             \"stress\",             tangential_force / area,         )     elif tangential_force == 0:         return (             \"tangential_force\",             stress * area,         )     else:         return (             \"area\",             tangential_force / stress,         )", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef check_anagrams(first_str: str, second_str: str) -> bool:\n    first_str = first_str.lower().strip()\n    second_str = second_str.lower().strip()\n\n    # Remove whitespace\n    first_str = first_str.replace(\" \", \"\")\n    second_str = second_str.replace(\" \", \"\")\n\n    # Strings of different lengths are not anagrams\n    if len(first_str) != len(second_str):\n        return False\n\n    # Default values for count should be 0\n    count: defaultdict[str, int] = defaultdict(int)\n\n    # For each character in input strings,\n    # increment count in the corresponding\n    for i in range(len(first_str)):\n        count[first_str[i]] += 1\n        count[second_str[i]] -= 1\n\n    return all(_count == 0 for _count in count.values())", "output": "Two strings are anagrams if they are made up of the same letters but are"}
{"task": "repair", "input": "fix bug:\ndef generate_parentheses_iterative(length: int) -> list:\n    \"\"\"\n    Generate all valid combinations of parentheses (Iterative Approach).\n\n    The algorithm works as follows:\n    1. Initialize an empty list to store the combinations.\n    2. Initialize a stack to keep track of partial combinations.\n    3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n    4. While the stack is not empty:\n        a. Pop a partial combination and its open and close counts from the stack.\n        b. If the combination length is equal to 2*length, add it to the result.\n        c. If open count < length, push new combination with added '(' on stack.\n        d. If close count < open count, push new combination with added ')' on stack.\n    5. Return the result containing all valid combinations.\n\n    Args:\n        length: The desired length of the parentheses combinations\n\n    Returns:\n        A list of strings representing valid combinations of parentheses\n\n    Time Complexity:\n        O(2^(2*length))\n\n    Space Complexity:\n        O(2^(2*length))\n\n    >>> generate_parentheses_iterative(3)\n    ['()()()', '()(())', '(())()', '(()())', '((()))']\n    >>> generate_parentheses_iterative(2)\n    ['()()', '(())']\n    >>> generate_parentheses_iterative(1)\n    ['()']\n    >>> generate_parentheses_iterative(0)\n    ['']\n    \"\"\"\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result", "output": "def generate_parentheses_iterative(length: int) -> list:\n    \"\"\"\n    Generate all valid combinations of parentheses (Iterative Approach).\n\n    The algorithm works as follows:\n    1. Initialize an empty list to store the combinations.\n    2. Initialize a stack to keep track of partial combinations.\n    3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n    4. While the stack is not empty:\n        a. Pop a partial combination and its open and close counts from the stack.\n        b. If the combination length is equal to 2*length, add it to the result.\n        c. If open count < length, push new combination with added '(' on stack.\n        d. If close count < open count, push new combination with added ')' on stack.\n    5. Return the result containing all valid combinations.\n\n    Args:\n        length: The desired length of the parentheses combinations\n\n    Returns:\n        A list of strings representing valid combinations of parentheses\n\n    Time Complexity:\n        O(2^(2*length))\n\n    Space Complexity:\n        O(2^(2*length))\n\n    >>> generate_parentheses_iterative(3)\n    ['()()()', '()(())', '(())()', '(()())', '((()))']\n    >>> generate_parentheses_iterative(2)\n    ['()()', '(())']\n    >>> generate_parentheses_iterative(1)\n    ['()']\n    >>> generate_parentheses_iterative(0)\n    ['']\n    \"\"\"\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result"}
{"task": "detection", "input": "classify code:\ndef odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef _validate_input(points: list[Point] | list[list[float]]) -> list[Point]:\n\n    if not hasattr(points, \"__iter__\"):\n        msg = f\"Expecting an iterable object but got an non-iterable type {points}\"\n        raise ValueError(msg)\n\n    if not points:\n        msg = f\"Expecting a list of points but got {points}\"\n        raise ValueError(msg)\n\n    return _construct_points(points)", "output": "validates an input instance before a convex-hull algorithms uses it"}
{"task": "search", "input": "search code:\nGenerate a sequence of prime numbers\n\nChoices:\n0: def prime_generator():      num = 2     while True:         if is_prime(num):             yield num         num += 1\n1: def subset_combinations(elements: list[int], n: int) -> list:     r = len(elements)     if n > r:         return []      dp: list[list[tuple]] = [[] for _ in range(r + 1)]      dp[0].append(())      for i in range(1, r + 1):         for j in range(i, 0, -1):             for prev_combination in dp[j - 1]:                 dp[j].append((*prev_combination, elements[i - 1]))      try:         return sorted(dp[n])     except TypeError:         return dp[n]\n2: def f(x: float) -> float:     return math.pow(x, 3) - (2 * x) - 5", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef wiggle_sort(nums):\n    \"\"\"Perform Wiggle Sort.\"\"\"\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]", "output": "def wiggle_sort(nums: list) -> list:\n    \"\"\"\n    Python implementation of wiggle.\n    Example:\n    >>> wiggle_sort([0, 5, 3, 2, 2])\n    [0, 5, 2, 3, 2]\n    >>> wiggle_sort([])\n    []\n    >>> wiggle_sort([-2, -5, -45])\n    [-45, -2, -5]\n    >>> wiggle_sort([-2.1, -5.68, -45.11])\n    [-45.11, -2.1, -5.68]\n    \"\"\"\n    for i, _ in enumerate(nums):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\n    return nums"}
{"task": "detection", "input": "classify code:\ndef sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef invert_modulo(a: int, n: int) -> int:\n    (b, _x) = extended_euclid(a, n)  # Implemented below\n    if b < 0:\n        b = (b % n + n) % n\n    return b", "output": "This function find the inverses of a i.e., a^(-1)"}
{"task": "repair", "input": "fix bug:\ndef perfect_cube(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not.\n\n    >>> perfect_cube(27)\n    True\n    >>> perfect_cube(4)\n    False\n    \"\"\"\n    val = n ** (1 / 3)\n    return (val * val * val) == n", "output": "def perfect_cube(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not.\n\n    >>> perfect_cube(27)\n    True\n    >>> perfect_cube(4)\n    False\n    \"\"\"\n    val = n ** (1 / 3)\n    return (val * val * val) == n"}
{"task": "detection", "input": "classify code:\ndef remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Reomove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split(\" \"))))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nYield lists of items from *iterable*, where each list ends just before\n\nChoices:\n0: def split_before(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         if pred(item) and buf:             yield buf             if maxsplit == 1:                 yield [item, *it]                 return             buf = []             maxsplit -= 1         buf.append(item)     if buf:         yield buf\n1: def validate_initial_digits(credit_card_number: str) -> bool:     return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))\n2: def download_image(url: str) -> str:     try:         response = httpx.get(url, timeout=10)         response.raise_for_status()     except httpx.RequestError as e:         return f\"An error occurred during the HTTP request to {url}: {e!r}\"      soup = BeautifulSoup(response.text, \"html.parser\")     image_meta_tag = soup.find(\"meta\", {\"property\": \"og:image\"})     if not image_meta_tag:         return \"No meta tag with property 'og:image' was found.\"      image_url = image_meta_tag.get(\"content\")     if not image_url:         return f\"Image URL not found in meta tag {image_meta_tag}.\"      try:         image_data = httpx.get(image_url, timeout=10).content     except httpx.RequestError as e:         return f\"An error occurred during the HTTP request to {image_url}: {e!r}\"     if not image_data:         return f\"Failed to download the image from {image_url}.\"      file_name = f\"{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H-%M-%S}.jpg\"     with open(file_name, \"wb\") as out_file:         out_file.write(image_data)     return f\"Image downloaded and saved in the file {file_name}\"", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 200) -> int:\n    total = 0\n    for i in range(2, n + 1):\n        max_length = 0\n        while True:\n            nums = [1]\n            max_length += 1\n            if solve(nums=nums, goal=i, depth=max_length):\n                break\n        total += max_length\n    return total", "output": "Calculates sum of smallest number of multiplactions for each number up to"}
{"task": "search", "input": "search code:\nReturns the color of a node, allowing for None leaves.\n\nChoices:\n0: def color(node: RedBlackTree | None) -> int:     if node is None:         return 0     else:         return node.color\n1: def quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:      if a == 0:         raise ValueError(\"Coefficient 'a' must not be zero.\")     delta = b * b - 4 * a * c      root_1 = (-b + sqrt(delta)) / (2 * a)     root_2 = (-b - sqrt(delta)) / (2 * a)      return (         root_1.real if not root_1.imag else root_1,         root_2.real if not root_2.imag else root_2,     )\n2: def ceil(x: float) -> int:     return int(x) if x - int(x) <= 0 else int(x) + 1", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Reomove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split(\" \"))))", "output": "def remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Remove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    >>> remove_duplicates(\"Python   is      great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split())))"}
{"task": "detection", "input": "classify code:\ndef get_pascal_triangle_unique_coefficients(depth: int) -> Set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef apnumber(value):\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n    if not 0 <= value < 10:\n        return str(value)\n    return (\n        _(\"zero\"),\n        _(\"one\"),\n        _(\"two\"),\n        _(\"three\"),\n        _(\"four\"),\n        _(\"five\"),\n        _(\"six\"),\n        _(\"seven\"),\n        _(\"eight\"),\n        _(\"nine\"),\n    )[value]", "output": "Converts an integer to Associated Press style."}
{"task": "search", "input": "search code:\nA pure Python implementation of a fibonacci search algorithm.\n\nChoices:\n0: def create_cipher_map(key: str) -> dict[str, str]:     # Create a list of the letters in the alphabet     alphabet = [chr(i + 65) for i in range(26)]     # Remove duplicate characters from key     key = remove_duplicates(key.upper())     offset = len(key)     # First fill cipher with key characters     cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}     # Then map remaining characters in alphabet to     # the alphabet from the beginning     for i in range(len(cipher_alphabet), 26):         char = alphabet[i - offset]         # Ensure we are not mapping letters to letters previously mapped         while char in key:             offset -= 1             char = alphabet[i - offset]         cipher_alphabet[alphabet[i]] = char     return cipher_alphabet\n1: def fibonacci_search(arr: list, val: int) -> int:     len_list = len(arr)     # Find m such that F_m >= n where F_i is the i_th fibonacci number.     i = 0     while True:         if fibonacci(i) >= len_list:             fibb_k = i             break         i += 1     offset = 0     while fibb_k > 0:         index_k = min(             offset + fibonacci(fibb_k - 1), len_list - 1         )  # Prevent out of range         item_k_1 = arr[index_k]         if item_k_1 == val:             return index_k         elif val < item_k_1:             fibb_k -= 1         elif val > item_k_1:             offset += fibonacci(fibb_k - 1)             fibb_k -= 2     return -1\n2: def erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:     output = np.zeros_like(image)     image_padded = np.zeros(         (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)     )      # Copy image to padded image     image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image      # Iterate over image & apply kernel     for x in range(image.shape[1]):         for y in range(image.shape[0]):             summation = (                 kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]             ).sum()             output[y, x] = int(summation == 5)     return output", "output": "1"}
{"task": "detection", "input": "classify code:\ndef contains_an_even_digit(n: int) -> bool:\n    \"\"\"\n    Return True if n contains an even digit.\n    >>> contains_an_even_digit(0)\n    True\n    >>> contains_an_even_digit(975317933)\n    False\n    >>> contains_an_even_digit(-245679)\n    True\n    \"\"\"\n    return any(digit in \"02468\" for digit in str(n))", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef geometric_series(nth_term: int, start_term_a: int, common_ratio_r: int) -> list:\n    \"\"\"Pure Python implementation of Geometric Series algorithm\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, '4.41', '9.261000000000001', '19.448100000000004']\n    >>> geometric_series(4, 2, -2)\n    [2, '-4.0', '8.0', '-16.0']\n    >>> geometric_series(4, -2, 2)\n    [-2, '-4.0', '-8.0', '-16.0']\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if \"\" in (nth_term, start_term_a, common_ratio_r):\n        return \"\"\n    series = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(str(float(start_term_a) * float(multiple)))\n            multiple = pow(float(common_ratio_r), power)\n    return series", "output": "def geometric_series(\n    nth_term: float | int,\n    start_term_a: float | int,\n    common_ratio_r: float | int,\n) -> list[float | int]:\n    \"\"\"\n    Pure Python implementation of Geometric Series algorithm\n\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\n    >>> geometric_series(4, 2, -2)\n    [2, -4.0, 8.0, -16.0]\n    >>> geometric_series(4, -2, 2)\n    [-2, -4.0, -8.0, -16.0]\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float | int] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series"}
{"task": "search", "input": "search code:\nFunction checks the all possible combinations with using bottom up approach,\n\nChoices:\n0: def check1(number: int) -> bool:      check_last = [0] * 11      # mark last 9 numbers     for _ in range(9):         check_last[int(number % 10)] = 1         number = number // 10     # flag     f = True      # check last 9 numbers for pandigitality      for x in range(9):         if not check_last[x + 1]:             f = False     return f\n1: def combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:      dp_array = [0] * (target + 1)     dp_array[0] = 1      for i in range(1, target + 1):         for j in range(n):             if i - array[j] >= 0:                 dp_array[i] += dp_array[i - array[j]]      return dp_array[target]\n2: def get_cluster(nodes):     cluster = {}     for key, value in nodes.items():         cluster.setdefault(key.count(\"1\"), {})[key] = value     return cluster", "output": "1"}
{"task": "detection", "input": "classify code:\ndef max_sub_array(nums: List[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    \"\"\"\n    digits = 0\n    while n > 0:\n        n = n // 10\n        digits += 1\n    return digits", "output": "def num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    >>> num_digits(0)\n    1\n    >>> num_digits(-1)\n    1\n    >>> num_digits(-123456)\n    6\n    \"\"\"\n    digits = 0\n    n = abs(n)\n    while True:\n        n = n // 10\n        digits += 1\n        if n == 0:\n            break\n    return digits"}
{"task": "summary", "input": "summarize code:\ndef calculate_waiting_time(\n    process_name: list,  # noqa: ARG001\n    turn_around_time: list,\n    burst_time: list,\n    no_of_process: int,\n) -> list:\n\n    waiting_time = [0] * no_of_process\n    for i in range(no_of_process):\n        waiting_time[i] = turn_around_time[i] - burst_time[i]\n    return waiting_time", "output": "Calculate the waiting time of each processes."}
{"task": "detection", "input": "classify code:\ndef odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns a prime number generator using sieve method.\n\nChoices:\n0: def jump_search(arr: Sequence[T], item: T) -> int:      arr_size = len(arr)     block_size = int(math.sqrt(arr_size))      prev = 0     step = block_size     while arr[min(step, arr_size) - 1] < item:         prev = step         step += block_size         if prev >= arr_size:             return -1      while arr[prev] < item:         prev += 1         if prev == min(step, arr_size):             return -1     if arr[prev] == item:         return prev     return -1\n1: def sieve() -> Generator[int]:     factor_map: dict[int, int] = {}     prime = 2     while True:         factor = factor_map.pop(prime, None)         if factor:             x = factor + prime             while x in factor_map:                 x += factor             factor_map[x] = factor         else:             factor_map[prime * prime] = prime             yield prime         prime += 1\n2: def inorder(root: Node | None) -> None:     if not root:  # None         return     else:         inorder(root.left)         print(root.value, end=\",\")         inorder(root.right)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_nodes_from_right_to_left(root: Node | None, level: int) -> Generator[int]:\n\n    def populate_output(root: Node | None, level: int) -> Generator[int]:\n        if not root:\n            return\n        if level == 1:\n            yield root.data\n        elif level > 1:\n            yield from populate_output(root.right, level - 1)\n            yield from populate_output(root.left, level - 1)\n\n    yield from populate_output(root, level)", "output": "Returns a list of nodes value from a particular level:"}
{"task": "repair", "input": "fix bug:\ndef median_of_five(arr: list) -> int:\n    \"\"\"\n    Return the median of the input list\n    :param arr: Array to find median of\n    :return: median of arr\n\n    >>> median_of_five([2, 4, 5, 7, 899])\n    5\n    >>> median_of_five([5, 7, 899, 54, 32])\n    32\n    >>> median_of_five([5, 4, 3, 2])\n    4\n    >>> median_of_five([3, 5, 7, 10, 2])\n    5\n    \"\"\"\n    arr = sorted(arr)\n    return arr[len(arr) // 2]", "output": "def median_of_five(arr: list) -> int:\n    \"\"\"\n    Return the median of the input list\n    :param arr: Array to find median of\n    :return: median of arr\n\n    >>> median_of_five([2, 4, 5, 7, 899])\n    5\n    >>> median_of_five([5, 7, 899, 54, 32])\n    32\n    >>> median_of_five([5, 4, 3, 2])\n    4\n    >>> median_of_five([3, 5, 7, 10, 2])\n    5\n    \"\"\"\n    arr = sorted(arr)\n    return arr[len(arr) // 2]"}
{"task": "summary", "input": "summarize code:\ndef calculate_resistance(number_of_bands: int, color_code_list: list) -> dict:\n    is_valid = check_validity(number_of_bands, color_code_list)\n    if is_valid:\n        number_of_significant_bands = get_band_type_count(\n            number_of_bands, \"significant\"\n        )\n        significant_colors = color_code_list[:number_of_significant_bands]\n        significant_digits = int(get_significant_digits(significant_colors))\n        multiplier_color = color_code_list[number_of_significant_bands]\n        multiplier = get_multiplier(multiplier_color)\n        if number_of_bands == 3:\n            tolerance_color = None\n        else:\n            tolerance_color = color_code_list[number_of_significant_bands + 1]\n        tolerance = (\n            20 if tolerance_color is None else get_tolerance(str(tolerance_color))\n        )\n        if number_of_bands != 6:\n            temperature_coeffecient_color = None\n        else:\n            temperature_coeffecient_color = color_code_list[\n                number_of_significant_bands + 2\n            ]\n        temperature_coeffecient = (\n            0\n            if temperature_coeffecient_color is None\n            else get_temperature_coeffecient(str(temperature_coeffecient_color))\n        )\n        resisitance = significant_digits * multiplier\n        if temperature_coeffecient == 0:\n            answer = f\"{resisitance}Î© Â±{tolerance}% \"\n        else:\n            answer = f\"{resisitance}Î© Â±{tolerance}% {temperature_coeffecient} ppm/K\"\n        return {\"resistance\": answer}\n    else:\n        raise ValueError(\"Input is invalid\")", "output": "Function calculates the total resistance of the resistor using the color codes."}
{"task": "repair", "input": "fix bug:\ndef decimal_isolate(number: float, digit_amount: int) -> float:\n    \"\"\"\n    Isolates the decimal part of a number.\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\n    >>> decimal_isolate(1.53, 0)\n    0.53\n    >>> decimal_isolate(35.345, 1)\n    0.3\n    >>> decimal_isolate(35.345, 2)\n    0.34\n    >>> decimal_isolate(35.345, 3)\n    0.345\n    >>> decimal_isolate(-14.789, 3)\n    -0.789\n    >>> decimal_isolate(0, 2)\n    0\n    >>> decimal_isolate(-14.123, 1)\n    -0.1\n    >>> decimal_isolate(-14.123, 2)\n    -0.12\n    >>> decimal_isolate(-14.123, 3)\n    -0.123\n    \"\"\"\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)", "output": "def decimal_isolate(number: float, digit_amount: int) -> float:\n    \"\"\"\n    Isolates the decimal part of a number.\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\n    >>> decimal_isolate(1.53, 0)\n    0.53\n    >>> decimal_isolate(35.345, 1)\n    0.3\n    >>> decimal_isolate(35.345, 2)\n    0.34\n    >>> decimal_isolate(35.345, 3)\n    0.345\n    >>> decimal_isolate(-14.789, 3)\n    -0.789\n    >>> decimal_isolate(0, 2)\n    0\n    >>> decimal_isolate(-14.123, 1)\n    -0.1\n    >>> decimal_isolate(-14.123, 2)\n    -0.12\n    >>> decimal_isolate(-14.123, 3)\n    -0.123\n    \"\"\"\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)"}
{"task": "detection", "input": "classify code:\ndef check1(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital from END\n\n    >>> check1(123456789987654321)\n    True\n\n    >>> check1(120000987654321)\n    True\n\n    >>> check1(12345678957656779870004321)\n    False\n\n    \"\"\"\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn a 2-tuple with a list containing the first *n* elements of\n\nChoices:\n0: def sigmoid(vector: np.ndarray) -> np.ndarray:     return 1 / (1 + np.exp(-vector))\n1: def spy(iterable, n=1):     p, q = tee(iterable)     return take(n, q), p\n2: def bell_numbers(max_set_length: int) -> list[int]:     if max_set_length < 0:         raise ValueError(\"max_set_length must be non-negative\")      bell = [0] * (max_set_length + 1)     bell[0] = 1      for i in range(1, max_set_length + 1):         for j in range(i):             bell[i] += _binomial_coefficient(i - 1, j) * bell[j]      return bell", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef ichunked(iterable, n):\n    iterator = iter(iterable)\n    while True:\n        # Create new chunk\n        chunk, materialize_next = _ichunk(iterator, n)\n\n        # Check to see whether we're at the end of the source iterable\n        if not materialize_next():\n            return\n\n        yield chunk\n\n        # Fill previous chunk's cache\n        materialize_next(None)", "output": "Break *iterable* into sub-iterables with *n* elements each."}
{"task": "detection", "input": "classify code:\ndef extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn the number of different square laminae that can be formed using up to\n\nChoices:\n0: def solution(filename: str = \"matrix.txt\") -> int:     with open(os.path.join(os.path.dirname(__file__), filename)) as in_file:         data = in_file.read()      grid = [[int(cell) for cell in row.split(\",\")] for row in data.strip().splitlines()]     dp = [[0 for cell in row] for row in grid]     n = len(grid[0])      dp = [[0 for i in range(n)] for j in range(n)]     dp[0][0] = grid[0][0]     for i in range(1, n):         dp[0][i] = grid[0][i] + dp[0][i - 1]     for i in range(1, n):         dp[i][0] = grid[i][0] + dp[i - 1][0]      for i in range(1, n):         for j in range(1, n):             dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])      return dp[-1][-1]\n1: def display_billionaires(forbes_billionaires: list[dict[str, int | str]]) -> None:      table = rich_table.Table(         title=f\"Forbes Top {LIMIT} Real-Time Billionaires at {TODAY:%Y-%m-%d %H:%M}\",         style=\"green\",         highlight=True,         box=box.SQUARE,     )     for key in forbes_billionaires[0]:         table.add_column(key)      for billionaire in forbes_billionaires:         table.add_row(*billionaire.values())      rich_console.Console().print(table)\n2: def solution(limit: int = 1000000) -> int:     answer = 0      for outer_width in range(3, (limit // 4) + 2):         if outer_width**2 > limit:             hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)         else:             hole_width_lower_bound = 1         if (outer_width - hole_width_lower_bound) % 2:             hole_width_lower_bound += 1          answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1      return answer", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef linear_search(sequence, target):\n    \"\"\"Pure implementation of linear search algorithm in Python\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return None", "output": "def linear_search(sequence: list, target: int) -> int:\n    \"\"\"A pure Python implementation of a linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return -1"}
{"task": "detection", "input": "classify code:\ndef median(nums):\n    \"\"\"Find median of a list of numbers.\"\"\"\n    # Sort list\n    sorted_list = sorted(nums)\n    print(\"List of numbers:\")\n    print(sorted_list)\n\n    # Is number of items in list even?\n    if len(sorted_list) % 2 == 0:\n        # Find index for first middle value.\n        mid_index_1 = len(sorted_list) / 2\n        # Find index for second middle value.\n        mid_index_2 = -(len(sorted_list) / 2) - 1\n        # Divide middle values by 2 to get average (mean).\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n        return med  # Return makes `else:` unnecessary.\n    # Number of items is odd.\n    mid_index = (len(sorted_list) - 1) / 2\n    # Middle index is median.\n    med = sorted_list[mid_index]\n    return med", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the maximum sum of k consecutive elements\n\nChoices:\n0: def run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta):     n = len_data      prod = np.dot(theta, data_x.transpose())     prod -= data_y.transpose()     sum_grad = np.dot(prod, data_x)     theta = theta - (alpha / n) * sum_grad     return theta\n1: def max_sum_in_array(array: list[int], k: int) -> int:     if len(array) < k or k < 0:         raise ValueError(\"Invalid Input\")     max_sum = current_sum = sum(array[:k])     for i in range(len(array) - k):         current_sum = current_sum - array[i] + array[i + k]         max_sum = max(max_sum, current_sum)     return max_sum\n2: def solution(n: int = 1000000) -> int:     largest_number = 1     pre_counter = 1     counters = {1: 1}      for input1 in range(2, n):         counter = 0         number = input1          while True:             if number in counters:                 counter += counters[number]                 break             if number % 2 == 0:                 number //= 2                 counter += 1             else:                 number = (3 * number) + 1                 counter += 1          if input1 not in counters:             counters[input1] = counter          if counter > pre_counter:             largest_number = input1             pre_counter = counter     return largest_number", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef calculate_spearman_rank_correlation(\n    variable_1: Sequence[float], variable_2: Sequence[float]\n) -> float:\n    n = len(variable_1)\n    rank_var1 = assign_ranks(variable_1)\n    rank_var2 = assign_ranks(variable_2)\n\n    # Calculate differences of ranks\n    d = [rx - ry for rx, ry in zip(rank_var1, rank_var2)]\n\n    # Calculate the sum of squared differences\n    d_squared = sum(di**2 for di in d)\n\n    # Calculate the Spearman's rank correlation coefficient\n    rho = 1 - (6 * d_squared) / (n * (n**2 - 1))\n\n    return rho", "output": "Calculates Spearman's rank correlation coefficient."}
{"task": "repair", "input": "fix bug:\ndef construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway", "output": "def construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway"}
{"task": "detection", "input": "classify code:\ndef geometric_series(nth_term: int, start_term_a: int, common_ratio_r: int) -> list:\n    \"\"\"Pure Python implementation of Geometric Series algorithm\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, '4.41', '9.261000000000001', '19.448100000000004']\n    >>> geometric_series(4, 2, -2)\n    [2, '-4.0', '8.0', '-16.0']\n    >>> geometric_series(4, -2, 2)\n    [-2, '-4.0', '-8.0', '-16.0']\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if \"\" in (nth_term, start_term_a, common_ratio_r):\n        return \"\"\n    series = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(str(float(start_term_a) * float(multiple)))\n            multiple = pow(float(common_ratio_r), power)\n    return series", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef and_gate(input_1: int, input_2: int) -> int:\n    return int(input_1 and input_2)", "output": "Calculate AND of the input values"}
{"task": "search", "input": "search code:\nFunction description is as follows-\n\nChoices:\n0: def random_chars(number_char: int = 32) -> str:     assert number_char > 1, \"The number of character should greater than 1\"     letter_code = ascii_lowercase + digits     return \"\".join(random.choice(letter_code) for _ in range(number_char))\n1: def draw_fractal_recursive(x: float, y: float, length: float, depth: float):     if depth == 0:         draw_cross(x, y, length)         return      draw_fractal_recursive(x, y, length / 3, depth - 1)     draw_fractal_recursive(x + length / 3, y, length / 3, depth - 1)     draw_fractal_recursive(x - length / 3, y, length / 3, depth - 1)     draw_fractal_recursive(x, y + length / 3, length / 3, depth - 1)     draw_fractal_recursive(x, y - length / 3, length / 3, depth - 1)\n2: def knapsack(     weights: list, values: list, number_of_items: int, max_weight: int, index: int ) -> int:     if index == number_of_items:         return 0     ans1 = 0     ans2 = 0     ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)     if weights[index] <= max_weight:         ans2 = values[index] + knapsack(             weights, values, number_of_items, max_weight - weights[index], index + 1         )     return max(ans1, ans2)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef pressure_and_volume_to_temperature(\n    pressure: float, moles: float, volume: float\n) -> float:\n    \"\"\"\n    Convert pressure and volume to temperature.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> pressure_and_volume_to_temperature(0.82, 1, 2)\n      20\n      >>> pressure_and_volume_to_temperature(8.2, 5, 3)\n      60\n    \"\"\"\n    return round(float((pressure * volume) / (0.0821 * moles)))", "output": "def pressure_and_volume_to_temperature(\n    pressure: float, moles: float, volume: float\n) -> float:\n    \"\"\"\n    Convert pressure and volume to temperature.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> pressure_and_volume_to_temperature(0.82, 1, 2)\n      20\n      >>> pressure_and_volume_to_temperature(8.2, 5, 3)\n      60\n    \"\"\"\n    return round(float((pressure * volume) / (0.0821 * moles)))"}
{"task": "repair", "input": "fix bug:\ndef vol_cube(side_length: Union[int, float]) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)", "output": "def vol_cube(side_length: int | float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)"}
{"task": "detection", "input": "classify code:\ndef split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n\n    >>> split(\";abbb;;c;\", separator=';')\n    ['', 'abbb', '', 'c', '']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef number_of_divisors(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    div = 1\n    temp = 1\n    while n % 2 == 0:\n        temp += 1\n        n = int(n / 2)\n    div *= temp\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        temp = 1\n        while n % i == 0:\n            temp += 1\n            n = int(n / i)\n        div *= temp\n    if n > 1:\n        div *= 2\n    return div", "output": "Calculate Number of Divisors of an Integer."}
{"task": "search", "input": "search code:\nChecks whether n is a 9-digit 1 to 9 pandigital number.\n\nChoices:\n0: def generate_image(cells: list[list[int]]) -> Image.Image:     # Create the output image     img = Image.new(\"RGB\", (len(cells[0]), len(cells)))     pixels = img.load()     # Generates image     for w in range(img.width):         for h in range(img.height):             color = 255 - int(255 * cells[h][w])             pixels[w, h] = (color, color, color)     return img\n1: def is_9_pandigital(n: int) -> bool:     s = str(n)     return len(s) == 9 and set(s) == set(\"123456789\")\n2: def netstring_server(server_socket):     \"A basic netstring server loop, supporting a few operations\"     try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock)             while 1:                 request = client.read_ns()                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'reply4k':                     client.write_ns(b'a' * 4096)                 elif request == b'ping':                     client.write_ns(b'pong')                 elif request == b'reply128k':                     client.setmaxsize(128 * 1024)                     client.write_ns(b'huge' * 32 * 1024)  # 128kb                     client.setmaxsize(32768)  # back to default     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in xrange(m)] for _ in xrange(m + 1)]\n    for i in xrange(m + 1):\n        memo[i][0] = 1\n\n    for n in xrange(m + 1):\n        for k in xrange(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1", "output": "def partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1"}
{"task": "summary", "input": "summarize code:\ndef is_9_pandigital(n: int) -> bool:\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")", "output": "Checks whether n is a 9-digit 1 to 9 pandigital number."}
{"task": "detection", "input": "classify code:\ndef apply_table(inp, table):\n    \"\"\"\n    >>> apply_table(\"0123456789\", list(range(10)))\n    '9012345678'\n    >>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n    '8765432109'\n    \"\"\"\n    res = \"\"\n    for i in table:\n        res += inp[i - 1]\n    return res", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPassword Generator allows you to generate a random password of length N.\n\nChoices:\n0: def password_generator(length: int = 8) -> str:     chars = ascii_letters + digits + punctuation     return \"\".join(secrets.choice(chars) for _ in range(length))\n1: def match_word_pattern(pattern: str, input_string: str) -> bool:      def backtrack(pattern_index: int, str_index: int) -> bool:         if pattern_index == len(pattern) and str_index == len(input_string):             return True         if pattern_index == len(pattern) or str_index == len(input_string):             return False         char = pattern[pattern_index]         if char in pattern_map:             mapped_str = pattern_map[char]             if input_string.startswith(mapped_str, str_index):                 return backtrack(pattern_index + 1, str_index + len(mapped_str))             else:                 return False         for end in range(str_index + 1, len(input_string) + 1):             substr = input_string[str_index:end]             if substr in str_map:                 continue             pattern_map[char] = substr             str_map[substr] = char             if backtrack(pattern_index + 1, end):                 return True             del pattern_map[char]             del str_map[substr]         return False      pattern_map: dict[str, str] = {}     str_map: dict[str, str] = {}     return backtrack(0, 0)\n2: def build_tree() -> TreeNode:     root = TreeNode(1)     root.left = TreeNode(2)     root.right = TreeNode(5)     root.left.left = TreeNode(3)     root.left.right = TreeNode(4)     root.right.right = TreeNode(6)     return root", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]", "output": "def wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]"}
{"task": "summary", "input": "summarize code:\ndef find_minimum_partitions(string: str) -> int:\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]", "output": "Returns the minimum cuts needed for a palindrome partitioning of string"}
{"task": "detection", "input": "classify code:\ndef swap(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b", "output": "CORRECT"}
{"task": "search", "input": "search code:\nConvert the cells into a greyscale PIL.Image.Image and return it to the caller.\n\nChoices:\n0: def create_cipher_map(key: str) -> dict[str, str]:     # Create a list of the letters in the alphabet     alphabet = [chr(i + 65) for i in range(26)]     # Remove duplicate characters from key     key = remove_duplicates(key.upper())     offset = len(key)     # First fill cipher with key characters     cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}     # Then map remaining characters in alphabet to     # the alphabet from the beginning     for i in range(len(cipher_alphabet), 26):         char = alphabet[i - offset]         # Ensure we are not mapping letters to letters previously mapped         while char in key:             offset -= 1             char = alphabet[i - offset]         cipher_alphabet[alphabet[i]] = char     return cipher_alphabet\n1: def generate_image(cells: list[list[int]]) -> Image.Image:     # Create the output image     img = Image.new(\"RGB\", (len(cells[0]), len(cells)))     pixels = img.load()     # Generates image     for w in range(img.width):         for h in range(img.height):             color = 255 - int(255 * cells[h][w])             pixels[w, h] = (color, color, color)     return img\n2: def first_true(iterable, default=None, pred=None):     return next(filter(pred, iterable), default)", "output": "1"}
{"task": "search", "input": "search code:\nReturn true if the input n is a palindrome.\n\nChoices:\n0: def is_combination_valid(combination):     return (         int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))         == int(\"\".join(combination[5:9]))     ) or (         int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))         == int(\"\".join(combination[5:9]))     )\n1: def archimedes_principle(     fluid_density: float, volume: float, gravity: float = g ) -> float:      if fluid_density <= 0:         raise ValueError(\"Impossible fluid density\")     if volume <= 0:         raise ValueError(\"Impossible object volume\")     if gravity < 0:         raise ValueError(\"Impossible gravity\")      return fluid_density * gravity * volume\n2: def is_palindrome(n: int | str) -> bool:     n = str(n)     return n == n[::-1]", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef get_totients(max_one: int) -> List[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients", "output": "def get_totients(max_one: int) -> list[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients"}
{"task": "detection", "input": "classify code:\ndef f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef before_and_after(predicate, it):\n    trues, after = tee(it)\n    trues = compress(takewhile(predicate, trues), zip(after))\n    return trues, after", "output": "A variant of :func:`takewhile` that allows complete access to the"}
{"task": "repair", "input": "fix bug:\ndef binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int, right: int\n) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n\n    \"\"\"\n    if right < left:\n        return None\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)", "output": "def binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n    -1\n    \"\"\"\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)"}
{"task": "detection", "input": "classify code:\ndef p_series(nth_term: int, power: int) -> list:\n    \"\"\"Pure Python implementation of P-Series algorithm\n\n    :return: The P-Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> p_series(5, 2)\n    [1, '1/4', '1/9', '1/16', '1/25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    [1, '1/0.25', '1/0.1111111111111111', '1/0.0625', '1/0.04']\n    >>> p_series(\"\", 1000)\n    ''\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    [1]\n    \"\"\"\n    if nth_term == \"\":\n        return nth_term\n    nth_term = int(nth_term)\n    power = int(power)\n    series = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1/{pow(temp + 1, int(power))}\" if series else 1)\n    return series", "output": "BUGGY"}
{"task": "search", "input": "search code:\nApproximates the arc length of a line segment by treating the curve as a\n\nChoices:\n0: def print_linked_list(head: Node | None) -> None:     if head is None:         return     while head.next_node is not None:         print(head.data, end=\"->\")         head = head.next_node     print(head.data)\n1: def line_length(     fnc: Callable[[float], float],     x_start: float,     x_end: float,     steps: int = 100, ) -> float:      x1 = x_start     fx1 = fnc(x_start)     length = 0.0      for _ in range(steps):         # Approximates curve as a sequence of linear lines and sums their length         x2 = (x_end - x_start) / steps + x1         fx2 = fnc(x2)         length += math.hypot(x2 - x1, fx2 - fx1)          # Increment step         x1 = x2         fx1 = fx2      return length\n2: def mf_knapsack(i, wt, val, j):     global f  # a global dp table for knapsack     if f[i][j] < 0:         if j < wt[i - 1]:             val = mf_knapsack(i - 1, wt, val, j)         else:             val = max(                 mf_knapsack(i - 1, wt, val, j),                 mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],             )         f[i][j] = val     return f[i][j]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:\n    num_filters = len(filter_points) - 2\n    filters = np.zeros((num_filters, int(ftt_size / 2) + 1))\n\n    for n in range(num_filters):\n        start = filter_points[n]\n        mid = filter_points[n + 1]\n        end = filter_points[n + 2]\n\n        # Linearly increase values from 0 to 1\n        filters[n, start:mid] = np.linspace(0, 1, mid - start)\n\n        # Linearly decrease values from 1 to 0\n        filters[n, mid:end] = np.linspace(1, 0, end - mid)\n\n    return filters", "output": "Generate filters for audio processing."}
{"task": "detection", "input": "classify code:\ndef get_totients(max_one: int) -> list[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef peak(lst: List[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])", "output": "def peak(lst: list[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])"}
{"task": "summary", "input": "summarize code:\ndef partition(arr: list[int], low: int, high: int) -> int:\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] >= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1", "output": "Partitions list based on the pivot element."}
{"task": "search", "input": "search code:\nFind the smallest negative index\n\nChoices:\n0: def find_negative_index(array: list[int]) -> int:     left = 0     right = len(array) - 1      # Edge cases such as no values or all numbers are negative.     if not array or array[0] < 0:         return 0      while right + 1 > left:         mid = (left + right) // 2         num = array[mid]          # Num must be negative and the index must be greater than or equal to 0.         if num < 0 and array[mid - 1] >= 0:             return mid          if num >= 0:             left = mid + 1         else:             right = mid - 1     # No negative numbers so return the last index of the array + 1 which is the length.     return len(array)\n1: def is_square_form(num: int) -> bool:     digit = 9      while num > 0:         if num % 10 != digit:             return False         num //= 100         digit -= 1      return True\n2: def breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:     visited = [False] * len(graph)  # Mark all nodes as not visited     queue = []  # breadth-first search queue      # Source node     queue.append(source)     visited[source] = True      while queue:         u = queue.pop(0)  # Pop the front node         # Traverse all adjacent nodes of u         for ind, node in enumerate(graph[u]):             if visited[ind] is False and node > 0:                 queue.append(ind)                 visited[ind] = True                 parents[ind] = u     return visited[sink]", "output": "0"}
{"task": "search", "input": "search code:\nimage: is a grayscale PIL image object\n\nChoices:\n0: def n_input_and_gate(inputs: list[int]) -> int:     return int(all(inputs))\n1: def mean_threshold(image: Image) -> Image:     height, width = image.size     mean = 0     pixels = image.load()     for i in range(width):         for j in range(height):             pixel = pixels[j, i]             mean += pixel     mean //= width * height      for j in range(width):         for i in range(height):             pixels[i, j] = 255 if pixels[i, j] > mean else 0     return image\n2: def main() -> None:     kmap = [[0, 1], [1, 1]]      # Manually generate the product of [0, 1] and [0, 1]      for row in kmap:         print(row)      print(\"Simplified Expression:\")     print(simplify_kmap(kmap))", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef vernam_decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_decrypt(\"RIJVS\",\"KEY\")\n    'HELLO'\n    \"\"\"\n    decrypted_text = \"\"\n    for i in range(len(ciphertext)):\n        ct = ord(ciphertext[i]) - ord(key[i % len(key)])\n        while ct < 0:\n            ct = 26 + ct\n        decrypted_text += chr(65 + ct)\n    return decrypted_text", "output": "def vernam_decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_decrypt(\"RIJVS\",\"KEY\")\n    'HELLO'\n    \"\"\"\n    decrypted_text = \"\"\n    for i in range(len(ciphertext)):\n        ct = ord(ciphertext[i]) - ord(key[i % len(key)])\n        while ct < 0:\n            ct = 26 + ct\n        decrypted_text += chr(65 + ct)\n    return decrypted_text"}
{"task": "detection", "input": "classify code:\ndef generate_parentheses_iterative(length: int) -> list:\n    \"\"\"\n    Generate all valid combinations of parentheses (Iterative Approach).\n\n    The algorithm works as follows:\n    1. Initialize an empty list to store the combinations.\n    2. Initialize a stack to keep track of partial combinations.\n    3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n    4. While the stack is not empty:\n        a. Pop a partial combination and its open and close counts from the stack.\n        b. If the combination length is equal to 2*length, add it to the result.\n        c. If open count < length, push new combination with added '(' on stack.\n        d. If close count < open count, push new combination with added ')' on stack.\n    5. Return the result containing all valid combinations.\n\n    Args:\n        length: The desired length of the parentheses combinations\n\n    Returns:\n        A list of strings representing valid combinations of parentheses\n\n    Time Complexity:\n        O(2^(2*length))\n\n    Space Complexity:\n        O(2^(2*length))\n\n    >>> generate_parentheses_iterative(3)\n    ['()()()', '()(())', '(())()', '(()())', '((()))']\n    >>> generate_parentheses_iterative(2)\n    ['()()', '(())']\n    >>> generate_parentheses_iterative(1)\n    ['()']\n    >>> generate_parentheses_iterative(0)\n    ['']\n    \"\"\"\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef get_distance(x: float, y: float, max_step: int) -> float:\n    a = x\n    b = y\n    for step in range(max_step):  # noqa: B007\n        a_new = a * a - b * b + x\n        b = 2 * a * b + y\n        a = a_new\n\n        # divergence happens for all complex number with an absolute value\n        # greater than 4\n        if a * a + b * b > 4:\n            break\n    return step / (max_step - 1)", "output": "Return the relative distance (= step/max_step) after which the complex number"}
{"task": "search", "input": "search code:\nFind the number of digits in a number.\n\nChoices:\n0: def polynomial_derivative(coefficients):     n = len(coefficients)     powers = reversed(range(1, n))     return list(map(mul, coefficients, powers))\n1: def num_digits_faster(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      return len(str(abs(n)))\n2: def is_collection(obj):     return is_iterable(obj) and not isinstance(obj, (str, bytes))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef manhattan_distance_one_liner(point_a: list, point_b: list) -> float:\n\n    _validate_point(point_a)\n    _validate_point(point_b)\n    if len(point_a) != len(point_b):\n        raise ValueError(\"Both points must be in the same n-dimensional space\")\n\n    return float(sum(abs(x - y) for x, y in zip(point_a, point_b)))", "output": "Version with one liner"}
{"task": "detection", "input": "classify code:\ndef three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)"}
{"task": "search", "input": "search code:\nCalculate AND of a list of input values\n\nChoices:\n0: def n_input_and_gate(inputs: list[int]) -> int:     return int(all(inputs))\n1: def solution(n: int = 15) -> int:     total = 0     for m in range(2, n + 1):         x1 = 2 / (m + 1)         p = 1.0         for i in range(1, m + 1):             xi = i * x1             p *= xi**i         total += int(p)     return total\n2: def narcissistic_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False     expo = len(str(n))  # the power that all digits will be raised to     # check if sum of each digit multiplied expo times is equal to number     return n == sum(int(i) ** expo for i in str(n))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef is_combination_valid(combination):\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )", "output": "Checks if a combination (a tuple of 9 digits)"}
{"task": "repair", "input": "fix bug:\ndef is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )", "output": "def is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )"}
{"task": "detection", "input": "classify code:\ndef is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef surface_area_cube(side_length: float) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * side_length ** 2\r", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    \"\"\"\n    digits = 0\n    while n > 0:\n        n = n // 10\n        digits += 1\n    return digits", "output": "def num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    >>> num_digits(0)\n    1\n    >>> num_digits(-1)\n    1\n    >>> num_digits(-123456)\n    6\n    \"\"\"\n    digits = 0\n    n = abs(n)\n    while True:\n        n = n // 10\n        digits += 1\n        if n == 0:\n            break\n    return digits"}
{"task": "search", "input": "search code:\nSorts a list using the merge sort algorithm.\n\nChoices:\n0: def power_of_4(number: int) -> bool:     if not isinstance(number, int):         raise TypeError(\"number must be an integer\")     if number <= 0:         raise ValueError(\"number must be positive\")     if number & (number - 1) == 0:         c = 0         while number:             c += 1             number >>= 1         return c % 2 == 1     else:         return False\n1: def merge_sort(collection: list) -> list:      def merge(left: list, right: list) -> list:         result = []         while left and right:             result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))         result.extend(left)         result.extend(right)         return result      if len(collection) <= 1:         return collection     mid_index = len(collection) // 2     return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))\n2: def get_set_bits_count_using_modulo_operator(number: int) -> int:     if number < 0:         raise ValueError(\"the value of input must not be negative\")     result = 0     while number:         if number % 2 == 1:             result += 1         number >>= 1     return result", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:\n\n    game_matrix = [list(row) for row in matrix]\n    total_score = 0\n\n    for move in moves:\n        pos_x, pos_y = move\n        game_matrix, score = play(game_matrix, pos_x, pos_y, size)\n        total_score += score\n\n    return total_score", "output": "Processes the game logic for the given matrix and moves."}
{"task": "repair", "input": "fix bug:\ndef binary_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return None", "output": "def binary_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1"}
{"task": "search", "input": "search code:\ncreating sparse table which saves each nodes 2^i-th parent\n\nChoices:\n0: def slow_reversible_numbers(     remaining_length: int, remainder: int, digits: list[int], length: int ) -> int:     if remaining_length == 0:         if digits[0] == 0 or digits[-1] == 0:             return 0          for i in range(length // 2 - 1, -1, -1):             remainder += digits[i] + digits[length - i - 1]              if remainder % 2 == 0:                 return 0              remainder //= 10          return 1      if remaining_length == 1:         if remainder % 2 == 0:             return 0          result = 0         for digit in range(10):             digits[length // 2] = digit             result += slow_reversible_numbers(                 0, (remainder + 2 * digit) // 10, digits, length             )         return result      result = 0     for digit1 in range(10):         digits[(length + remaining_length) // 2 - 1] = digit1          if (remainder + digit1) % 2 == 0:             other_parity_digits = ODD_DIGITS         else:             other_parity_digits = EVEN_DIGITS          for digit2 in other_parity_digits:             digits[(length - remaining_length) // 2] = digit2             result += slow_reversible_numbers(                 remaining_length - 2,                 (remainder + digit1 + digit2) // 10,                 digits,                 length,             )     return result\n1: def get_files_url() -> str:     with open(os.environ[\"GITHUB_EVENT_PATH\"]) as file:         event = json.load(file)     return event[\"pull_request\"][\"url\"] + \"/files\"\n2: def create_sparse(max_node: int, parent: list[list[int]]) -> list[list[int]]:     j = 1     while (1 << j) < max_node:         for i in range(1, max_node + 1):             parent[j][i] = parent[j - 1][parent[j - 1][i]]         j += 1     return parent", "output": "2"}
{"task": "detection", "input": "classify code:\ndef split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef get_distinct_edge(edge_array):\n    distinct_edge = set()\n    for row in edge_array:\n        for item in row:\n            distinct_edge.add(item[0])\n    return list(distinct_edge)", "output": "Return Distinct edges from edge array of multiple graphs"}
{"task": "detection", "input": "classify code:\ndef sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef alt_ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    >>> alt_ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> alt_ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    \"\"\"\n    return int(\"0x\" + \"\".join(f\"{int(i):02x}\" for i in ipv4_address.split(\".\")), 16)", "output": "def alt_ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    >>> alt_ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> alt_ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    \"\"\"\n    return int(\"0x\" + \"\".join(f\"{int(i):02x}\" for i in ipv4_address.split(\".\")), 16)"}
{"task": "summary", "input": "summarize code:\ndef sum_of_digits_recursion(n: int) -> int:\n    n = abs(n)\n    return n if n < 10 else n % 10 + sum_of_digits(n // 10)", "output": "Find the sum of digits of a number using recursion"}
{"task": "search", "input": "search code:\nConversion between volume units.\n\nChoices:\n0: def centripetal(mass: float, velocity: float, radius: float) -> float:     if mass < 0:         raise ValueError(\"The mass of the body cannot be negative\")     if radius <= 0:         raise ValueError(\"The radius is always a positive non zero integer\")     return (mass * (velocity) ** 2) / radius\n1: def slow_solution(max_number: int = 10**8) -> int:      prime_numbers = slow_calculate_prime_numbers(max_number // 2)      semiprimes_count = 0     left = 0     right = len(prime_numbers) - 1     while left <= right:         while prime_numbers[left] * prime_numbers[right] >= max_number:             right -= 1         semiprimes_count += right - left + 1         left += 1      return semiprimes_count\n2: def volume_conversion(value: float, from_type: str, to_type: str) -> float:     if from_type not in METRIC_CONVERSION:         raise ValueError(             f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"             + \", \".join(METRIC_CONVERSION)         )     if to_type not in METRIC_CONVERSION:         raise ValueError(             f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"             + \", \".join(METRIC_CONVERSION)         )     return (         value         * METRIC_CONVERSION[from_type].from_factor         * METRIC_CONVERSION[to_type].to_factor     )", "output": "2"}
{"task": "search", "input": "search code:\nCalculate the factorial of specified number (n!).\n\nChoices:\n0: def factorial(number: int) -> int:     if number != int(number):         raise ValueError(\"factorial() only accepts integral values\")     if number < 0:         raise ValueError(\"factorial() not defined for negative values\")     value = 1     for i in range(1, number + 1):         value *= i     return value\n1: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)\n2: def method_2(boundary: list[int], steps: int) -> float:     # \"Simpson Rule\"     # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)     if steps <= 0:         raise ZeroDivisionError(\"Number of steps must be greater than zero\")      h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 3.0) * f(a)     cnt = 2     for i in x_i:         y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)         cnt += 1     y += (h / 3.0) * f(b)     return y", "output": "0"}
{"task": "detection", "input": "classify code:\ndef num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    >>> num_digits(0)\n    1\n    >>> num_digits(-1)\n    1\n    >>> num_digits(-123456)\n    6\n    \"\"\"\n    digits = 0\n    n = abs(n)\n    while True:\n        n = n // 10\n        digits += 1\n        if n == 0:\n            break\n    return digits", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef reshape(matrix, shape):\n    if isinstance(shape, int):\n        return batched(chain.from_iterable(matrix), shape)\n    first_dim, *dims = shape\n    scalar_stream = _flatten_tensor(matrix)\n    reshaped = reduce(batched, reversed(dims), scalar_stream)\n    return islice(reshaped, first_dim)", "output": "Change the shape of a *matrix*."}
{"task": "repair", "input": "fix bug:\ndef get_black_and_white_rgb(distance: float) -> tuple:\n    \"\"\"\n    Black&white color-coding that ignores the relative distance. The Mandelbrot\n    set is black, everything else is white.\n\n    >>> get_black_and_white_rgb(0)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(0.5)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return (255, 255, 255)", "output": "def get_black_and_white_rgb(distance: float) -> tuple:\n    \"\"\"\n    Black&white color-coding that ignores the relative distance. The Mandelbrot\n    set is black, everything else is white.\n\n    >>> get_black_and_white_rgb(0)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(0.5)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return (255, 255, 255)"}
{"task": "search", "input": "search code:\nFunction description is as follows-\n\nChoices:\n0: def naturalsize(value, binary=False, gnu=False, format=\"%.1f\"):     if gnu:         suffix = suffixes[\"gnu\"]     elif binary:         suffix = suffixes[\"binary\"]     else:         suffix = suffixes[\"decimal\"]      base = 1024 if (gnu or binary) else 1000     bytes = float(value)     abs_bytes = abs(bytes)      if abs_bytes == 1 and not gnu:         return \"%d Byte\" % bytes     elif abs_bytes < base and not gnu:         return \"%d Bytes\" % bytes     elif abs_bytes < base and gnu:         return \"%dB\" % bytes      for i, s in enumerate(suffix):         unit = base ** (i + 2)         if abs_bytes < unit and not gnu:             return (format + \" %s\") % ((base * bytes / unit), s)         elif abs_bytes < unit and gnu:             return (format + \"%s\") % ((base * bytes / unit), s)     if gnu:         return (format + \"%s\") % ((base * bytes / unit), s)     return (format + \" %s\") % ((base * bytes / unit), s)\n1: def peak(lst: list[int]) -> int:     # middle index     m = len(lst) // 2      # choose the middle 3 elements     three = lst[m - 1 : m + 2]      # if middle element is peak     if three[1] > three[0] and three[1] > three[2]:         return three[1]      # if increasing, recurse on right     elif three[0] < three[2]:         if len(lst[:m]) == 2:             m -= 1         return peak(lst[m:])      # decreasing     else:         if len(lst[:m]) == 2:             m += 1         return peak(lst[:m])\n2: def calc_profit(profit: list, weight: list, max_weight: int) -> int:     if len(profit) != len(weight):         raise ValueError(\"The length of profit and weight must be same.\")     if max_weight <= 0:         raise ValueError(\"max_weight must greater than zero.\")     if any(p < 0 for p in profit):         raise ValueError(\"Profit can not be negative.\")     if any(w < 0 for w in weight):         raise ValueError(\"Weight can not be negative.\")      # List created to store profit gained for the 1kg in case of each weight     # respectively.  Calculate and append profit/weight for each element.     profit_by_weight = [p / w for p, w in zip(profit, weight)]      # Creating a copy of the list and sorting profit/weight in ascending order     sorted_profit_by_weight = sorted(profit_by_weight)      # declaring useful variables     length = len(sorted_profit_by_weight)     limit = 0     gain = 0     i = 0      # loop till the total weight do not reach max limit e.g. 15 kg and till i<length     while limit <= max_weight and i < length:         # flag value for encountered greatest element in sorted_profit_by_weight         biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]         index = profit_by_weight.index(biggest_profit_by_weight)         profit_by_weight[index] = -1          # check if the weight encountered is less than the total weight         # encountered before.         if max_weight - limit >= weight[index]:             limit += weight[index]             # Adding profit gained for the given weight 1 ===             # weight[index]/weight[index]             gain += 1 * profit[index]         else:             # Since the weight encountered is greater than limit, therefore take the             # required number of remaining kgs and calculate profit for it.             # weight remaining / weight[index]             gain += (max_weight - limit) / weight[index] * profit[index]             break         i += 1     return gain", "output": "2"}
{"task": "detection", "input": "classify code:\ndef find_repeat(\n    matrix_g: list[list[str]], row: int, column: int, size: int\n) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all connected elements of the same type from a given position.\n\n    >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)\n    {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}\n    >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)\n    set()\n    \"\"\"\n\n    column = size - 1 - column\n    visited = set()\n    repeated = set()\n\n    if (color := matrix_g[column][row]) != \"-\":\n\n        def dfs(row_n: int, column_n: int) -> None:\n            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:\n                return\n            if (row_n, column_n) in visited:\n                return\n            visited.add((row_n, column_n))\n            if matrix_g[row_n][column_n] == color:\n                repeated.add((row_n, column_n))\n                dfs(row_n - 1, column_n)\n                dfs(row_n + 1, column_n)\n                dfs(row_n, column_n - 1)\n                dfs(row_n, column_n + 1)\n\n        dfs(column, row)\n\n    return repeated", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef _create_spd_matrix(dimension: int) -> Any:\n    rng = np.random.default_rng()\n    random_matrix = rng.normal(size=(dimension, dimension))\n    spd_matrix = np.dot(random_matrix, random_matrix.T)\n    assert _is_matrix_spd(spd_matrix)\n    return spd_matrix", "output": "Returns a symmetric positive definite matrix given a dimension."}
{"task": "repair", "input": "fix bug:\ndef get_valid_pos(position: Tuple[int], n: int) -> List[Tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "def get_valid_pos(position: tuple[int], n: int) -> list[tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions"}
{"task": "search", "input": "search code:\nThird method: Support vector regressor\n\nChoices:\n0: def support_vector_regressor(x_train: list, x_test: list, train_user: list) -> float:     regressor = SVR(kernel=\"rbf\", C=1, gamma=0.1, epsilon=0.1)     regressor.fit(x_train, train_user)     y_pred = regressor.predict(x_test)     return float(y_pred[0])\n1: def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:     result = [0] * (gon_side * 3)     result[0:3] = perm[0:3]     perm.append(perm[1])      magic_number = 1 if gon_side < 5 else 2      for i in range(1, len(perm) // 3 + magic_number):         result[3 * i] = perm[2 * i + 1]         result[3 * i + 1] = result[3 * i - 1]         result[3 * i + 2] = perm[2 * i + 2]      return result\n2: def triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:     for triplet in permutations(arr, 3):         if sum(triplet) == target:             return tuple(sorted(triplet))     return (0, 0, 0)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef reverse_letters(sentence: str, length: int = 0) -> str:\n    \"\"\"\n    Reverse all words that are longer than the given length of characters in a sentence.\n    If unspecified, length is taken as 0\n\n    >>> reverse_letters(\"Hey wollef sroirraw\", 3)\n    'Hey fellow warriors'\n    >>> reverse_letters(\"nohtyP is nohtyP\", 2)\n    'Python is Python'\n    >>> reverse_letters(\"1 12 123 1234 54321 654321\", 0)\n    '1 21 321 4321 12345 123456'\n    >>> reverse_letters(\"racecar\")\n    'racecar'\n    \"\"\"\n    return \" \".join(\n        \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()\n    )", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef quick_sort(collection: list) -> list:\n    # Base case: if the collection has 0 or 1 elements, it is already sorted\n    if len(collection) < 2:\n        return collection\n\n    # Randomly select a pivot index and remove the pivot element from the collection\n    pivot_index = randrange(len(collection))\n    pivot = collection.pop(pivot_index)\n\n    # Partition the remaining elements into two groups: lesser or equal, and greater\n    lesser = [item for item in collection if item <= pivot]\n    greater = [item for item in collection if item > pivot]\n\n    # Recursively sort the lesser and greater groups, and combine with the pivot\n    return [*quick_sort(lesser), pivot, *quick_sort(greater)]", "output": "A pure Python implementation of quicksort algorithm."}
{"task": "repair", "input": "fix bug:\ndef longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [5, 7]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = array[i:]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq"}
{"task": "summary", "input": "summarize code:\ndef _is_matrix_spd(matrix: np.ndarray) -> bool:\n    # Ensure matrix is square.\n    assert np.shape(matrix)[0] == np.shape(matrix)[1]\n\n    # If matrix not symmetric, exit right away.\n    if np.allclose(matrix, matrix.T) is False:\n        return False\n\n    # Get eigenvalues and eignevectors for a symmetric matrix.\n    eigen_values, _ = np.linalg.eigh(matrix)\n\n    # Check sign of all eigenvalues.\n    # np.all returns a value of type np.bool_\n    return bool(np.all(eigen_values > 0))", "output": "Returns True if input matrix is symmetric positive definite."}
{"task": "detection", "input": "classify code:\ndef check(binary: List[str]) -> List[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20Â°C: bulk_modulus= 2.15MPa, density=998kg/mÂ³\n    Example 2 --> Mercury 20Â°C: bulk_modulus= 28.5MPa, density=13600kg/mÂ³\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5", "output": "def speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20Â°C: bulk_modulus= 2.15MPa, density=998kg/mÂ³\n    Example 2 --> Mercury 20Â°C: bulk_modulus= 28.5MPa, density=13600kg/mÂ³\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5"}
{"task": "search", "input": "search code:\nPrints the multiplication table of a given number till the given number of terms\n\nChoices:\n0: def multiplication_table(number: int, number_of_terms: int) -> str:     return \"\\n\".join(         f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)     )\n1: def split_into(iterable, sizes):     # convert the iterable argument into an iterator so its contents can     # be consumed by islice in case it is a generator     it = iter(iterable)      for size in sizes:         if size is None:             yield list(it)             return         else:             yield list(islice(it, size))\n2: def combinations(n: int, k: int) -> int:      # If either of the conditions are true, the function is being asked     # to calculate a factorial of a negative number, which is not possible     if n < k or k < 0:         raise ValueError(\"Please enter positive integers for n and k where n >= k\")     res = 1     for i in range(k):         res *= n - i         res //= i + 1     return res", "output": "0"}
{"task": "detection", "input": "classify code:\ndef modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2", "output": "def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2"}
{"task": "summary", "input": "summarize code:\ndef select(\n    parent_1: tuple[str, float],\n    population_score: list[tuple[str, float]],\n    genes: list[str],\n) -> list[str]:\n    pop = []\n    # Generate more children proportionally to the fitness score.\n    child_n = int(parent_1[1] * 100) + 1\n    child_n = 10 if child_n >= 10 else child_n\n    for _ in range(child_n):\n        parent_2 = population_score[random.randint(0, N_SELECTED)][0]\n\n        child_1, child_2 = crossover(parent_1[0], parent_2)\n        # Append new string to the population list.\n        pop.append(mutate(child_1, genes))\n        pop.append(mutate(child_2, genes))\n    return pop", "output": "Select the second parent and generate new population"}
{"task": "search", "input": "search code:\nFind the isolated node in the graph\n\nChoices:\n0: def solution(n: int = 1000) -> int:     return fibonacci_digits_index(n)\n1: def find_isolated_nodes(graph):     isolated = []     for node in graph:         if not graph[node]:             isolated.append(node)     return isolated\n2: def solution() -> int:     script_dir = os.path.dirname(os.path.realpath(__file__))     triangle_path = os.path.join(script_dir, \"triangle.txt\")      with open(triangle_path) as in_file:         triangle = [[int(i) for i in line.split()] for line in in_file]      while len(triangle) != 1:         last_row = triangle.pop()         curr_row = triangle[-1]         for j in range(len(last_row) - 1):             curr_row[j] += max(last_row[j], last_row[j + 1])     return triangle[0][0]", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp", "output": "def tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp"}
{"task": "search", "input": "search code:\nYields elements in order, ignoring serial duplicates\n\nChoices:\n0: def solution() -> int:     return sum(compute_truncated_primes(11))\n1: def solution(num_turns: int = 15) -> int:     total_prob: float = 0.0     prob: float     num_blue: int     num_red: int     ind: int     col: int     series: tuple[int, ...]      for series in product(range(2), repeat=num_turns):         num_blue = series.count(1)         num_red = num_turns - num_blue         if num_red >= num_blue:             continue         prob = 1.0         for ind, col in enumerate(series, 2):             if col == 0:                 prob *= (ind - 1) / ind             else:                 prob *= 1 / ind          total_prob += prob      return int(1 / total_prob)\n2: def unique_justseen(iterable, key=None):     if key is None:         return map(itemgetter(0), groupby(iterable))      return map(next, map(itemgetter(1), groupby(iterable, key)))", "output": "2"}
{"task": "detection", "input": "classify code:\ndef calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef power(a: int, b: int) -> float:\n    if b < 0:\n        return 1 / actual_power(a, -b)\n    return actual_power(a, b)", "output": ":param a: The base (integer)."}
{"task": "search", "input": "search code:\nCalculate the waiting time of each processes\n\nChoices:\n0: def calculate_waitingtime(     arrival_time: list[int], burst_time: list[int], no_of_processes: int ) -> list[int]:     remaining_time = [0] * no_of_processes     waiting_time = [0] * no_of_processes     # Copy the burst time into remaining_time[]     for i in range(no_of_processes):         remaining_time[i] = burst_time[i]      complete = 0     increment_time = 0     minm = 999999999     short = 0     check = False      # Process until all processes are completed     while complete != no_of_processes:         for j in range(no_of_processes):             if (                 arrival_time[j] <= increment_time                 and remaining_time[j] > 0                 and remaining_time[j] < minm             ):                 minm = remaining_time[j]                 short = j                 check = True          if not check:             increment_time += 1             continue         remaining_time[short] -= 1          minm = remaining_time[short]         if minm == 0:             minm = 999999999          if remaining_time[short] == 0:             complete += 1             check = False              # Find finish time of current process             finish_time = increment_time + 1              # Calculate waiting time             finar = finish_time - arrival_time[short]             waiting_time[short] = finar - burst_time[short]              waiting_time[short] = max(waiting_time[short], 0)          # Increment time         increment_time += 1     return waiting_time\n1: def local_weight(     point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float ) -> np.ndarray:     weight_mat = weight_matrix(point, x_train, tau)     weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (         x_train.T @ weight_mat @ y_train.T     )      return weight\n2: def ceil(x: float) -> int:     return int(x) if x - int(x) <= 0 else int(x) + 1", "output": "0"}
{"task": "detection", "input": "classify code:\ndef elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef get_cluster(nodes):\n    cluster = {}\n    for key, value in nodes.items():\n        cluster.setdefault(key.count(\"1\"), {})[key] = value\n    return cluster", "output": "Returns cluster"}
{"task": "repair", "input": "fix bug:\ndef generate_key(message: str, key: str) -> str:\n    \"\"\"\n    >>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n    'SECRETSECRETSECRE'\n    \"\"\"\n    x = len(message)\n    i = 0\n    while True:\n        if x == i:\n            i = 0\n        if len(key) == len(message):\n            break\n        key += key[i]\n        i += 1\n    return key", "output": "def generate_key(message: str, key: str) -> str:\n    \"\"\"\n    >>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n    'SECRETSECRETSECRE'\n    \"\"\"\n    x = len(message)\n    i = 0\n    while True:\n        if x == i:\n            i = 0\n        if len(key) == len(message):\n            break\n        key += key[i]\n        i += 1\n    return key"}
{"task": "detection", "input": "classify code:\ndef split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n\n    >>> split(\";abbb;;c;\", separator=';')\n    ['', 'abbb', '', 'c', '']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]", "output": "def largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]"}
{"task": "search", "input": "search code:\nAn extension of :func:`itertools.groupby` that can apply transformations\n\nChoices:\n0: def breadth_first_search(     level: list[int],     parent: list[list[int]],     max_node: int,     graph: dict[int, list[int]],     root: int = 1, ) -> tuple[list[int], list[list[int]]]:     level[root] = 0     q: Queue[int] = Queue(maxsize=max_node)     q.put(root)     while q.qsize() != 0:         u = q.get()         for v in graph[u]:             if level[v] == -1:                 level[v] = level[u] + 1                 q.put(v)                 parent[0][v] = u     return level, parent\n1: def groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):     ret = groupby(iterable, keyfunc)     if valuefunc:         ret = ((k, map(valuefunc, g)) for k, g in ret)     if reducefunc:         ret = ((k, reducefunc(g)) for k, g in ret)      return ret\n2: def data_safety_checker(list_vote: list, actual_result: float) -> bool:     safe = 0     not_safe = 0      if not isinstance(actual_result, float):         raise TypeError(\"Actual result should be float. Value passed is a list\")      for i in list_vote:         if i > actual_result:             safe = not_safe + 1         elif abs(abs(i) - abs(actual_result)) <= 0.1:             safe += 1         else:             not_safe += 1     return safe > not_safe", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef open_knight_tour(n: int) -> list[list[int]]:\n\n    board = [[0 for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 1\n            if open_knight_tour_helper(board, (i, j), 1):\n                return board\n            board[i][j] = 0\n\n    msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"\n    raise ValueError(msg)", "output": "Find the solution for the knight tour problem for a board of size n. Raises"}
{"task": "search", "input": "search code:\nPseudo-Code\n\nChoices:\n0: def data_safety_checker(list_vote: list, actual_result: float) -> bool:     safe = 0     not_safe = 0      if not isinstance(actual_result, float):         raise TypeError(\"Actual result should be float. Value passed is a list\")      for i in list_vote:         if i > actual_result:             safe = not_safe + 1         elif abs(abs(i) - abs(actual_result)) <= 0.1:             safe += 1         else:             not_safe += 1     return safe > not_safe\n1: def solution(n: int = 7) -> int:     pandigital_str = \"\".join(str(i) for i in range(1, n + 1))     perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]     pandigitals = [num for num in perm_list if is_prime(num)]     return max(pandigitals) if pandigitals else 0\n2: def util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:      # Base Case     if curr_ind == len(graph):         # return whether path exists between current and starting vertices         return graph[path[curr_ind - 1]][path[0]] == 1      # Recursive Step     for next_ver in range(len(graph)):         if valid_connection(graph, next_ver, curr_ind, path):             # Insert current vertex  into path as next transition             path[curr_ind] = next_ver             # Validate created path             if util_hamilton_cycle(graph, path, curr_ind + 1):                 return True             # Backtrack             path[curr_ind] = -1     return False", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef pancake_sort(arr):\n    \"\"\"Sort Array with Pancake Sort.\n    :param arr: Collection containing comparable items\n    :return: Collection ordered in ascending order of items\n    Examples:\n    >>> pancake_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pancake_sort([])\n    []\n    >>> pancake_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    cur = len(arr)\n    while cur > 1:\n        # Find the maximum number in arr\n        mi = arr.index(max(arr[0:cur]))\n        # Reverse from 0 to mi\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\n        # Reverse whole list\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\n        cur -= 1\n    return arr", "output": "def pancake_sort(arr):\n    \"\"\"Sort Array with Pancake Sort.\n    :param arr: Collection containing comparable items\n    :return: Collection ordered in ascending order of items\n    Examples:\n    >>> pancake_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pancake_sort([])\n    []\n    >>> pancake_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    cur = len(arr)\n    while cur > 1:\n        # Find the maximum number in arr\n        mi = arr.index(max(arr[0:cur]))\n        # Reverse from 0 to mi\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\n        # Reverse whole list\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\n        cur -= 1\n    return arr"}
{"task": "summary", "input": "summarize code:\ndef save_image(image_url: str, image_title: str) -> None:\n    image = httpx.get(image_url, headers=headers, timeout=10)\n    with open(image_title, \"wb\") as file:\n        file.write(image.content)", "output": "Saves the image of anime character"}
{"task": "detection", "input": "classify code:\ndef n31(a: int) -> tuple[list[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef decompress_data(data_bits: str) -> str:\n    lexicon = {\"0\": \"0\", \"1\": \"1\"}\n    result, curr_string = \"\", \"\"\n    index = len(lexicon)\n\n    for i in range(len(data_bits)):\n        curr_string += data_bits[i]\n        if curr_string not in lexicon:\n            continue\n\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n        lexicon[curr_string] = last_match_id + \"0\"\n\n        if math.log2(index).is_integer():\n            new_lex = {}\n            for curr_key in list(lexicon):\n                new_lex[\"0\" + curr_key] = lexicon.pop(curr_key)\n            lexicon = new_lex\n\n        lexicon[bin(index)[2:]] = last_match_id + \"1\"\n        index += 1\n        curr_string = \"\"\n    return result", "output": "Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm"}
{"task": "repair", "input": "fix bug:\ndef move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:\n    \"\"\"\n    Shifts all columns leftward when an entire column becomes empty.\n\n    >>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2)\n    [['A', '-'], ['-', '-'], ['-', 'C']]\n    \"\"\"\n\n    empty_columns = []\n\n    for column in range(size - 1, -1, -1):\n        if all(matrix_g[row][column] == \"-\" for row in range(size)):\n            empty_columns.append(column)\n\n    for column in empty_columns:\n        for col in range(column + 1, size):\n            for row in range(size):\n                matrix_g[row][col - 1] = matrix_g[row][col]\n        for row in range(size):\n            matrix_g[row][-1] = \"-\"\n\n    return matrix_g", "output": "def move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:\n    \"\"\"\n    Shifts all columns leftward when an entire column becomes empty.\n\n    >>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2)\n    [['A', '-'], ['-', '-'], ['-', 'C']]\n    \"\"\"\n\n    empty_columns = []\n\n    for column in range(size - 1, -1, -1):\n        if all(matrix_g[row][column] == \"-\" for row in range(size)):\n            empty_columns.append(column)\n\n    for column in empty_columns:\n        for col in range(column + 1, size):\n            for row in range(size):\n                matrix_g[row][col - 1] = matrix_g[row][col]\n        for row in range(size):\n            matrix_g[row][-1] = \"-\"\n\n    return matrix_g"}
{"task": "search", "input": "search code:\nGenerate a gon_side-gon ring from a permutation state\n\nChoices:\n0: def duplicates_everseen(iterable, key=None):     seen_set = set()     seen_list = []     use_key = key is not None      for element in iterable:         k = key(element) if use_key else element         try:             if k not in seen_set:                 seen_set.add(k)             else:                 yield element         except TypeError:             if k not in seen_list:                 seen_list.append(k)             else:                 yield element\n1: def gaussian_elimination(     coefficients: NDArray[float64], vector: NDArray[float64] ) -> NDArray[float64]:     # coefficients must to be a square matrix so we need to check first     rows, columns = np.shape(coefficients)     if rows != columns:         return np.array((), dtype=float)      # augmented matrix     augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)     augmented_mat = augmented_mat.astype(\"float64\")      # scale the matrix leaving it triangular     for row in range(rows - 1):         pivot = augmented_mat[row, row]         for col in range(row + 1, columns):             factor = augmented_mat[col, row] / pivot             augmented_mat[col, :] -= factor * augmented_mat[row, :]      x = retroactive_resolution(         augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]     )      return x\n2: def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:     result = [0] * (gon_side * 3)     result[0:3] = perm[0:3]     perm.append(perm[1])      magic_number = 1 if gon_side < 5 else 2      for i in range(1, len(perm) // 3 + magic_number):         result[3 * i] = perm[2 * i + 1]         result[3 * i + 1] = result[3 * i - 1]         result[3 * i + 2] = perm[2 * i + 2]      return result", "output": "2"}
{"task": "detection", "input": "classify code:\ndef decimal_to_binary(no_of_variable: int, minterms: list[float]) -> list[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef decimal_to_negative_base_2(num: int) -> int:\n    \"\"\"\n    This function returns the number negative base 2\n        of the decimal number of the input data.\n\n    Args:\n        int: The decimal number to convert.\n\n    Returns:\n        int: The negative base 2 number.\n\n    Examples:\n        >>> decimal_to_negative_base_2(0)\n        0\n        >>> decimal_to_negative_base_2(-19)\n        111101\n        >>> decimal_to_negative_base_2(4)\n        100\n        >>> decimal_to_negative_base_2(7)\n        11011\n    \"\"\"\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)", "output": "def decimal_to_negative_base_2(num: int) -> int:\n    \"\"\"\n    This function returns the number negative base 2\n        of the decimal number of the input data.\n\n    Args:\n        int: The decimal number to convert.\n\n    Returns:\n        int: The negative base 2 number.\n\n    Examples:\n        >>> decimal_to_negative_base_2(0)\n        0\n        >>> decimal_to_negative_base_2(-19)\n        111101\n        >>> decimal_to_negative_base_2(4)\n        100\n        >>> decimal_to_negative_base_2(7)\n        11011\n    \"\"\"\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)"}
{"task": "detection", "input": "classify code:\ndef recur_fibo(n):\n    if n <= 1:\n        return n\n    else:\n        (recur_fibo(n - 1) + recur_fibo(n - 2))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculate the simple moving average (SMA) for some given time series data.\n\nChoices:\n0: def compute_transform_tables(     source_string: str,     destination_string: str,     copy_cost: int,     replace_cost: int,     delete_cost: int,     insert_cost: int, ) -> tuple[list[list[int]], list[list[str]]]:     source_seq = list(source_string)     destination_seq = list(destination_string)     len_source_seq = len(source_seq)     len_destination_seq = len(destination_seq)     costs = [         [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]     ops = [         [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]      for i in range(1, len_source_seq + 1):         costs[i][0] = i * delete_cost         ops[i][0] = f\"D{source_seq[i - 1]}\"      for i in range(1, len_destination_seq + 1):         costs[0][i] = i * insert_cost         ops[0][i] = f\"I{destination_seq[i - 1]}\"      for i in range(1, len_source_seq + 1):         for j in range(1, len_destination_seq + 1):             if source_seq[i - 1] == destination_seq[j - 1]:                 costs[i][j] = costs[i - 1][j - 1] + copy_cost                 ops[i][j] = f\"C{source_seq[i - 1]}\"             else:                 costs[i][j] = costs[i - 1][j - 1] + replace_cost                 ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])              if costs[i - 1][j] + delete_cost < costs[i][j]:                 costs[i][j] = costs[i - 1][j] + delete_cost                 ops[i][j] = f\"D{source_seq[i - 1]}\"              if costs[i][j - 1] + insert_cost < costs[i][j]:                 costs[i][j] = costs[i][j - 1] + insert_cost                 ops[i][j] = f\"I{destination_seq[j - 1]}\"      return costs, ops\n1: def simple_moving_average(     data: Sequence[float], window_size: int ) -> list[float | None]:     if window_size < 1:         raise ValueError(\"Window size must be a positive integer\")      sma: list[float | None] = []      for i in range(len(data)):         if i < window_size - 1:             sma.append(None)  # SMA not available for early data points         else:             window = data[i - window_size + 1 : i + 1]             sma_value = sum(window) / window_size             sma.append(sma_value)     return sma\n2: def solution(n: int = 4000000) -> int:      if n <= 1:         return 0     a = 0     b = 2     count = 0     while 4 * b + a <= n:         a, b = b, 4 * b + a         count += a     return count + b", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef prune(itemset: list, candidates: list, length: int) -> list:\n    itemset_counter = Counter(tuple(item) for item in itemset)\n    pruned = []\n    for candidate in candidates:\n        is_subsequence = True\n        for item in candidate:\n            item_tuple = tuple(item)\n            if (\n                item_tuple not in itemset_counter\n                or itemset_counter[item_tuple] < length - 1\n            ):\n                is_subsequence = False\n                break\n        if is_subsequence:\n            pruned.append(candidate)\n    return pruned", "output": "Prune candidate itemsets that are not frequent."}
{"task": "summary", "input": "summarize code:\ndef ind_reactance(\n    inductance: float, frequency: float, reactance: float\n) -> dict[str, float]:\n\n    if (inductance, frequency, reactance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if inductance < 0:\n        raise ValueError(\"Inductance cannot be negative\")\n    if frequency < 0:\n        raise ValueError(\"Frequency cannot be negative\")\n    if reactance < 0:\n        raise ValueError(\"Inductive reactance cannot be negative\")\n    if inductance == 0:\n        return {\"inductance\": reactance / (2 * pi * frequency)}\n    elif frequency == 0:\n        return {\"frequency\": reactance / (2 * pi * inductance)}\n    elif reactance == 0:\n        return {\"reactance\": 2 * pi * frequency * inductance}\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")", "output": "Calculate inductive reactance, frequency or inductance from two given electrical"}
{"task": "repair", "input": "fix bug:\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)"}
{"task": "search", "input": "search code:\n- img_list <type: list>: list of all images\n\nChoices:\n0: def _batched(iterable, n, *, strict=False):  # pragma: no cover     if n < 1:         raise ValueError('n must be at least one')     iterator = iter(iterable)     while batch := tuple(islice(iterator, n)):         if strict and len(batch) != n:             raise ValueError('batched(): incomplete batch')         yield batch\n1: def update_image_and_anno(     img_list: list, anno_list: list, flip_type: int = 1 ) -> tuple[list, list, list]:     new_annos_lists = []     path_list = []     new_imgs_list = []     for idx in range(len(img_list)):         new_annos = []         path = img_list[idx]         path_list.append(path)         img_annos = anno_list[idx]         img = cv2.imread(path)         if flip_type == 1:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 x_center_new = 1 - bbox[1]                 new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])         elif flip_type == 0:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 y_center_new = 1 - bbox[2]                 new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])         new_annos_lists.append(new_annos)         new_imgs_list.append(new_img)     return new_imgs_list, new_annos_lists, path_list\n2: def longest_common_subsequence(x: str, y: str):     # find the length of strings      assert x is not None     assert y is not None      m = len(x)     n = len(y)      # declaring the array for storing the dp values     dp = [[0] * (n + 1) for _ in range(m + 1)]      for i in range(1, m + 1):         for j in range(1, n + 1):             match = 1 if x[i - 1] == y[j - 1] else 0              dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)      seq = \"\"     i, j = m, n     while i > 0 and j > 0:         match = 1 if x[i - 1] == y[j - 1] else 0          if dp[i][j] == dp[i - 1][j - 1] + match:             if match == 1:                 seq = x[i - 1] + seq             i -= 1             j -= 1         elif dp[i][j] == dp[i - 1][j]:             i -= 1         else:             j -= 1      return dp[m][n], seq", "output": "1"}
{"task": "detection", "input": "classify code:\ndef sum_reverse(n: int) -> int:\n    \"\"\"\n    Returns the sum of n and reverse of n.\n    >>> sum_reverse(123)\n    444\n    >>> sum_reverse(3478)\n    12221\n    >>> sum_reverse(12)\n    33\n    \"\"\"\n    return int(n) + int(str(n)[::-1])", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef least_common_multiple_slow(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n\n    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple\n\n    >>> least_common_multiple_slow(5, 2)\n    10\n    >>> least_common_multiple_slow(12, 76)\n    228\n    \"\"\"\n    max_num = first_num if first_num >= second_num else second_num\n    common_mult = max_num\n    while (common_mult % first_num > 0) or (common_mult % second_num > 0):\n        common_mult += max_num\n    return common_mult", "output": "def least_common_multiple_slow(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n\n    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple\n\n    >>> least_common_multiple_slow(5, 2)\n    10\n    >>> least_common_multiple_slow(12, 76)\n    228\n    \"\"\"\n    max_num = first_num if first_num >= second_num else second_num\n    common_mult = max_num\n    while (common_mult % first_num > 0) or (common_mult % second_num > 0):\n        common_mult += max_num\n    return common_mult"}
{"task": "summary", "input": "summarize code:\ndef transpose(it):\n    return zip(*it, strict=True)", "output": "Swap the rows and columns of the input matrix."}
{"task": "search", "input": "search code:\nEnciphers a message given a cipher map.\n\nChoices:\n0: def encipher(message: str, cipher_map: dict[str, str]) -> str:     return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())\n1: def try_key(ciphertext: list[int], key: tuple[int, ...]) -> str | None:     decoded: str = \"\"     keychar: int     cipherchar: int     decodedchar: int      for keychar, cipherchar in zip(cycle(key), ciphertext):         decodedchar = cipherchar ^ keychar         if decodedchar not in VALID_INTS:             return None         decoded += chr(decodedchar)      return decoded\n2: def is_combination_valid(combination):     return (         int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))         == int(\"\".join(combination[5:9]))     ) or (         int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))         == int(\"\".join(combination[5:9]))     )", "output": "0"}
{"task": "search", "input": "search code:\nThis method is recursive starting from (i, j) and going in one of four directions:\n\nChoices:\n0: def run_maze(     maze: list[list[int]],     i: int,     j: int,     destination_row: int,     destination_column: int,     solutions: list[list[int]], ) -> bool:     size = len(maze)     # Final check point.     if i == destination_row and j == destination_column and maze[i][j] == 0:         solutions[i][j] = 0         return True      lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds     upper_flag = (i < size) and (j < size)  # Check upper bounds      if lower_flag and upper_flag:         # check for already visited and block points.         block_flag = (solutions[i][j]) and (not maze[i][j])         if block_flag:             # check visited             solutions[i][j] = 0              # check for directions             if (                 run_maze(maze, i + 1, j, destination_row, destination_column, solutions)                 or run_maze(                     maze, i, j + 1, destination_row, destination_column, solutions                 )                 or run_maze(                     maze, i - 1, j, destination_row, destination_column, solutions                 )                 or run_maze(                     maze, i, j - 1, destination_row, destination_column, solutions                 )             ):                 return True              solutions[i][j] = 1             return False     return False\n1: def catalan_number(node_count: int) -> int:     return binomial_coefficient(2 * node_count, node_count) // (node_count + 1)\n2: def solution(limit: int = 1000000) -> int:     answer = 0      for outer_width in range(3, (limit // 4) + 2):         if outer_width**2 > limit:             hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)         else:             hole_width_lower_bound = 1         if (outer_width - hole_width_lower_bound) % 2:             hole_width_lower_bound += 1          answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1      return answer", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef is_ip_v4_address_valid(ip: str) -> bool:\n    octets = ip.split(\".\")\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        if not octet.isdigit():\n            return False\n\n        number = int(octet)\n        if len(str(number)) != len(octet):\n            return False\n\n        if not 0 <= number <= 255:\n            return False\n\n    return True", "output": "print \"Valid IP address\" If IP is valid."}
{"task": "repair", "input": "fix bug:\ndef f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2", "output": "def f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2"}
{"task": "detection", "input": "classify code:\ndef solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef rgb_to_gray(rgb: np.ndarray) -> np.ndarray:\n    r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]\n    return 0.2989 * r + 0.5870 * g + 0.1140 * b", "output": "Return gray image from rgb image"}
{"task": "detection", "input": "classify code:\ndef stalin_sort(sequence: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Stalin sort algorithm.\n\n    >>> stalin_sort([4, 3, 5, 2, 1, 7])\n    [4, 5, 7]\n\n    >>> stalin_sort([1, 2, 3, 4])\n    [1, 2, 3, 4]\n\n    >>> stalin_sort([4, 5, 5, 2, 3])\n    [4, 5, 5]\n\n    >>> stalin_sort([6, 11, 12, 4, 1, 5])\n    [6, 11, 12]\n\n    >>> stalin_sort([5, 0, 4, 3])\n    [5]\n\n    >>> stalin_sort([5, 4, 3, 2, 1])\n    [5]\n\n    >>> stalin_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> stalin_sort([1, 2, 8, 7, 6])\n    [1, 2, 8]\n    \"\"\"\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result", "output": "CORRECT"}
{"task": "search", "input": "search code:\nreturns n-th term of sequence\n\nChoices:\n0: def local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:     center = image[x_coordinate][y_coordinate]     powers = [1, 2, 4, 8, 16, 32, 64, 128]      # skip get_neighbors_pixel if center is null     if center is None:         return 0      # Starting from the top right, assigning value to pixels clockwise     binary_values = [         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),         get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),     ]      # Converting the binary value to decimal.     return sum(         binary_value * power for binary_value, power in zip(binary_values, powers)     )\n1: def decimal_to_binary_recursive_helper(decimal: int) -> str:     decimal = int(decimal)     if decimal in (0, 1):  # Exit cases for the recursion         return str(decimal)     div, mod = divmod(decimal, 2)     return decimal_to_binary_recursive_helper(div) + str(mod)\n2: def solution(n: int = 10**15) -> int:      digits = [1]     i = 1     dn = 0     while True:         _diff, terms_jumped = next_term(digits, 20, i + dn, n)         dn += terms_jumped         if dn == n - i:             break      a_n = 0     for j in range(len(digits)):         a_n += digits[j] * 10**j     return a_n", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    -1\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return -1\n    else:\n        return \"\".join(l1)", "output": "def compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    'X'\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return \"X\"\n    else:\n        return \"\".join(l1)"}
{"task": "summary", "input": "summarize code:\ndef sigmoid_linear_unit(vector: np.ndarray) -> np.ndarray:\n    return vector * sigmoid(vector)", "output": "Implements the Sigmoid Linear Unit (SiLU) or swish function"}
{"task": "detection", "input": "classify code:\ndef bisect_left(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "BUGGY"}
{"task": "search", "input": "search code:\nGenerates all possible combinations of k numbers out of 1 ... n using backtracking.\n\nChoices:\n0: def _running_median_minheap_only(iterator):  # pragma: no cover     \"Backport of non-windowed running_median() for Python 3.13 and prior.\"      read = iterator.__next__     lo = []  # max-heap (actually a minheap with negated values)     hi = []  # min-heap (same size as or one smaller than lo)      with suppress(StopIteration):         while True:             heappush(lo, -heappushpop(hi, read()))             yield -lo[0]              heappush(hi, -heappushpop(lo, -read()))             yield (hi[0] - lo[0]) / 2\n1: def generate_all_combinations(n: int, k: int) -> list[list[int]]:     if k < 0:         raise ValueError(\"k must not be negative\")     if n < 0:         raise ValueError(\"n must not be negative\")      result: list[list[int]] = []     create_all_state(1, n, k, [], result)     return result\n2: def split_punct_ws(text):     return [w for w in _punct_re.split(text) if w]", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef lin_search(left: int, right: int, array: List[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1", "output": "def lin_search(left: int, right: int, array: list[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1"}
{"task": "summary", "input": "summarize code:\ndef make_tree_nine() -> Node:\n    tree = Node(1)\n    tree.left = Node(2)\n    tree.right = Node(3)\n    tree.left.left = Node(4)\n    tree.left.right = Node(5)\n    tree.right.right = Node(6)\n    tree.left.left.left = Node(7)\n    tree.left.left.right = Node(8)\n    tree.left.right.right = Node(9)\n    return tree", "output": "Return a binary tree with 9 nodes that looks like this:"}
{"task": "repair", "input": "fix bug:\ndef calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "output": "def calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r"}
{"task": "detection", "input": "classify code:\ndef scaling(scaling_factor: float) -> List[List[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns cluster\n\nChoices:\n0: def _count_cross_inversions(p, q):      r = []     i = j = num_inversion = 0     while i < len(p) and j < len(q):         if p[i] > q[j]:             # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)             # These are all inversions. The claim emerges from the             # property that P is sorted.             num_inversion += len(p) - i             r.append(q[j])             j += 1         else:             r.append(p[i])             i += 1      if i < len(p):         r.extend(p[i:])     else:         r.extend(q[j:])      return r, num_inversion\n1: def get_cluster(nodes):     cluster = {}     for key, value in nodes.items():         cluster.setdefault(key.count(\"1\"), {})[key] = value     return cluster\n2: def intword(value, format=\"%.1f\"):     try:         value = int(value)     except (TypeError, ValueError):         return value      if value < powers[0]:         return str(value)     for ordinal, power in enumerate(powers[1:], 1):         if value < power:             chopped = value / float(powers[ordinal - 1])             if float(format % chopped) == float(10**3):                 chopped = value / float(powers[ordinal])                 singular, plural = human_powers[ordinal]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped             else:                 singular, plural = human_powers[ordinal - 1]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped     return str(value)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    \"\"\"\n    Implements the Damerau-Levenshtein distance algorithm that measures\n    the edit distance between two strings.\n\n    Parameters:\n        first_string: The first string to compare\n        second_string: The second string to compare\n\n    Returns:\n        distance: The edit distance between the first and second strings\n\n    >>> damerau_levenshtein_distance(\"cat\", \"cut\")\n    1\n    >>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n    3\n    >>> damerau_levenshtein_distance(\"hello\", \"world\")\n    4\n    >>> damerau_levenshtein_distance(\"book\", \"back\")\n    2\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    \"\"\"\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]", "output": "def damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    \"\"\"\n    Implements the Damerau-Levenshtein distance algorithm that measures\n    the edit distance between two strings.\n\n    Parameters:\n        first_string: The first string to compare\n        second_string: The second string to compare\n\n    Returns:\n        distance: The edit distance between the first and second strings\n\n    >>> damerau_levenshtein_distance(\"cat\", \"cut\")\n    1\n    >>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n    3\n    >>> damerau_levenshtein_distance(\"hello\", \"world\")\n    4\n    >>> damerau_levenshtein_distance(\"book\", \"back\")\n    2\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    \"\"\"\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]"}
{"task": "detection", "input": "classify code:\ndef get_valid_pos(position: tuple[int], n: int) -> list[tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCalculate the area of a circle.\n\nChoices:\n0: def printboard(board: list[list[int]]) -> None:     for i in range(len(board)):         for j in range(len(board)):             if board[i][j] == 1:                 print(\"Q\", end=\" \")  # Queen is present             else:                 print(\".\", end=\" \")  # Empty cell         print()\n1: def median(matrix: list[list[int]]) -> int:     # Flatten the matrix into a sorted 1D list     linear = sorted(num for row in matrix for num in row)      # Calculate the middle index     mid = (len(linear) - 1) // 2      # Return the median     return linear[mid]\n2: def area_circle(radius: float) -> float:     if radius < 0:         raise ValueError(\"area_circle() only accepts non-negative values\")     return pi * radius**2", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef split_at(iterable, pred, maxsplit=-1, keep_separator=False):\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item):\n            yield buf\n            if keep_separator:\n                yield [item]\n            if maxsplit == 1:\n                yield list(it)\n                return\n            buf = []\n            maxsplit -= 1\n        else:\n            buf.append(item)\n    yield buf", "output": "Yield lists of items from *iterable*, where each list is delimited by"}
{"task": "detection", "input": "classify code:\ndef minor(matrix: list[list], row: int, column: int) -> list[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nGiven a list of possible decoded messages, narrow down the possibilities\n\nChoices:\n0: def polynomial_derivative(coefficients):     n = len(coefficients)     powers = reversed(range(1, n))     return list(map(mul, coefficients, powers))\n1: def filter_common_word(possibles: list[str], common_word: str) -> list[str]:     return [possible for possible in possibles if common_word in possible.lower()]\n2: def first_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value", "output": "Utility-function to check that two hsv-colors are approximately equal"}
{"task": "repair", "input": "fix bug:\ndef abs_max(x: List[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j", "output": "def abs_max(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j"}
{"task": "summary", "input": "summarize code:\ndef is_valid(\n    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool\n) -> bool:\n    for i in range(len(word)):\n        if vertical:\n            if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":\n                return False\n        elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":\n            return False\n    return True", "output": "Check if a word can be placed at the given position."}
{"task": "detection", "input": "classify code:\ndef knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef dp_count(S, m, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 3, 4)\n    4\n    >>> dp_count([1, 2, 3], 3, 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 4, 10)\n    5\n    >>> dp_count([10], 1, 99)\n    0\n    >>> dp_count([4, 5, 6], 3, 0)\n    1\n    \"\"\"\n\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]", "output": "def dp_count(S, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 4)\n    4\n    >>> dp_count([1, 2, 3], 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 10)\n    5\n    >>> dp_count([10], 99)\n    0\n    >>> dp_count([4, 5, 6], 0)\n    1\n    >>> dp_count([1, 2, 3], -5)\n    0\n    \"\"\"\n    if n < 0:\n        return 0\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]"}
{"task": "search", "input": "search code:\nImplement sin function.\n\nChoices:\n0: def inspect_formatargspec(         args, varargs=None, varkw=None, defaults=None,         kwonlyargs=(), kwonlydefaults={}, annotations={},         formatarg=str,         formatvarargs=lambda name: '*' + name,         formatvarkw=lambda name: '**' + name,         formatvalue=lambda value: '=' + repr(value),         formatreturns=lambda text: ' -> ' + text,         formatannotation=formatannotation):      def formatargandannotation(arg):         result = formatarg(arg)         if arg in annotations:             result += ': ' + formatannotation(annotations[arg])         return result     specs = []     if defaults:         firstdefault = len(args) - len(defaults)     for i, arg in enumerate(args):         spec = formatargandannotation(arg)         if defaults and i >= firstdefault:             spec = spec + formatvalue(defaults[i - firstdefault])         specs.append(spec)     if varargs is not None:         specs.append(formatvarargs(formatargandannotation(varargs)))     else:         if kwonlyargs:             specs.append('*')     if kwonlyargs:         for kwonlyarg in kwonlyargs:             spec = formatargandannotation(kwonlyarg)             if kwonlydefaults and kwonlyarg in kwonlydefaults:                 spec += formatvalue(kwonlydefaults[kwonlyarg])             specs.append(spec)     if varkw is not None:         specs.append(formatvarkw(formatargandannotation(varkw)))     result = '(' + ', '.join(specs) + ')'     if 'return' in annotations:         result += formatreturns(formatannotation(annotations['return']))     return result\n1: def find_min_iterative(nums: list[int | float]) -> int | float:     if len(nums) == 0:         raise ValueError(\"find_min_iterative() arg is an empty sequence\")     min_num = nums[0]     for num in nums:         min_num = min(min_num, num)     return min_num\n2: def sin(     angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10 ) -> float:     # Simplify the angle to be between 360 and -360 degrees.     angle_in_degrees = angle_in_degrees - ((angle_in_degrees // 360.0) * 360.0)      # Converting from degrees to radians     angle_in_radians = radians(angle_in_degrees)      result = angle_in_radians     a = 3     b = -1      for _ in range(accuracy):         result += (b * (angle_in_radians**a)) / factorial(a)          b = -b  # One positive term and the next will be negative and so on...         a += 2  # Increased by 2 for every term.      return round(result, rounded_values_count)", "output": "2"}
{"task": "search", "input": "search code:\nRemoves size prefix, that compressed file should have\n\nChoices:\n0: def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:     arr.sort()     n = len(arr)     for i in range(n - 1):         left, right = i + 1, n - 1         while left < right:             if arr[i] + arr[left] + arr[right] == target:                 return (arr[i], arr[left], arr[right])             elif arr[i] + arr[left] + arr[right] < target:                 left += 1             elif arr[i] + arr[left] + arr[right] > target:                 right -= 1     return (0, 0, 0)\n1: def remove_prefix(data_bits: str) -> str:     counter = 0     for letter in data_bits:         if letter == \"1\":             break         counter += 1      data_bits = data_bits[counter:]     data_bits = data_bits[counter + 1 :]     return data_bits\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]", "output": "def create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]"}
{"task": "summary", "input": "summarize code:\ndef simple_moving_average(\n    data: Sequence[float], window_size: int\n) -> list[float | None]:\n    if window_size < 1:\n        raise ValueError(\"Window size must be a positive integer\")\n\n    sma: list[float | None] = []\n\n    for i in range(len(data)):\n        if i < window_size - 1:\n            sma.append(None)  # SMA not available for early data points\n        else:\n            window = data[i - window_size + 1 : i + 1]\n            sma_value = sum(window) / window_size\n            sma.append(sma_value)\n    return sma", "output": "Calculate the simple moving average (SMA) for some given time series data."}
{"task": "detection", "input": "classify code:\ndef calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]", "output": "def encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]"}
{"task": "search", "input": "search code:\nChecks if a combination (a tuple of 9 digits)\n\nChoices:\n0: def is_combination_valid(combination):     return (         int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))         == int(\"\".join(combination[5:9]))     ) or (         int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))         == int(\"\".join(combination[5:9]))     )\n1: def union_set(x: Node, y: Node) -> None:     x, y = find_set(x), find_set(y)     if x == y:         return      elif x.rank > y.rank:         y.parent = x     else:         x.parent = y         if x.rank == y.rank:             y.rank += 1\n2: def pheromone_update(     pheromone: list[list[float]],     cities: dict[int, list[int]],     pheromone_evaporation: float,     ants_route: list[list[int]],     q: float,  # Pheromone system parameters Q, which is a constant     best_path: list[int],     best_distance: float, ) -> tuple[list[list[float]], list[int], float]:     for a in range(len(cities)):  # Update the volatilization of pheromone on all routes         for b in range(len(cities)):             pheromone[a][b] *= pheromone_evaporation     for ant_route in ants_route:         total_distance = 0.0         for i in range(len(ant_route) - 1):  # Calculate total distance             total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])         delta_pheromone = q / total_distance         for i in range(len(ant_route) - 1):  # Update pheromones             pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone             pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][                 ant_route[i + 1]             ]          if total_distance < best_distance:             best_path = ant_route             best_distance = total_distance      return pheromone, best_path, best_distance", "output": "0"}
{"task": "detection", "input": "classify code:\ndef binary_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef matrix_chain_multiply(arr: list[int]) -> int:\n    if len(arr) < 2:\n        return 0\n    # initialising 2D dp matrix\n    n = len(arr)\n    dp = [[maxsize for j in range(n)] for i in range(n)]\n    # we want minimum cost of multiplication of matrices\n    # of dimension (i*k) and (k*j). This cost is arr[i-1]*arr[k]*arr[j].\n    for i in range(n - 1, 0, -1):\n        for j in range(i, n):\n            if i == j:\n                dp[i][j] = 0\n                continue\n            for k in range(i, j):\n                dp[i][j] = min(\n                    dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]\n                )\n\n    return dp[1][n - 1]", "output": "Find the minimum number of multiplcations required to multiply the chain of matrices"}
{"task": "detection", "input": "classify code:\ndef hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 1000000) -> int:\n    divisor = limit - 1\n    if divisor % 2 == 0:\n        divisor += 1\n    while least_divisible_repunit(divisor) <= limit:\n        divisor += 2\n    return divisor", "output": "Return the least value of n for which least_divisible_repunit(n)"}
{"task": "repair", "input": "fix bug:\ndef is_sum_subset(arr, arr_len, required_sum):\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 4, 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 4, 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    subset = [[False for i in range(required_sum + 1)] for i in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    # uncomment to print the subset\n    # for i in range(arrLen+1):\n    #     print(subset[i])\n    print(subset[arr_len][required_sum])", "output": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    return subset[arr_len][required_sum]"}
{"task": "search", "input": "search code:\nFind the minimum change from the given denominations and value\n\nChoices:\n0: def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:     right = right or len(list_data) - 1     if left > right:         return -1     elif list_data[left] == key:         return left     elif list_data[right] == key:         return right     else:         return search(list_data, key, left + 1, right - 1)\n1: def _extract_labels(f, one_hot=False, num_classes=10):     print(\"Extracting\", f.name)     with gzip.GzipFile(fileobj=f) as bytestream:         magic = _read32(bytestream)         if magic != 2049:             msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"             raise ValueError(msg)         num_items = _read32(bytestream)         buf = bytestream.read(num_items)         labels = np.frombuffer(buf, dtype=np.uint8)         if one_hot:             return _dense_to_one_hot(labels, num_classes)         return labels\n2: def find_minimum_change(denominations: list[int], value: str) -> list[int]:     total_value = int(value)      # Initialize Result     answer = []      # Traverse through all denomination     for denomination in reversed(denominations):         # Find denominations         while int(total_value) >= int(denomination):             total_value -= int(denomination)             answer.append(denomination)  # Append the \"answers\" array      return answer", "output": "2"}
{"task": "search", "input": "search code:\n| `weights` - ``int`` list\n\nChoices:\n0: def next_number(number: int) -> int:      sum_of_digits_squared = 0     while number:         # Increased Speed Slightly by checking every 5 digits together.         sum_of_digits_squared += DIGITS_SQUARED[number % 100000]         number //= 100000      return sum_of_digits_squared\n1: def concave_triangle_area(circles_number: int) -> float:      intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (         2 * (circles_number**2 + 1)     )     intersection_x = circles_number * intersection_y      triangle_area = intersection_x * intersection_y / 2     concave_region_area = circle_bottom_arc_integral(         1 / 2     ) - circle_bottom_arc_integral(intersection_x)      return triangle_area + concave_region_area\n2: def procentual_proximity(     source_data: list[list[float]], weights: list[int] ) -> list[list[float]]:      data_lists = get_data(source_data)     score_lists = calculate_each_score(data_lists, weights)     final_scores = generate_final_scores(score_lists)      # append scores to source data     for i, ele in enumerate(final_scores):         source_data[i].append(ele)      return source_data", "output": "2"}
{"task": "detection", "input": "classify code:\ndef speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20Â°C: bulk_modulus= 2.15MPa, density=998kg/mÂ³\n    Example 2 --> Mercury 20Â°C: bulk_modulus= 28.5MPa, density=13600kg/mÂ³\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef data_safety_checker(list_vote: list, actual_result: float) -> None:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2,3,4],5.0)\n    Today's data is not safe.\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe = safe + 1\n            else:\n                not_safe = not_safe + 1\n    print(f\"Today's data is {'not ' if safe <= not_safe else ''}safe.\")", "output": "def data_safety_checker(list_vote: list, actual_result: float) -> bool:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2, 3, 4], 5.0)\n    False\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe += 1\n            else:\n                not_safe += 1\n    return safe > not_safe"}
{"task": "summary", "input": "summarize code:\ndef create_state_space_tree(\n    sequence: list[int | str],\n    current_sequence: list[int | str],\n    index: int,\n    index_used: list[int],\n) -> None:\n\n    if index == len(sequence):\n        print(current_sequence)\n        return\n\n    for i in range(len(sequence)):\n        if not index_used[i]:\n            current_sequence.append(sequence[i])\n            index_used[i] = True\n            create_state_space_tree(sequence, current_sequence, index + 1, index_used)\n            current_sequence.pop()\n            index_used[i] = False", "output": "Creates a state space tree to iterate through each branch using DFS."}
{"task": "detection", "input": "classify code:\ndef orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    \"\"\"\n    Calculates the work required to move an object from one orbit to another in a\n    gravitational field based on the change in total mechanical energy.\n\n    The formula used is:\n        W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\n    where:\n        W = work done (Joules)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the central body (kg)\n        m = mass of the orbiting object (kg)\n        r_initial = initial orbit radius (m)\n        r_final = final orbit radius (m)\n\n    Args:\n        mass_central (float): Mass of the central body (kg)\n        mass_object (float): Mass of the object being moved (kg)\n        r_initial (float): Initial orbital radius (m)\n        r_final (float): Final orbital radius (m)\n\n    Returns:\n        str: Work done in Joules as a string in scientific notation (3 decimals)\n\n    Examples:\n        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n        '2.811e+09'\n        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n        '-1.405e+09'\n        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n        '1.514e+11'\n    \"\"\"\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\"", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef main():\n    num = int(input(\"Enter an integer to see if it is an Armstrong number: \").strip())\n    print(f\"{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number.\")\n    print(f\"{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number.\")\n    print(f\"{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number.\")", "output": "Request that user input an integer and tell them if it is Armstrong number."}
{"task": "search", "input": "search code:\nCalculate reactive power from apparent power and power factor.\n\nChoices:\n0: def combinations(n: int, k: int) -> int:      # If either of the conditions are true, the function is being asked     # to calculate a factorial of a negative number, which is not possible     if n < k or k < 0:         raise ValueError(\"Please enter positive integers for n and k where n >= k\")     res = 1     for i in range(k):         res *= n - i         res //= i + 1     return res\n1: def binary_insertion_sort(collection: list) -> list:      n = len(collection)     for i in range(1, n):         value_to_insert = collection[i]         low = 0         high = i - 1          while low <= high:             mid = (low + high) // 2             if value_to_insert < collection[mid]:                 high = mid - 1             else:                 low = mid + 1         for j in range(i, low, -1):             collection[j] = collection[j - 1]         collection[low] = value_to_insert     return collection\n2: def reactive_power(apparent_power: float, power_factor: float) -> float:     if (         not isinstance(power_factor, (int, float))         or power_factor < -1         or power_factor > 1     ):         raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")     return apparent_power * math.sqrt(1 - power_factor**2)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef max_sub_array(nums: List[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best", "output": "def max_sub_array(nums: list[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best"}
{"task": "detection", "input": "classify code:\ndef filter_common_word(possibles: list[str], common_word: str) -> list[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef is_9_pandigital(n: int) -> bool:\n    \"\"\"\n    Checks whether n is a 9-digit 1 to 9 pandigital number.\n    >>> is_9_pandigital(12345)\n    False\n    >>> is_9_pandigital(156284973)\n    True\n    >>> is_9_pandigital(1562849733)\n    False\n    \"\"\"\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")", "output": "def is_9_pandigital(n: int) -> bool:\n    \"\"\"\n    Checks whether n is a 9-digit 1 to 9 pandigital number.\n    >>> is_9_pandigital(12345)\n    False\n    >>> is_9_pandigital(156284973)\n    True\n    >>> is_9_pandigital(1562849733)\n    False\n    \"\"\"\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")"}
{"task": "search", "input": "search code:\nYield the primes less than n.\n\nChoices:\n0: def sieve(n):     # This implementation comes from an older version of the itertools     # documentation.  The newer implementation is easier to read but is     # less lazy.     if n > 2:         yield 2     start = 3     data = bytearray((0, 1)) * (n // 2)     for p in iter_index(data, 1, start, stop=isqrt(n) + 1):         yield from iter_index(data, 1, start, p * p)         data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))         start = p * p     yield from iter_index(data, 1, start)\n1: def is_9_pandigital(n: int) -> bool:     s = str(n)     return len(s) == 9 and set(s) == set(\"123456789\")\n2: def solution(limit: int = 1_000_000) -> int:      # generating an array from -1 to limit     phi = np.arange(-1, limit)      for i in range(2, limit + 1):         if phi[i] == i - 1:             ind = np.arange(2 * i, limit + 1, i)  # indexes for selection             phi[ind] -= phi[ind] // i      return int(np.sum(phi[2 : limit + 1]))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(length: int = 50) -> int:\n\n    ways_number = [1] * (length + 1)\n\n    for row_length in range(3, length + 1):\n        for block_length in range(3, row_length + 1):\n            for block_start in range(row_length - block_length):\n                ways_number[row_length] += ways_number[\n                    row_length - block_start - block_length - 1\n                ]\n\n            ways_number[row_length] += 1\n\n    return ways_number[length]", "output": "Returns the number of ways a row of the given length can be filled"}
{"task": "search", "input": "search code:\nGiven a list of integers, return elements a, b, c such that a + b + c = 0.\n\nChoices:\n0: def multiplication_table(number: int, number_of_terms: int) -> str:     return \"\\n\".join(         f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)     )\n1: def find_triplets_with_0_sum(nums: list[int]) -> list[list[int]]:     return [         list(x)         for x in sorted({abc for abc in combinations(sorted(nums), 3) if not sum(abc)})     ]\n2: def solution(n: int = 1000) -> int:      total = 0     terms = (n - 1) // 3     total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.     terms = (n - 1) // 5     total += ((terms) * (10 + (terms - 1) * 5)) // 2     terms = (n - 1) // 15     total -= ((terms) * (30 + (terms - 1) * 15)) // 2     return total", "output": "1"}
{"task": "detection", "input": "classify code:\ndef get_squares(n: int) -> list[int]:\n    \"\"\"\n    >>> get_squares(0)\n    []\n    >>> get_squares(1)\n    [0]\n    >>> get_squares(2)\n    [0, 1]\n    >>> get_squares(3)\n    [0, 1, 4]\n    >>> get_squares(4)\n    [0, 1, 4, 9]\n    \"\"\"\n    return [number * number for number in range(n)]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef draw_cross(x: float, y: float, length: float):\n    turtle.up()\n    turtle.goto(x - length / 2, y - length / 6)\n    turtle.down()\n    turtle.seth(0)\n    turtle.begin_fill()\n    for _ in range(4):\n        turtle.fd(length / 3)\n        turtle.right(90)\n        turtle.fd(length / 3)\n        turtle.left(90)\n        turtle.fd(length / 3)\n        turtle.left(90)\n    turtle.end_fill()", "output": "Draw a cross at the specified position and with the specified length."}
{"task": "repair", "input": "fix bug:\ndef check(binary: List[str]) -> List[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))", "output": "def check(binary: list[str]) -> list[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))"}
{"task": "repair", "input": "fix bug:\ndef minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))", "output": "def minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))"}
{"task": "summary", "input": "summarize code:\ndef solution(max_base: int = 5) -> int:\n    freqs = defaultdict(list)\n    num = 0\n\n    while True:\n        digits = get_digits(num)\n        freqs[digits].append(num)\n\n        if len(freqs[digits]) == max_base:\n            base = freqs[digits][0] ** 3\n            return base\n\n        num += 1", "output": "Iterate through every possible cube and sort the cube's digits in"}
{"task": "search", "input": "search code:\nReturns the first true value in the iterable.\n\nChoices:\n0: def running_key_decrypt(key: str, ciphertext: str) -> str:     ciphertext = ciphertext.replace(\" \", \"\").upper()     key = key.replace(\" \", \"\").upper()     key_length = len(key)     plaintext = []     ord_a = ord(\"A\")      for i, char in enumerate(ciphertext):         c = ord(char) - ord_a         k = ord(key[i % key_length]) - ord_a         p = (c - k) % 26         plaintext.append(chr(p + ord_a))      return \"\".join(plaintext)\n1: def solution(num: int = 100) -> int:     return sum(int(x) for x in str(factorial(num)))\n2: def first_true(iterable, default=None, pred=None):     return next(filter(pred, iterable), default)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef is_match(string: str, pattern: str) -> bool:\n    \"\"\"\n    >>> is_match(\"\", \"\")\n    True\n    >>> is_match(\"aa\", \"a\")\n    False\n    >>> is_match(\"abc\", \"abc\")\n    True\n    >>> is_match(\"abc\", \"*c\")\n    True\n    >>> is_match(\"abc\", \"a*\")\n    True\n    >>> is_match(\"abc\", \"*a*\")\n    True\n    >>> is_match(\"abc\", \"?b?\")\n    True\n    >>> is_match(\"abc\", \"*?\")\n    True\n    >>> is_match(\"abc\", \"a*d\")\n    False\n    >>> is_match(\"abc\", \"a*c?\")\n    False\n    >>> is_match('baaabab','*****ba*****ba')\n    False\n    >>> is_match('baaabab','*****ba*****ab')\n    True\n    >>> is_match('aa','*')\n    True\n    \"\"\"\n    dp = [[False] * (len(pattern) + 1) for _ in string + \"1\"]\n    dp[0][0] = True\n    # Fill in the first row\n    for j, char in enumerate(pattern, 1):\n        if char == \"*\":\n            dp[0][j] = dp[0][j - 1]\n    # Fill in the rest of the DP table\n    for i, s_char in enumerate(string, 1):\n        for j, p_char in enumerate(pattern, 1):\n            if p_char in (s_char, \"?\"):\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[len(string)][len(pattern)]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef removeprefix(text: str, prefix: str) -> str:\n    if text.startswith(prefix):\n        return text[len(prefix):]\n    return text", "output": "Remove `prefix` from start of `text` if present."}
{"task": "search", "input": "search code:\nReturns number with the specified format, clamped between floor and ceil.\n\nChoices:\n0: def count_inversions_bf(arr):      num_inversions = 0     n = len(arr)      for i in range(n - 1):         for j in range(i + 1, n):             if arr[i] > arr[j]:                 num_inversions += 1      return num_inversions\n1: def clamp(value, format=\"{:}\", floor=None, ceil=None, floor_token=\"<\", ceil_token=\">\"):     if value is None:         return None      if floor is not None and value < floor:         value = floor         token = floor_token     elif ceil is not None and value > ceil:         value = ceil         token = ceil_token     else:         token = \"\"      if isinstance(format, str):         return token + format.format(value)     elif callable(format):         return token + format(value)     else:         raise ValueError(             \"Invalid format. Must be either a valid formatting string, or a function \"             \"that accepts value and returns a string.\"         )\n2: def xnor_gate(input_1: int, input_2: int) -> int:     return 1 if input_1 == input_2 else 0", "output": "1"}
{"task": "detection", "input": "classify code:\ndef largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef levenshtein_distance(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Implementation of the Levenshtein distance in Python.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance(\"\", \"test\")\n    4\n    >>> levenshtein_distance(\"book\", \"back\")\n    2\n    >>> levenshtein_distance(\"book\", \"book\")\n    0\n    >>> levenshtein_distance(\"test\", \"\")\n    4\n    >>> levenshtein_distance(\"\", \"\")\n    0\n    >>> levenshtein_distance(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    # The longer word should come first\n    if len(first_word) < len(second_word):\n        return levenshtein_distance(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1]\n\n        for j, c2 in enumerate(second_word):\n            # Calculate insertions, deletions, and substitutions\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n\n            # Get the minimum to append to the current row\n            current_row.append(min(insertions, deletions, substitutions))\n\n        # Store the previous row\n        previous_row = current_row\n\n    # Returns the last element (distance)\n    return previous_row[-1]", "output": "def levenshtein_distance(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Implementation of the Levenshtein distance in Python.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance(\"\", \"test\")\n    4\n    >>> levenshtein_distance(\"book\", \"back\")\n    2\n    >>> levenshtein_distance(\"book\", \"book\")\n    0\n    >>> levenshtein_distance(\"test\", \"\")\n    4\n    >>> levenshtein_distance(\"\", \"\")\n    0\n    >>> levenshtein_distance(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    # The longer word should come first\n    if len(first_word) < len(second_word):\n        return levenshtein_distance(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1]\n\n        for j, c2 in enumerate(second_word):\n            # Calculate insertions, deletions, and substitutions\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n\n            # Get the minimum to append to the current row\n            current_row.append(min(insertions, deletions, substitutions))\n\n        # Store the previous row\n        previous_row = current_row\n\n    # Returns the last element (distance)\n    return previous_row[-1]"}
{"task": "repair", "input": "fix bug:\ndef solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in xrange(1, 1001):\n        total += i ** i\n    return str(total)[-10:]", "output": "def solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in range(1, 1001):\n        total += i ** i\n    return str(total)[-10:]"}
{"task": "summary", "input": "summarize code:\ndef city_select(\n    pheromone: list[list[float]],\n    current_city: dict[int, list[int]],\n    unvisited_cities: dict[int, list[int]],\n    alpha: float,\n    beta: float,\n) -> tuple[dict[int, list[int]], dict[int, list[int]]]:\n    probabilities = []\n    for city, value in unvisited_cities.items():\n        city_distance = distance(value, next(iter(current_city.values())))\n        probability = (pheromone[city][next(iter(current_city.keys()))] ** alpha) * (\n            (1 / city_distance) ** beta\n        )\n        probabilities.append(probability)\n\n    chosen_city_i = random.choices(\n        list(unvisited_cities.keys()), weights=probabilities\n    )[0]\n    chosen_city = {chosen_city_i: unvisited_cities[chosen_city_i]}\n    del unvisited_cities[next(iter(chosen_city.keys()))]\n    return chosen_city, unvisited_cities", "output": "Choose the next city for ants"}
{"task": "search", "input": "search code:\nNon-decreasing indices, lazily consumed\n\nChoices:\n0: def world_covid19_stats(     url: str = \"https://www.worldometers.info/coronavirus/\", ) -> dict:     soup = BeautifulSoup(         httpx.get(url, timeout=10, follow_redirects=True).text, \"html.parser\"     )     keys = soup.find_all(\"h1\")     values = soup.find_all(\"div\", {\"class\": \"maincounter-number\"})     keys += soup.find_all(\"span\", {\"class\": \"panel-title\"})     values += soup.find_all(\"div\", {\"class\": \"number-table-main\"})     return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}\n1: def _running_median_minheap_only(iterator):  # pragma: no cover     \"Backport of non-windowed running_median() for Python 3.13 and prior.\"      read = iterator.__next__     lo = []  # max-heap (actually a minheap with negated values)     hi = []  # min-heap (same size as or one smaller than lo)      with suppress(StopIteration):         while True:             heappush(lo, -heappushpop(hi, read()))             yield -lo[0]              heappush(hi, -heappushpop(lo, -read()))             yield (hi[0] - lo[0]) / 2\n2: def _extract_monotonic(iterator, indices):     'Non-decreasing indices, lazily consumed'     num_read = 0     for index in indices:         advance = index - num_read         try:             value = next(islice(iterator, advance, None))         except ValueError:             if advance != -1 or index < 0:                 raise ValueError(f'Invalid index: {index}') from None         except StopIteration:             raise IndexError(index) from None         else:             num_read += advance + 1         yield value", "output": "2"}
{"task": "detection", "input": "classify code:\ndef euclidean_distance_sqr(point1, point2):\n    \"\"\"\n    >>> euclidean_distance_sqr([1,2],[2,4])\n    5\n    \"\"\"\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2", "output": "CORRECT"}
{"task": "search", "input": "search code:\nExtend suppressed units (if any) with all units lower than the minimum unit.\n\nChoices:\n0: def draw_cross(x: float, y: float, length: float):     turtle.up()     turtle.goto(x - length / 2, y - length / 6)     turtle.down()     turtle.seth(0)     turtle.begin_fill()     for _ in range(4):         turtle.fd(length / 3)         turtle.right(90)         turtle.fd(length / 3)         turtle.left(90)         turtle.fd(length / 3)         turtle.left(90)     turtle.end_fill()\n1: def _suppress_lower_units(min_unit, suppress):     suppress = set(suppress)     for u in Unit:         if u == min_unit:             break         suppress.add(u)      return suppress\n2: def left_rotate_32(i: int, shift: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")     if shift < 0:         raise ValueError(\"Shift must be non-negative\")     return ((i << shift) ^ (i >> (32 - shift))) % 2**32", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef swap_case(sentence):\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        if char.islower():\n            new_string += char.upper()\n        if regexp.search(char):\n            new_string += char\n\n    return new_string", "output": "def swap_case(sentence: str) -> str:\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n\n    return new_string"}
{"task": "detection", "input": "classify code:\ndef abs_max(x: List[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef elf_hash(data: str) -> int:\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_", "output": "Implementation of ElfHash Algorithm, a variant of PJW hash function."}
{"task": "summary", "input": "summarize code:\ndef comb_sort(data: list) -> list:\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data", "output": "Pure implementation of comb sort algorithm in Python"}
{"task": "search", "input": "search code:\nCalculate the number of non-bouncy numbers with at most n digits.\n\nChoices:\n0: def covariance_between_classes(     features: np.ndarray, labels: np.ndarray, classes: int ) -> np.ndarray:      general_data_mean = features.mean(1)     covariance_sum = np.nan     for i in range(classes):         data = features[:, labels == i]         device_data = data.shape[1]         data_mean = data.mean(1)         if i > 0:             # If covariance_sum is not None             covariance_sum += device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )         else:             # If covariance_sum is np.nan (i.e. first loop)             covariance_sum = device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )      return covariance_sum / features.shape[1]\n1: def fizz_buzz(number: int, iterations: int) -> str:     if not isinstance(iterations, int):         raise ValueError(\"iterations must be defined as integers\")     if not isinstance(number, int) or not number >= 1:         raise ValueError(         )     if not iterations >= 1:         raise ValueError(\"Iterations must be done more than 0 times to play FizzBuzz\")      out = \"\"     while number <= iterations:         if number % 3 == 0:             out += \"Fizz\"         if number % 5 == 0:             out += \"Buzz\"         if 0 not in (number % 3, number % 5):             out += str(number)          # print(out)         number += 1         out += \" \"     return out\n2: def non_bouncy_exact(n: int) -> int:     return choose(8 + n, n) + choose(9 + n, n) - 10", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef abs_max(x: List[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j", "output": "def abs_max(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j"}
{"task": "detection", "input": "classify code:\ndef capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    return sentence[0].upper() + sentence[1:]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the sum of all even fibonacci sequence elements that are lower\n\nChoices:\n0: def solution(n: int = 4000000) -> int:      even_fibs = []     a, b = 0, 1     while b <= n:         if b % 2 == 0:             even_fibs.append(b)         a, b = b, a + b     return sum(even_fibs)\n1: def simple_moving_average(     data: Sequence[float], window_size: int ) -> list[float | None]:     if window_size < 1:         raise ValueError(\"Window size must be a positive integer\")      sma: list[float | None] = []      for i in range(len(data)):         if i < window_size - 1:             sma.append(None)  # SMA not available for early data points         else:             window = data[i - window_size + 1 : i + 1]             sma_value = sum(window) / window_size             sma.append(sma_value)     return sma\n2: def height(root: Node | None) -> int:     return (max(height(root.left), height(root.right)) + 1) if root else 0", "output": "0"}
{"task": "detection", "input": "classify code:\ndef prime_sieve(limit: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef sin(\n    angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10\n) -> float:\n    # Simplify the angle to be between 360 and -360 degrees.\n    angle_in_degrees = angle_in_degrees - ((angle_in_degrees // 360.0) * 360.0)\n\n    # Converting from degrees to radians\n    angle_in_radians = radians(angle_in_degrees)\n\n    result = angle_in_radians\n    a = 3\n    b = -1\n\n    for _ in range(accuracy):\n        result += (b * (angle_in_radians**a)) / factorial(a)\n\n        b = -b  # One positive term and the next will be negative and so on...\n        a += 2  # Increased by 2 for every term.\n\n    return round(result, rounded_values_count)", "output": "Implement sin function."}
{"task": "repair", "input": "fix bug:\ndef bisect_left(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "def bisect_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo"}
{"task": "search", "input": "search code:\nDecode the input string using the provided key.\n\nChoices:\n0: def decode(ciphertext: str, key: str) -> str:      table = generate_table(key)     plaintext = \"\"      for char1, char2 in chunker(ciphertext, 2):         row1, col1 = divmod(table.index(char1), 5)         row2, col2 = divmod(table.index(char2), 5)          if row1 == row2:             plaintext += table[row1 * 5 + (col1 - 1) % 5]             plaintext += table[row2 * 5 + (col2 - 1) % 5]         elif col1 == col2:             plaintext += table[((row1 - 1) % 5) * 5 + col1]             plaintext += table[((row2 - 1) % 5) * 5 + col2]         else:  # rectangle             plaintext += table[row1 * 5 + col2]             plaintext += table[row2 * 5 + col1]      return plaintext\n1: def bisection(function: Callable[[float], float], a: float, b: float) -> float:     start: float = a     end: float = b     if function(a) == 0:  # one of the a or b is a root for the function         return a     elif function(b) == 0:         return b     elif (         function(a) * function(b) > 0     ):  # if none of these are root and they are both positive or negative,         # then this algorithm can't find the root         raise ValueError(\"could not find root in given interval.\")     else:         mid: float = start + (end - start) / 2.0         while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7             if function(mid) == 0:                 return mid             elif function(mid) * function(start) < 0:                 end = mid             else:                 start = mid             mid = start + (end - start) / 2.0         return mid\n2: def pretty_print(n):     if n <= 0:         return \"       ...       ....        nothing printing :(\"     upper_half = floyd(n)  # upper half     lower_half = reverse_floyd(n)  # lower half     return upper_half + lower_half", "output": "0"}
{"task": "detection", "input": "classify code:\ndef is_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef vernam_encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_encrypt(\"HELLO\",\"KEY\")\n    'RIJVS'\n    \"\"\"\n    ciphertext = \"\"\n    for i in range(len(plaintext)):\n        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65\n        while ct > 25:\n            ct = ct - 26\n        ciphertext += chr(65 + ct)\n    return ciphertext", "output": "def vernam_encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_encrypt(\"HELLO\",\"KEY\")\n    'RIJVS'\n    \"\"\"\n    ciphertext = \"\"\n    for i in range(len(plaintext)):\n        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65\n        while ct > 25:\n            ct = ct - 26\n        ciphertext += chr(65 + ct)\n    return ciphertext"}
{"task": "summary", "input": "summarize code:\ndef suppress_non_maximum(image_shape, gradient_direction, sobel_grad):\n    destination = np.zeros(image_shape)\n\n    for row in range(1, image_shape[0] - 1):\n        for col in range(1, image_shape[1] - 1):\n            direction = gradient_direction[row, col]\n\n            if (\n                0 <= direction < PI / 8\n                or 15 * PI / 8 <= direction <= 2 * PI\n                or 7 * PI / 8 <= direction <= 9 * PI / 8\n            ):\n                w = sobel_grad[row, col - 1]\n                e = sobel_grad[row, col + 1]\n                if sobel_grad[row, col] >= w and sobel_grad[row, col] >= e:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                PI / 8 <= direction < 3 * PI / 8\n                or 9 * PI / 8 <= direction < 11 * PI / 8\n            ):\n                sw = sobel_grad[row + 1, col - 1]\n                ne = sobel_grad[row - 1, col + 1]\n                if sobel_grad[row, col] >= sw and sobel_grad[row, col] >= ne:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                3 * PI / 8 <= direction < 5 * PI / 8\n                or 11 * PI / 8 <= direction < 13 * PI / 8\n            ):\n                n = sobel_grad[row - 1, col]\n                s = sobel_grad[row + 1, col]\n                if sobel_grad[row, col] >= n and sobel_grad[row, col] >= s:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                5 * PI / 8 <= direction < 7 * PI / 8\n                or 13 * PI / 8 <= direction < 15 * PI / 8\n            ):\n                nw = sobel_grad[row - 1, col - 1]\n                se = sobel_grad[row + 1, col + 1]\n                if sobel_grad[row, col] >= nw and sobel_grad[row, col] >= se:\n                    destination[row, col] = sobel_grad[row, col]\n\n    return destination", "output": "Non-maximum suppression. If the edge strength of the current pixel is the largest"}
{"task": "repair", "input": "fix bug:\ndef filter_common_word(possibles: List[str], common_word: str) -> List[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]", "output": "def filter_common_word(possibles: list[str], common_word: str) -> list[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]"}
{"task": "summary", "input": "summarize code:\ndef sum_of_divisors(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    s = 1\n    temp = 1\n    while n % 2 == 0:\n        temp += 1\n        n = int(n / 2)\n    if temp > 1:\n        s *= (2**temp - 1) / (2 - 1)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        temp = 1\n        while n % i == 0:\n            temp += 1\n            n = int(n / i)\n        if temp > 1:\n            s *= (i**temp - 1) / (i - 1)\n    return int(s)", "output": "Calculate Sum of Divisors."}
{"task": "search", "input": "search code:\nTake in 2 integers.\n\nChoices:\n0: def arithmetic_right_shift(number: int, shift_amount: int) -> str:     if number >= 0:  # Get binary representation of positive number         binary_number = \"0\" + str(bin(number)).strip(\"-\")[2:]     else:  # Get binary (2's complement) representation of negative number         binary_number_length = len(bin(number)[3:])  # Find 2's complement of number         binary_number = bin(abs(number) - (1 << binary_number_length))[3:]         binary_number = (             \"1\" + \"0\" * (binary_number_length - len(binary_number)) + binary_number         )      if shift_amount >= len(binary_number):         return \"0b\" + binary_number[0] * len(binary_number)     return (         \"0b\"         + binary_number[0] * shift_amount         + binary_number[: len(binary_number) - shift_amount]     )\n1: def solution() -> float:      peter_totals_frequencies = total_frequency_distribution(         sides_number=4, dice_number=9     )     colin_totals_frequencies = total_frequency_distribution(         sides_number=6, dice_number=6     )      peter_wins_count = 0     min_peter_total = 9     max_peter_total = 4 * 9     min_colin_total = 6     for peter_total in range(min_peter_total, max_peter_total + 1):         peter_wins_count += peter_totals_frequencies[peter_total] * sum(             colin_totals_frequencies[min_colin_total:peter_total]         )      total_games_number = (4**9) * (6**6)     peter_win_probability = peter_wins_count / total_games_number      rounded_peter_win_probability = round(peter_win_probability, ndigits=7)      return rounded_peter_win_probability\n2: def invert_modulo(a: int, n: int) -> int:     (b, _x) = extended_euclid(a, n)  # Implemented below     if b < 0:         b = (b % n + n) % n     return b", "output": "0"}
{"task": "detection", "input": "classify code:\ndef solution(n: int = 4000000) -> int:\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    10\r\n    >>> solution(15)\r\n    10\r\n    >>> solution(2)\r\n    2\r\n    >>> solution(1)\r\n    0\r\n    >>> solution(34)\r\n    44\r\n    \"\"\"\r\n    even_fibs = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            even_fibs.append(b)\r\n        a, b = b, a + b\r\n    return sum(even_fibs)\r", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef median(nums: list) -> Union[int, float]:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )", "output": "def median(nums: list) -> int | float:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )"}
{"task": "search", "input": "search code:\nTake in a negative integer 'number'.\n\nChoices:\n0: def get_band_type_count(total_number_of_bands: int, type_of_band: str) -> int:     if total_number_of_bands not in band_types:         msg = f\"{total_number_of_bands} is not a valid number of bands\"         raise ValueError(msg)     if type_of_band not in band_types[total_number_of_bands]:         msg = f\"{type_of_band} is not valid for a {total_number_of_bands} band resistor\"         raise ValueError(msg)     return band_types[total_number_of_bands][type_of_band]\n1: def newton_raphson(     f: RealFunc,     x0: float = 0,     max_iter: int = 100,     step: float = 1e-6,     max_error: float = 1e-6,     log_steps: bool = False, ) -> tuple[float, float, list[float]]:      def f_derivative(x: float) -> float:         return calc_derivative(f, x, step)      a = x0  # Set initial guess     steps = []     for _ in range(max_iter):         if log_steps:  # Log intermediate steps             steps.append(a)          error = abs(f(a))         if error < max_error:             return a, error, steps          if f_derivative(a) == 0:             raise ZeroDivisionError(\"No converging solution found, zero derivative\")         a -= f(a) / f_derivative(a)  # Calculate next estimate     raise ArithmeticError(\"No converging solution found, iteration limit reached\")\n2: def twos_complement(number: int) -> str:     if number > 0:         raise ValueError(\"input must be a negative integer\")     binary_number_length = len(bin(number)[3:])     twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]     twos_complement_number = (         (             \"1\"             + \"0\" * (binary_number_length - len(twos_complement_number))             + twos_complement_number         )         if number < 0         else \"0\"     )     return \"0b\" + twos_complement_number", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef opening_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:\n    if kernel is None:\n        np.ones((3, 3))\n\n    return transform(transform(image, \"dilation\", kernel), \"erosion\", kernel)", "output": "Opening filter, defined as the sequence of"}
{"task": "detection", "input": "classify code:\ndef find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None", "output": "CORRECT"}
{"task": "search", "input": "search code:\nreturns Edge list for frequent subgraphs\n\nChoices:\n0: def freq_subgraphs_edge_list(paths):     freq_sub_el = []     for edges in paths:         el = []         for j in range(len(edges) - 1):             temp = list(edges[j])             for e in temp:                 edge = (e[0], e[1])                 el.append(edge)         freq_sub_el.append(el)     return freq_sub_el\n1: def binary_exp_iterative(base: float, exponent: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res *= base          base *= base         exponent >>= 1      return res\n2: def interact_treap(root: Node | None, args: str) -> Node | None:     for arg in args.split():         if arg[0] == \"+\":             root = insert(root, int(arg[1:]))          elif arg[0] == \"-\":             root = erase(root, int(arg[1:]))          else:             print(\"Unknown command\")      return root", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef prime_sieve(limit: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "def prime_sieve(limit: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes"}
{"task": "summary", "input": "summarize code:\ndef convert_to_2d(\n    x: float, y: float, z: float, scale: float, distance: float\n) -> tuple[float, float]:\n    if not all(isinstance(val, (float, int)) for val in locals().values()):\n        msg = f\"Input values must either be float or int: {list(locals().values())}\"\n        raise TypeError(msg)\n    projected_x = ((x * distance) / (z + distance)) * scale\n    projected_y = ((y * distance) / (z + distance)) * scale\n    return projected_x, projected_y", "output": "Converts 3d point to a 2d drawable point"}
{"task": "detection", "input": "classify code:\ndef hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nUse depth first search to find strongly connected\n\nChoices:\n0: def solution(n: int = 1000) -> int:      total = 0     terms = (n - 1) // 3     total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.     terms = (n - 1) // 5     total += ((terms) * (10 + (terms - 1) * 5)) // 2     terms = (n - 1) // 15     total -= ((terms) * (30 + (terms - 1) * 15)) // 2     return total\n1: def escape_shell_args(args, sep=' ', style=None):     if not style:         style = 'cmd' if sys.platform == 'win32' else 'sh'      if style == 'sh':         return args2sh(args, sep=sep)     elif style == 'cmd':         return args2cmd(args, sep=sep)      raise ValueError(\"style expected one of 'cmd' or 'sh', not %r\" % style)\n2: def find_components(     reversed_graph: dict[int, list[int]], vert: int, visited: list[bool] ) -> list[int]:      visited[vert] = True     component = [vert]      for neighbour in reversed_graph[vert]:         if not visited[neighbour]:             component += find_components(reversed_graph, neighbour, visited)      return component", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - ord(\"a\")] = True\n    return all(flag)", "output": "def check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)"}
{"task": "detection", "input": "classify code:\ndef find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n\n    for i in range(low, high):\n        missing_number ^= i ^ nums[i - low]\n\n    return missing_number", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef calculate_variance(items: list, means: list, total_count: int) -> float:\n    squared_diff = []  # An empty list to store all squared differences\n    # iterate over number of elements in items\n    for i in range(len(items)):\n        # for loop iterates over number of elements in inner layer of items\n        for j in range(len(items[i])):\n            # appending squared differences to 'squared_diff' list\n            squared_diff.append((items[i][j] - means[i]) ** 2)\n\n    # one divided by (the number of all instances - number of classes) multiplied by\n    # sum of all squared differences\n    n_classes = len(means)  # Number of classes in dataset\n    return 1 / (total_count - n_classes) * sum(squared_diff)", "output": "Calculate the variance"}
{"task": "repair", "input": "fix bug:\ndef is_match(string: str, pattern: str) -> bool:\n    \"\"\"\n    >>> is_match(\"\", \"\")\n    True\n    >>> is_match(\"aa\", \"a\")\n    False\n    >>> is_match(\"abc\", \"abc\")\n    True\n    >>> is_match(\"abc\", \"*c\")\n    True\n    >>> is_match(\"abc\", \"a*\")\n    True\n    >>> is_match(\"abc\", \"*a*\")\n    True\n    >>> is_match(\"abc\", \"?b?\")\n    True\n    >>> is_match(\"abc\", \"*?\")\n    True\n    >>> is_match(\"abc\", \"a*d\")\n    False\n    >>> is_match(\"abc\", \"a*c?\")\n    False\n    >>> is_match('baaabab','*****ba*****ba')\n    False\n    >>> is_match('baaabab','*****ba*****ab')\n    True\n    >>> is_match('aa','*')\n    True\n    \"\"\"\n    dp = [[False] * (len(pattern) + 1) for _ in string + \"1\"]\n    dp[0][0] = True\n    # Fill in the first row\n    for j, char in enumerate(pattern, 1):\n        if char == \"*\":\n            dp[0][j] = dp[0][j - 1]\n    # Fill in the rest of the DP table\n    for i, s_char in enumerate(string, 1):\n        for j, p_char in enumerate(pattern, 1):\n            if p_char in (s_char, \"?\"):\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[len(string)][len(pattern)]", "output": "def is_match(string: str, pattern: str) -> bool:\n    \"\"\"\n    >>> is_match(\"\", \"\")\n    True\n    >>> is_match(\"aa\", \"a\")\n    False\n    >>> is_match(\"abc\", \"abc\")\n    True\n    >>> is_match(\"abc\", \"*c\")\n    True\n    >>> is_match(\"abc\", \"a*\")\n    True\n    >>> is_match(\"abc\", \"*a*\")\n    True\n    >>> is_match(\"abc\", \"?b?\")\n    True\n    >>> is_match(\"abc\", \"*?\")\n    True\n    >>> is_match(\"abc\", \"a*d\")\n    False\n    >>> is_match(\"abc\", \"a*c?\")\n    False\n    >>> is_match('baaabab','*****ba*****ba')\n    False\n    >>> is_match('baaabab','*****ba*****ab')\n    True\n    >>> is_match('aa','*')\n    True\n    \"\"\"\n    dp = [[False] * (len(pattern) + 1) for _ in string + \"1\"]\n    dp[0][0] = True\n    # Fill in the first row\n    for j, char in enumerate(pattern, 1):\n        if char == \"*\":\n            dp[0][j] = dp[0][j - 1]\n    # Fill in the rest of the DP table\n    for i, s_char in enumerate(string, 1):\n        for j, p_char in enumerate(pattern, 1):\n            if p_char in (s_char, \"?\"):\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[len(string)][len(pattern)]"}
{"task": "detection", "input": "classify code:\ndef pigeon_sort(array):\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "BUGGY"}
{"task": "search", "input": "search code:\nWrapper function to call subroutine called util_color\n\nChoices:\n0: def identity(n: int) -> list[list[int]]:     n = int(n)     return [[int(row == column) for column in range(n)] for row in range(n)]\n1: def color(graph: list[list[int]], max_colors: int) -> list[int]:     colored_vertices = [-1] * len(graph)      if util_color(graph, max_colors, colored_vertices, 0):         return colored_vertices      return []\n2: def is_ip_v4_address_valid(ip: str) -> bool:     octets = ip.split(\".\")     if len(octets) != 4:         return False      for octet in octets:         if not octet.isdigit():             return False          number = int(octet)         if len(str(number)) != len(octet):             return False          if not 0 <= number <= 255:             return False      return True", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef rotate_array(arr: list[int], steps: int) -> list[int]:\n\n    n = len(arr)\n    if n == 0:\n        return arr\n\n    steps = steps % n\n\n    if steps < 0:\n        steps += n\n\n    def reverse(start: int, end: int) -> None:\n\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    reverse(0, n - 1)\n    reverse(0, steps - 1)\n    reverse(steps, n - 1)\n\n    return arr", "output": "Rotates a list to the right by steps positions."}
{"task": "repair", "input": "fix bug:\ndef combination_sum_iv_dp_array(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)", "output": "def combination_sum_iv_dp_array(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)"}
{"task": "summary", "input": "summarize code:\ndef util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:\n\n    # Base Case\n    if curr_ind == len(graph):\n        # return whether path exists between current and starting vertices\n        return graph[path[curr_ind - 1]][path[0]] == 1\n\n    # Recursive Step\n    for next_ver in range(len(graph)):\n        if valid_connection(graph, next_ver, curr_ind, path):\n            # Insert current vertex  into path as next transition\n            path[curr_ind] = next_ver\n            # Validate created path\n            if util_hamilton_cycle(graph, path, curr_ind + 1):\n                return True\n            # Backtrack\n            path[curr_ind] = -1\n    return False", "output": "Pseudo-Code"}
{"task": "search", "input": "search code:\nReturn the peak value of `lst`.\n\nChoices:\n0: def solution(n: int = 10000) -> int:     total = sum(         i         for i in range(1, n)         if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i     )     return total\n1: def peak(lst: list[int]) -> int:     # middle index     m = len(lst) // 2      # choose the middle 3 elements     three = lst[m - 1 : m + 2]      # if middle element is peak     if three[1] > three[0] and three[1] > three[2]:         return three[1]      # if increasing, recurse on right     elif three[0] < three[2]:         if len(lst[:m]) == 2:             m -= 1         return peak(lst[m:])      # decreasing     else:         if len(lst[:m]) == 2:             m += 1         return peak(lst[:m])\n2: def calculate_probabilities(instance_count: int, total_count: int) -> float:     # number of instances in specific class divided by number of all instances     return instance_count / total_count", "output": "1"}
{"task": "detection", "input": "classify code:\ndef minor(matrix: list[list], row: int, column: int) -> list[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef get_frequency_order(message: str) -> str:\n    letter_to_freq = get_letter_count(message)\n    freq_to_letter: dict[int, list[str]] = {\n        freq: [] for letter, freq in letter_to_freq.items()\n    }\n    for letter in LETTERS:\n        freq_to_letter[letter_to_freq[letter]].append(letter)\n\n    freq_to_letter_str: dict[int, str] = {}\n\n    for freq in freq_to_letter:  # noqa: PLC0206\n        freq_to_letter[freq].sort(key=ETAOIN.find, reverse=True)\n        freq_to_letter_str[freq] = \"\".join(freq_to_letter[freq])\n\n    freq_pairs = list(freq_to_letter_str.items())\n    freq_pairs.sort(key=get_item_at_index_zero, reverse=True)\n\n    freq_order: list[str] = [freq_pair[1] for freq_pair in freq_pairs]\n\n    return \"\".join(freq_order)", "output": "Get the frequency order of the letters in the given string"}
{"task": "detection", "input": "classify code:\ndef double_linear_search(array: List[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef vector_product(point1: Tuple[int, int], point2: Tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]", "output": "def vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]"}
{"task": "search", "input": "search code:\nConverts a large integer to a friendly text representation.\n\nChoices:\n0: def solution(n: int = 1001) -> int:     total = 1      for i in range(1, ceil(n / 2.0)):         odd = 2 * i + 1         even = 2 * i         total = total + 4 * odd**2 - 6 * even      return total\n1: def intword(value, format=\"%.1f\"):     try:         value = int(value)     except (TypeError, ValueError):         return value      if value < powers[0]:         return str(value)     for ordinal, power in enumerate(powers[1:], 1):         if value < power:             chopped = value / float(powers[ordinal - 1])             if float(format % chopped) == float(10**3):                 chopped = value / float(powers[ordinal])                 singular, plural = human_powers[ordinal]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped             else:                 singular, plural = human_powers[ordinal - 1]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped     return str(value)\n2: def power_iteration(     input_matrix: np.ndarray,     vector: np.ndarray,     error_tol: float = 1e-12,     max_iterations: int = 100, ) -> tuple[float, np.ndarray]:      # Ensure matrix is square.     assert np.shape(input_matrix)[0] == np.shape(input_matrix)[1]     # Ensure proper dimensionality.     assert np.shape(input_matrix)[0] == np.shape(vector)[0]     # Ensure inputs are either both complex or both real     assert np.iscomplexobj(input_matrix) == np.iscomplexobj(vector)     is_complex = np.iscomplexobj(input_matrix)     if is_complex:         # Ensure complex input_matrix is Hermitian         assert np.array_equal(input_matrix, input_matrix.conj().T)      # Set convergence to False. Will define convergence when we exceed max_iterations     # or when we have small changes from one iteration to next.      convergence = False     lambda_previous = 0     iterations = 0     error = 1e12      while not convergence:         # Multiple matrix by the vector.         w = np.dot(input_matrix, vector)         # Normalize the resulting output vector.         vector = w / np.linalg.norm(w)         # Find rayleigh quotient         # (faster than usual b/c we know vector is normalized already)         vector_h = vector.conj().T if is_complex else vector.T         lambda_ = np.dot(vector_h, np.dot(input_matrix, vector))          # Check convergence.         error = np.abs(lambda_ - lambda_previous) / lambda_         iterations += 1          if error <= error_tol or iterations >= max_iterations:             convergence = True          lambda_previous = lambda_      if is_complex:         lambda_ = np.real(lambda_)      return float(lambda_), vector", "output": "1"}
{"task": "search", "input": "search code:\nReq = 1/ (1/R1 + 1/R2 + ... + 1/Rn)\n\nChoices:\n0: def resistor_parallel(resistors: list[float]) -> float:      first_sum = 0.00     for index, resistor in enumerate(resistors):         if resistor <= 0:             msg = f\"Resistor at index {index} has a negative or zero value!\"             raise ValueError(msg)         first_sum += 1 / float(resistor)     return 1 / first_sum\n1: def topological_sort(start: str, visited: list[str], sort: list[str]) -> list[str]:     current = start     # add current to visited     visited.append(current)     neighbors = edges[current]     for neighbor in neighbors:         # if neighbor not in visited, visit         if neighbor not in visited:             sort = topological_sort(neighbor, visited, sort)     # if all neighbors visited add current to sort     sort.append(current)     # if all vertices haven't been visited select a new one to visit     if len(visited) != len(vertices):         for vertice in vertices:             if vertice not in visited:                 sort = topological_sort(vertice, visited, sort)     # return sort     return sort\n2: def matmul(m1, m2):     n = len(m2[0])     return batched(starmap(_sumprod, product(m1, transpose(m2))), n)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)", "output": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)"}
{"task": "summary", "input": "summarize code:\ndef deserialize(data: str) -> TreeNode | None:\n\n    if not data:\n        raise ValueError(\"Data cannot be empty.\")\n\n    # Split the serialized string by a comma to get node values\n    nodes = data.split(\",\")\n\n    def build_tree() -> TreeNode | None:\n        # Get the next value from the list\n        value = nodes.pop(0)\n\n        if value == \"null\":\n            return None\n\n        node = TreeNode(int(value))\n        node.left = build_tree()  # Recursively build left subtree\n        node.right = build_tree()  # Recursively build right subtree\n        return node\n\n    return build_tree()", "output": "Deserialize a string to a binary tree."}
{"task": "detection", "input": "classify code:\ndef count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions", "output": "BUGGY"}
{"task": "search", "input": "search code:\nYield the items from *iterable*, but strip any from the\n\nChoices:\n0: def solution(nth: int = 10001) -> int:     return next(itertools.islice(prime_generator(), nth - 1, nth))\n1: def strip(iterable, pred):     return rstrip(lstrip(iterable, pred), pred)\n2: def solution(n: int = 1000000) -> int:     largest_number = 1     pre_counter = 1     counters = {1: 1}      for input1 in range(2, n):         counter = 0         number = input1          while True:             if number in counters:                 counter += counters[number]                 break             if number % 2 == 0:                 number //= 2                 counter += 1             else:                 number = (3 * number) + 1                 counter += 1          if input1 not in counters:             counters[input1] = counter          if counter > pre_counter:             largest_number = input1             pre_counter = counter     return largest_number", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value", "output": "def _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value"}
{"task": "summary", "input": "summarize code:\ndef prim(graph: list, root: Vertex) -> list:\n    a = []\n    for u in graph:\n        u.key = math.inf\n        u.pi = None\n    root.key = 0\n    q = graph[:]\n    while q:\n        u = min(q)\n        q.remove(u)\n        for v in u.neighbors:\n            if (v in q) and (u.edges[v.id] < v.key):\n                v.pi = u\n                v.key = u.edges[v.id]\n    for i in range(1, len(graph)):\n        a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))\n    return a", "output": "Prim's Algorithm."}
{"task": "detection", "input": "classify code:\ndef bisect_left(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef calculate_probabilities(instance_count: int, total_count: int) -> float:\n    \"\"\"\n    Calculate the probability that a given instance will belong to which class\n    :param instance_count: number of instances in class\n    :param total_count: the number of all instances\n    :return: value of probability for considered class\n\n    >>> calculate_probabilities(20, 60)\n    0.3333333333333333\n    >>> calculate_probabilities(30, 100)\n    0.3\n    \"\"\"\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count", "output": "def calculate_probabilities(instance_count: int, total_count: int) -> float:\n    \"\"\"\n    Calculate the probability that a given instance will belong to which class\n    :param instance_count: number of instances in class\n    :param total_count: the number of all instances\n    :return: value of probability for considered class\n\n    >>> calculate_probabilities(20, 60)\n    0.3333333333333333\n    >>> calculate_probabilities(30, 100)\n    0.3\n    \"\"\"\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count"}
{"task": "summary", "input": "summarize code:\ndef bwt_transform(s: str) -> BWTTransformDict:\n    if not isinstance(s, str):\n        raise TypeError(\"The parameter s type must be str.\")\n    if not s:\n        raise ValueError(\"The parameter s must not be empty.\")\n\n    rotations = all_rotations(s)\n    rotations.sort()  # sort the list of rotations in alphabetically order\n    # make a string composed of the last char of each rotation\n    response: BWTTransformDict = {\n        \"bwt_string\": \"\".join([word[-1] for word in rotations]),\n        \"idx_original_string\": rotations.index(s),\n    }\n    return response", "output": "rotations and the index of the original string at ordered rotations list"}
{"task": "search", "input": "search code:\nFinds the maclaurin approximation of sin\n\nChoices:\n0: def area_ellipse(radius_x: float, radius_y: float) -> float:     if radius_x < 0 or radius_y < 0:         raise ValueError(\"area_ellipse() only accepts non-negative values\")     return pi * radius_x * radius_y\n1: def maclaurin_sin(theta: float, accuracy: int = 30) -> float:      if not isinstance(theta, (int, float)):         raise ValueError(\"maclaurin_sin() requires either an int or float for theta\")      if not isinstance(accuracy, int) or accuracy <= 0:         raise ValueError(\"maclaurin_sin() requires a positive int for accuracy\")      theta = float(theta)     div = theta // (2 * pi)     theta -= 2 * div * pi     return sum(         (-1) ** r * theta ** (2 * r + 1) / factorial(2 * r + 1) for r in range(accuracy)     )\n2: def couloumbs_law(     force: float, charge1: float, charge2: float, distance: float ) -> dict[str, float]:      charge_product = abs(charge1 * charge2)      if (force, charge1, charge2, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if distance < 0:         raise ValueError(\"Distance cannot be negative\")     if force == 0:         force = COULOMBS_CONSTANT * charge_product / (distance**2)         return {\"force\": force}     elif charge1 == 0:         charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)         return {\"charge1\": charge1}     elif charge2 == 0:         charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)         return {\"charge2\": charge2}     elif distance == 0:         distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5         return {\"distance\": distance}     raise ValueError(\"Exactly one argument must be 0\")", "output": "1"}
{"task": "detection", "input": "classify code:\ndef vol_cube(side_length: int | float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef wiggle_sort(nums):\n    \"\"\"Perform Wiggle Sort.\"\"\"\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef format_ruleset(ruleset: int) -> List[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]", "output": "def format_ruleset(ruleset: int) -> list[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]"}
{"task": "search", "input": "search code:\nReturn the thousands separator for a locale, default to comma.\n\nChoices:\n0: def is_valid(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> bool:     for i in range(len(word)):         if vertical:             if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":                 return False         elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":             return False     return True\n1: def num_digits_faster(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      return len(str(abs(n)))\n2: def thousands_separator() -> str:     try:         sep = _THOUSANDS_SEPARATOR[_CURRENT.locale]     except (AttributeError, KeyError):         sep = \",\"     return sep", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef calculate_signal_power(audio_fft: np.ndarray) -> np.ndarray:\n    # Calculate the power by squaring the absolute values of the FFT coefficients\n    return np.square(np.abs(audio_fft))", "output": "Calculate the power of the audio signal from its FFT."}
{"task": "search", "input": "search code:\nReturn True if n contains an even digit.\n\nChoices:\n0: def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:     return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))\n1: def get_factors(     number: int, factors: Counter | None = None, factor: int = 2 ) -> Counter:      match number:         case int(number) if number == 1:             return Counter({1: 1})         case int(num) if number > 0:             number = num         case _:             raise TypeError(\"number must be integer and greater than zero\")      factors = factors or Counter()      if number == factor:  # break condition         # all numbers are factors of itself         factors[factor] += 1         return factors      if number % factor > 0:         # if it is greater than zero         # so it is not a factor of number and we check next number         return get_factors(number, factors, factor + 1)      factors[factor] += 1     # else we update factors (that is Counter(dict-like) type) and check again     return get_factors(number // factor, factors, factor)\n2: def contains_an_even_digit(n: int) -> bool:     return any(digit in \"02468\" for digit in str(n))", "output": "2"}
{"task": "detection", "input": "classify code:\ndef exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):\n    children = tee(iterable, len(offsets))\n\n    return zip_offset(\n        *children, offsets=offsets, longest=longest, fillvalue=fillvalue\n    )", "output": "Yield tuples whose elements are offset from *iterable*."}
{"task": "repair", "input": "fix bug:\ndef sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32", "output": "def sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32"}
{"task": "repair", "input": "fix bug:\ndef scalar_multiply(matrix: List[list], n: int) -> List[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]", "output": "def scalar_multiply(matrix: list[list], n: int) -> list[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]"}
{"task": "search", "input": "search code:\nheap helper function get the position of the left child of the current node\n\nChoices:\n0: def get_child_left_position(position: int) -> int:     return (2 * position) + 1\n1: def find_pure_symbols(     clauses: list[Clause], symbols: list[str], model: dict[str, bool | None] ) -> tuple[list[str], dict[str, bool | None]]:     pure_symbols = []     assignment: dict[str, bool | None] = {}     literals = []      for clause in clauses:         if clause.evaluate(model):             continue         for literal in clause.literals:             literals.append(literal)      for s in symbols:         sym = s + \"'\"         if (s in literals and sym not in literals) or (             s not in literals and sym in literals         ):             pure_symbols.append(s)     for p in pure_symbols:         assignment[p] = None     for s in pure_symbols:         sym = s + \"'\"         if s in literals:             assignment[s] = True         elif sym in literals:             assignment[s] = False     return pure_symbols, assignment\n2: def factorial(num: int) -> int:     fact = 1     for i in range(1, num + 1):         fact *= i     return fact", "output": "0"}
{"task": "detection", "input": "classify code:\ndef calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef multiplication_table(number: int, number_of_terms: int) -> str:\n    return \"\\n\".join(\n        f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)\n    )", "output": "Prints the multiplication table of a given number till the given number of terms"}
{"task": "repair", "input": "fix bug:\ndef get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column", "output": "def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column"}
{"task": "search", "input": "search code:\nreturns a random matrix WxH with integer components\n\nChoices:\n0: def random_matrix(width: int, height: int, a: int, b: int) -> Matrix:     random.seed(None)     matrix: list[list[float]] = [         [random.randint(a, b) for _ in range(width)] for _ in range(height)     ]     return Matrix(matrix, width, height)\n1: def msd_radix_sort(list_of_ints: list[int]) -> list[int]:     if not list_of_ints:         return []      if min(list_of_ints) < 0:         raise ValueError(\"All numbers must be positive\")      most_bits = max(len(bin(x)[2:]) for x in list_of_ints)     return _msd_radix_sort(list_of_ints, most_bits)\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "0"}
{"task": "detection", "input": "classify code:\ndef create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef random_pivot(lst):\n    return choice(lst)", "output": "Choose a random pivot for the list."}
{"task": "search", "input": "search code:\nGenerates a string of roman numerals for a given integer.\n\nChoices:\n0: def solution(limit: int = 999_966_663_333) -> int:     primes_upper_bound = math.floor(math.sqrt(limit)) + 100     primes = prime_sieve(primes_upper_bound)      matches_sum = 0     prime_index = 0     last_prime = primes[prime_index]      while (last_prime**2) <= limit:         next_prime = primes[prime_index + 1]          lower_bound = last_prime**2         upper_bound = next_prime**2          # Get numbers divisible by lps(current)         current = lower_bound + last_prime         while upper_bound > current <= limit:             matches_sum += current             current += last_prime          # Reset the upper_bound         while (upper_bound - next_prime) > limit:             upper_bound -= next_prime          # Add the numbers divisible by ups(current)         current = upper_bound - next_prime         while current > lower_bound:             matches_sum += current             current -= next_prime          # Remove the numbers divisible by both ups and lps         current = 0         while upper_bound > current <= limit:             if current <= lower_bound:                 # Increment the current number                 current += last_prime * next_prime                 continue              if current > limit:                 break              # Remove twice since it was added by both ups and lps             matches_sum -= current * 2              # Increment the current number             current += last_prime * next_prime          # Setup for next pair         last_prime = next_prime         prime_index += 1      return matches_sum\n1: def generate_roman_numerals(num: int) -> str:      numerals = \"\"      m_count = num // 1000     numerals += m_count * \"M\"     num %= 1000      c_count = num // 100     if c_count == 9:         numerals += \"CM\"         c_count -= 9     elif c_count == 4:         numerals += \"CD\"         c_count -= 4     if c_count >= 5:         numerals += \"D\"         c_count -= 5     numerals += c_count * \"C\"     num %= 100      x_count = num // 10     if x_count == 9:         numerals += \"XC\"         x_count -= 9     elif x_count == 4:         numerals += \"XL\"         x_count -= 4     if x_count >= 5:         numerals += \"L\"         x_count -= 5     numerals += x_count * \"X\"     num %= 10      if num == 9:         numerals += \"IX\"         num -= 9     elif num == 4:         numerals += \"IV\"         num -= 4     if num >= 5:         numerals += \"V\"         num -= 5     numerals += num * \"I\"      return numerals\n2: def get_subreddit_data(     subreddit: str, limit: int = 1, age: str = \"new\", wanted_data: list | None = None ) -> dict:     wanted_data = wanted_data or []     if invalid_search_terms := \", \".join(sorted(set(wanted_data) - valid_terms)):         msg = f\"Invalid search term: {invalid_search_terms}\"         raise ValueError(msg)     response = httpx.get(         f\"https://www.reddit.com/r/{subreddit}/{age}.json?limit={limit}\",         headers={\"User-agent\": \"A random string\"},         timeout=10,     )     response.raise_for_status()     if response.status_code == 429:         raise httpx.HTTPError(response=response)      data = response.json()     if not wanted_data:         return {id_: data[\"data\"][\"children\"][id_] for id_ in range(limit)}      data_dict = {}     for id_ in range(limit):         data_dict[id_] = {             item: data[\"data\"][\"children\"][id_][\"data\"][item] for item in wanted_data         }     return data_dict", "output": "1"}
{"task": "detection", "input": "classify code:\ndef vol_cube(side_length: Union[int, float]) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 51) -> int:\n    unique_coefficients = get_pascal_triangle_unique_coefficients(n)\n    squarefrees = get_squarefrees(unique_coefficients)\n    return sum(squarefrees)", "output": "Returns the sum of squarefrees for a given Pascal's Triangle of depth n."}
{"task": "repair", "input": "fix bug:\ndef solution(n):\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    [2, 8]\r\n    >>> solution(15)\r\n    [2, 8]\r\n    >>> solution(2)\r\n    [2]\r\n    >>> solution(1)\r\n    []\r\n    >>> solution(34)\r\n    [2, 8, 34]\r\n    \"\"\"\r\n    ls = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            ls.append(b)\r\n        a, b = b, a + b\r\n    return ls\r", "output": "def solution(n: int = 4000000) -> int:\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    10\r\n    >>> solution(15)\r\n    10\r\n    >>> solution(2)\r\n    2\r\n    >>> solution(1)\r\n    0\r\n    >>> solution(34)\r\n    44\r\n    \"\"\"\r\n    even_fibs = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            even_fibs.append(b)\r\n        a, b = b, a + b\r\n    return sum(even_fibs)\r"}
{"task": "detection", "input": "classify code:\ndef alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    \"\"\"\n    The method arranges two lists as one list in alternative forms of the list elements.\n    :param first_input_list:\n    :param second_input_list:\n    :return: List\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\n    >>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\n    >>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef gnome_sort(unsorted):\n    \"\"\"Pure implementation of the gnome sort algorithm in Python.\"\"\"\n    if len(unsorted) <= 1:\n        return unsorted\n\n    i = 1\n\n    while i < len(unsorted):\n        if unsorted[i - 1] <= unsorted[i]:\n            i += 1\n        else:\n            unsorted[i - 1], unsorted[i] = unsorted[i], unsorted[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1", "output": "def gnome_sort(lst: list) -> list:\n    \"\"\"\n    Pure implementation of the gnome sort algorithm in Python\n\n    Take some mutable ordered collection with heterogeneous comparable items inside as\n    arguments, return the same collection ordered by ascending.\n\n    Examples:\n    >>> gnome_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> gnome_sort([])\n    []\n\n    >>> gnome_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    >>> \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\"))))\n    ' !Gadeimnoprstu'\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n\n    i = 1\n\n    while i < len(lst):\n        if lst[i - 1] <= lst[i]:\n            i += 1\n        else:\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1\n\n    return lst"}
{"task": "search", "input": "search code:\nCheck if a word can be placed at the given position.\n\nChoices:\n0: def excel_title_to_column(column_title: str) -> int:     assert column_title.isupper()     answer = 0     index = len(column_title) - 1     power = 0      while index >= 0:         value = (ord(column_title[index]) - 64) * pow(26, power)         answer += value         power += 1         index -= 1      return answer\n1: def is_valid(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> bool:     for i in range(len(word)):         if vertical:             if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":                 return False         elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":             return False     return True\n2: def solution(m: int = 100) -> int:     memo = [[0 for _ in range(m)] for _ in range(m + 1)]     for i in range(m + 1):         memo[i][0] = 1      for n in range(m + 1):         for k in range(1, m):             memo[n][k] += memo[n][k - 1]             if n > k:                 memo[n][k] += memo[n - k - 1][k]      return memo[m][m - 1] - 1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef exactly_n(iterable, n, predicate=bool):\n    iterator = filter(predicate, iterable)\n    if n <= 0:\n        if n < 0:\n            return False\n        for _ in iterator:\n            return False\n        return True\n\n    iterator = islice(iterator, n - 1, None)\n    for _ in iterator:\n        for _ in iterator:\n            return False\n        return True\n    return False", "output": "Return ``True`` if exactly ``n`` items in the iterable are ``True``"}
{"task": "detection", "input": "classify code:\ndef solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in range(1, 1001):\n        total += i ** i\n    return str(total)[-10:]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef get_format_args(fstr):\n    # TODO: memoize\n    formatter = Formatter()\n    fargs, fkwargs, _dedup = [], [], set()\n\n    def _add_arg(argname, type_char='s'):\n        if argname not in _dedup:\n            _dedup.add(argname)\n            argtype = _TYPE_MAP.get(type_char, str)  # TODO: unicode\n            try:\n                fargs.append((int(argname), argtype))\n            except ValueError:\n                fkwargs.append((argname, argtype))\n\n    for lit, fname, fspec, conv in formatter.parse(fstr):\n        if fname is not None:\n            type_char = fspec[-1:]\n            fname_list = re.split('[.[]', fname)\n            if len(fname_list) > 1:\n                raise ValueError('encountered compound format arg: %r' % fname)\n            try:\n                base_fname = fname_list[0]\n                assert base_fname\n            except (IndexError, AssertionError):\n                raise ValueError('encountered anonymous positional argument')\n            _add_arg(fname, type_char)\n            for sublit, subfname, _, _ in formatter.parse(fspec):\n                # TODO: positional and anon args not allowed here.\n                if subfname is not None:\n                    _add_arg(subfname)\n    return fargs, fkwargs", "output": "Turn a format string into two lists of arguments referenced by the"}
{"task": "repair", "input": "fix bug:\ndef luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0", "output": "def luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0"}
{"task": "search", "input": "search code:\nA version of :func:`sorted` which will happily sort an iterable of\n\nChoices:\n0: def solution(max_base: int = 10, max_power: int = 22) -> int:     bases = range(1, max_base)     powers = range(1, max_power)     return sum(         1 for power in powers for base in bases if len(str(base**power)) == power     )\n1: def make_tree() -> Node | None:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     return tree\n2: def untyped_sorted(iterable, key=None, reverse=False):     class _Wrapper:         slots = ('obj',)          def __init__(self, obj):             self.obj = obj          def __lt__(self, other):             obj = key(self.obj) if key is not None else self.obj             other = key(other.obj) if key is not None else other.obj             try:                 ret = obj < other             except TypeError:                 ret = ((type(obj).__name__, id(type(obj)), obj)                        < (type(other).__name__, id(type(other)), other))             return ret      if key is not None and not callable(key):         raise TypeError('expected function or callable object for key, not: %r'                         % key)      return sorted(iterable, key=_Wrapper, reverse=reverse)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef double_linear_search(array: list[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef power(x: int, y: int, mod: int) -> int:\n    \"\"\"\n    Examples:\n    >>> power(2, 15, 3)\n    2\n    >>> power(5, 1, 30)\n    5\n    \"\"\"\n\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, mod) % mod\n    temp = (temp * temp) % mod\n    if y % 2 == 1:\n        temp = (temp * x) % mod\n    return temp", "output": "def power(x: int, y: int, mod: int) -> int:\n    \"\"\"\n    Examples:\n    >>> power(2, 15, 3)\n    2\n    >>> power(5, 1, 30)\n    5\n    \"\"\"\n\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, mod) % mod\n    temp = (temp * temp) % mod\n    if y % 2 == 1:\n        temp = (temp * x) % mod\n    return temp"}
{"task": "search", "input": "search code:\nReturn the citation number.\n\nChoices:\n0: def rstrip(iterable, strip_value=None):     return list(rstrip_iter(iterable, strip_value))\n1: def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:     # Mark current node as visited and add to recursion stack     visited.add(vertex)     rec_stk.add(vertex)      for node in graph[vertex]:         if node not in visited:             if depth_first_search(graph, node, visited, rec_stk):                 return True         elif node in rec_stk:             return True      # The node needs to be removed from recursion stack before function ends     rec_stk.remove(vertex)     return False\n2: def get_citation(base_url: str, params: dict) -> str:     soup = BeautifulSoup(         httpx.get(base_url, params=params, timeout=10).content, \"html.parser\"     )     div = soup.find(\"div\", attrs={\"class\": \"gs_ri\"})     anchors = div.find(\"div\", attrs={\"class\": \"gs_fl\"}).find_all(\"a\")     return anchors[2].get_text()", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef power_of_4(number: int) -> bool:\n    if not isinstance(number, int):\n        raise TypeError(\"number must be an integer\")\n    if number <= 0:\n        raise ValueError(\"number must be positive\")\n    if number & (number - 1) == 0:\n        c = 0\n        while number:\n            c += 1\n            number >>= 1\n        return c % 2 == 1\n    else:\n        return False", "output": "Return True if this number is power of 4 or False otherwise."}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def calculate_span(price: list[int]) -> list[int]:     n = len(price)     s = [0] * n     # Create a stack and push index of fist element to it     st = []     st.append(0)      # Span value of first element is always 1     s[0] = 1      # Calculate span values for rest of the elements     for i in range(1, n):         # Pop elements from stack while stack is not         # empty and top of stack is smaller than price[i]         while len(st) > 0 and price[st[-1]] <= price[i]:             st.pop()          # If stack becomes empty, then price[i] is greater         # than all elements on left of it, i.e. price[0],         # price[1], ..price[i-1]. Else the price[i]  is         # greater than elements after top of stack         s[i] = i + 1 if len(st) <= 0 else (i - st[-1])          # Push this element to stack         st.append(i)      return s\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def solution(n: int = 1000000) -> int:      result = max((collatz_sequence_length(i), i) for i in range(1, n))     return result[1]", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first", "output": "def add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first"}
{"task": "detection", "input": "classify code:\ndef prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef find_triplets_with_0_sum(nums: list[int]) -> list[list[int]]:\n    return [\n        list(x)\n        for x in sorted({abc for abc in combinations(sorted(nums), 3) if not sum(abc)})\n    ]", "output": "Given a list of integers, return elements a, b, c such that a + b + c = 0."}
{"task": "repair", "input": "fix bug:\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)"}
{"task": "summary", "input": "summarize code:\ndef sliced(seq, n, strict=False):\n    iterator = takewhile(len, (seq[i : i + n] for i in count(0, n)))\n    if strict:\n\n        def ret():\n            for _slice in iterator:\n                if len(_slice) != n:\n                    raise ValueError(\"seq is not divisible by n.\")\n                yield _slice\n\n        return ret()\n    else:\n        return iterator", "output": "Yield slices of length *n* from the sequence *seq*."}
{"task": "search", "input": "search code:\nReturns the sum of all the multiples of 3 or 5 below n.\n\nChoices:\n0: def doublestarmap(func, iterable):     for item in iterable:         yield func(**item)\n1: def solution(n: int = 1000) -> int:      a = 3     result = 0     while a < n:         if a % 3 == 0 or a % 5 == 0:             result += a         elif a % 15 == 0:             result -= a         a += 1     return result\n2: def capacitor_series(capacitors: list[float]) -> float:      first_sum = 0.0     for index, capacitor in enumerate(capacitors):         if capacitor <= 0:             msg = f\"Capacitor at index {index} has a negative or zero value!\"             raise ValueError(msg)         first_sum += 1 / capacitor     return 1 / first_sum", "output": "1"}
{"task": "detection", "input": "classify code:\ndef sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn the number of chains with a starting number below one million which\n\nChoices:\n0: def base16_encode(data: bytes) -> str:     # Turn the data into a list of integers (where each integer is a byte),     # Then turn each byte into its hexadecimal representation, make sure     # it is uppercase, and then join everything together and return it.     return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])\n1: def solution(num_terms: int = 60, max_start: int = 1000000) -> int:     return sum(1 for i in range(1, max_start) if chain_length(i) == num_terms)\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef pigeon_sort(array):\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "def pigeon_sort(array):\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if(len(array) == 0):\n        return array\n\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array"}
{"task": "summary", "input": "summarize code:\ndef ncycles(iterable, n):\n    return chain.from_iterable(repeat(tuple(iterable), n))", "output": "Returns the sequence elements *n* times"}
{"task": "search", "input": "search code:\nConverts a string to capitalized case, preserving the input as is\n\nChoices:\n0: def softmax(vector):      # Calculate e^x for each x in your vector where e is Euler's     # number (approximately 2.718)     exponent_vector = np.exp(vector)      # Add up the all the exponentials     sum_of_exponents = np.sum(exponent_vector)      # Divide every exponent by the sum of all exponents     softmax_vector = exponent_vector / sum_of_exponents      return softmax_vector\n1: def to_title_case(word: str) -> str:      if \"a\" <= word[0] <= \"z\":         word = chr(ord(word[0]) - 32) + word[1:]      for i in range(1, len(word)):         if \"A\" <= word[i] <= \"Z\":             word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]      return word\n2: def in_reverse(linked_list: LinkedList) -> str:     return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)"}
{"task": "summary", "input": "summarize code:\ndef dotproduct(vec1, vec2):\n    return sum(map(mul, vec1, vec2))", "output": "Returns the dot product of the two iterables."}
{"task": "detection", "input": "classify code:\ndef decimal_to_binary(no_of_variable: int, minterms: List[float]) -> List[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef three_sum(nums: list[int]) -> list[list[int]]:\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans", "output": "Find all unique triplets in a sorted array of integers that sum up to zero."}
{"task": "search", "input": "search code:\nReturn the maximum possible sum amongst all non - empty subsequences.\n\nChoices:\n0: def longest_subsequence(array: list[int]) -> list[int]:     n = len(array)     # The longest increasing subsequence ending at array[i]     longest_increasing_subsequence = []     for i in range(n):         longest_increasing_subsequence.append([array[i]])      for i in range(1, n):         for prev in range(i):             # If array[prev] is less than or equal to array[i], then             # longest_increasing_subsequence[prev] + array[i]             # is a valid increasing subsequence              # longest_increasing_subsequence[i] is only set to             # longest_increasing_subsequence[prev] + array[i] if the length is longer.              if array[prev] <= array[i] and len(                 longest_increasing_subsequence[prev]             ) + 1 > len(longest_increasing_subsequence[i]):                 longest_increasing_subsequence[i] = copy.copy(                     longest_increasing_subsequence[prev]                 )                 longest_increasing_subsequence[i].append(array[i])      result: list[int] = []     for i in range(n):         if len(longest_increasing_subsequence[i]) > len(result):             result = longest_increasing_subsequence[i]      return result\n1: def max_subsequence_sum(nums: Sequence[int] | None = None) -> int:     if nums is None or not nums:         raise ValueError(\"Input sequence should not be empty\")      ans = nums[0]     for i in range(1, len(nums)):         num = nums[i]         ans = max(ans, ans + num, num)      return ans\n2: def example() -> int:     # Input values.     test_input = np.array(         (             [0, 0, 0],             [0, 0, 1],             [0, 1, 0],             [0, 1, 1],             [1, 0, 0],             [1, 0, 1],             [1, 1, 0],             [1, 1, 1],         ),         dtype=np.float64,     )      # True output values for the given input values.     output = np.array(([0], [1], [1], [0], [1], [0], [0], [1]), dtype=np.float64)      # Calling neural network class.     neural_network = TwoHiddenLayerNeuralNetwork(         input_array=test_input, output_array=output     )      # Calling training function.     # Set give_loss to True if you want to see loss in every iteration.     neural_network.train(output=output, iterations=10, give_loss=False)      return neural_network.predict(np.array(([1, 1, 1]), dtype=np.float64))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef calculate_probabilities(instance_count: int, total_count: int) -> float:\n    \"\"\"\n    Calculate the probability that a given instance will belong to which class\n    :param instance_count: number of instances in class\n    :param total_count: the number of all instances\n    :return: value of probability for considered class\n\n    >>> calculate_probabilities(20, 60)\n    0.3333333333333333\n    >>> calculate_probabilities(30, 100)\n    0.3\n    \"\"\"\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef get_squared_primes_to_use(\n    num_to_look: int, squared_primes: List[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx", "output": "def get_squared_primes_to_use(\n    num_to_look: int, squared_primes: list[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx"}
{"task": "repair", "input": "fix bug:\ndef calc_profit(profit: list, weight: list, max_weight: int) -> Union[str, int]:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain", "output": "def calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain"}
{"task": "summary", "input": "summarize code:\ndef astable_duty_cycle(resistance_1: float, resistance_2: float) -> float:\n\n    if resistance_1 <= 0 or resistance_2 <= 0:\n        raise ValueError(\"All values must be positive\")\n    return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100", "output": "Usage examples:"}
{"task": "search", "input": "search code:\nCalculate the binomial coefficient c(n,r) using the multiplicative formula.\n\nChoices:\n0: def is_palindrome_dict(head: ListNode | None) -> bool:     if not head or not head.next_node:         return True     d: dict[int, list[int]] = {}     pos = 0     while head:         if head.val in d:             d[head.val].append(pos)         else:             d[head.val] = [pos]         head = head.next_node         pos += 1     checksum = pos - 1     middle = 0     for v in d.values():         if len(v) % 2 != 0:             middle += 1         else:             for step, i in enumerate(range(len(v))):                 if v[i] + v[len(v) - 1 - step] != checksum:                     return False         if middle > 1:             return False     return True\n1: def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:     return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2\n2: def choose(n: int, r: int) -> int:     ret = 1.0     for i in range(1, r + 1):         ret *= (n + 1 - i) / i     return round(ret)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef text_to_bits(text, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_to_bits(\"msg\")\n    '011011010111001101100111'\n    \"\"\"\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \"big\"))[2:]\n    return bits.zfill(8 * ((len(bits) + 7) // 8))", "output": "CORRECT"}
{"task": "search", "input": "search code:\nPrecomputing squares and checking if a^2 + b^2 is the square by set look-up.\n\nChoices:\n0: def solution(max_n: int = 10000000) -> int:      min_numerator = 1  # i     min_denominator = 0  # Ï†(i)     totients = get_totients(max_n + 1)      for i in range(2, max_n + 1):         t = totients[i]          if i * min_denominator < min_numerator * t and has_same_digits(i, t):             min_numerator = i             min_denominator = t      return min_numerator\n1: def solution(n: int = 1000) -> int:      squares = get_squares(n)     squares_set = set(squares)     for a in range(1, n // 3):         for b in range(a + 1, (n - a) // 2 + 1):             if (                 squares[a] + squares[b] in squares_set                 and squares[n - a - b] == squares[a] + squares[b]             ):                 return a * b * (n - a - b)      return -1\n2: def _pgettext(msgctxt, message):     # This GNU gettext function was added in Python 3.8, so for older versions we     # reimplement it. It works by joining `msgctx` and `message` by '4' byte.     try:         # Python 3.8+         return get_translation().pgettext(msgctxt, message)     except AttributeError:         # Python 3.7 and older         key = msgctxt + \"\\x04\" + message         translation = get_translation().gettext(key)         return message if translation == key else translation", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef print_binary_search_tree(root, key, i, j, parent, is_left):\n    if i > j or i < 0 or j > len(root) - 1:\n        return\n\n    node = root[i][j]\n    if parent == -1:  # root does not have a parent\n        print(f\"{key[node]} is the root of the binary search tree.\")\n    elif is_left:\n        print(f\"{key[node]} is the left child of key {parent}.\")\n    else:\n        print(f\"{key[node]} is the right child of key {parent}.\")\n\n    print_binary_search_tree(root, key, i, node - 1, key[node], True)\n    print_binary_search_tree(root, key, node + 1, j, key[node], False)", "output": "Recursive function to print a BST from a root table."}
{"task": "repair", "input": "fix bug:\ndef dp_count(S, m, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 3, 4)\n    4\n    >>> dp_count([1, 2, 3], 3, 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 4, 10)\n    5\n    >>> dp_count([10], 1, 99)\n    0\n    >>> dp_count([4, 5, 6], 3, 0)\n    1\n    \"\"\"\n\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]", "output": "def dp_count(S, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 4)\n    4\n    >>> dp_count([1, 2, 3], 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 10)\n    5\n    >>> dp_count([10], 99)\n    0\n    >>> dp_count([4, 5, 6], 0)\n    1\n    >>> dp_count([1, 2, 3], -5)\n    0\n    \"\"\"\n    if n < 0:\n        return 0\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]"}
{"task": "detection", "input": "classify code:\ndef calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nRuns k-means on given data and initial set of centroids.\n\nChoices:\n0: def find_max_area(mat: list[list[int]]) -> int:     seen: set = set()      max_area = 0     for row, line in enumerate(mat):         for col, item in enumerate(line):             if item == 1 and (row, col) not in seen:                 # Maximizing the area                 max_area = max(max_area, depth_first_search(row, col, seen, mat))     return max_area\n1: def real_power(apparent_power: float, power_factor: float) -> float:     if (         not isinstance(power_factor, (int, float))         or power_factor < -1         or power_factor > 1     ):         raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")     return apparent_power * power_factor\n2: def kmeans(     data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False ):     centroids = initial_centroids[:]     prev_cluster_assignment = None      for itr in range(maxiter):         if verbose:             print(itr, end=\"\")          # 1. Make cluster assignments using nearest centroids         cluster_assignment = assign_clusters(data, centroids)          # 2. Compute a new centroid for each of the k clusters, averaging all data         #    points assigned to that cluster.         centroids = revise_centroids(data, k, cluster_assignment)          # Check for convergence: if none of the assignments changed, stop         if (             prev_cluster_assignment is not None             and (prev_cluster_assignment == cluster_assignment).all()         ):             break          # Print number of new assignments         if prev_cluster_assignment is not None:             num_changed = np.sum(prev_cluster_assignment != cluster_assignment)             if verbose:                 print(                     f\"    {num_changed:5d} elements changed their cluster assignment.\"                 )          # Record heterogeneity convergence metric         if record_heterogeneity is not None:             # YOUR CODE HERE             score = compute_heterogeneity(data, k, centroids, cluster_assignment)             record_heterogeneity.append(score)          prev_cluster_assignment = cluster_assignment[:]      return centroids, cluster_assignment", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef swap(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b", "output": "def swap(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b"}
{"task": "detection", "input": "classify code:\ndef calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area", "output": "Function updates the largest_square_area, using bottom up approach."}
{"task": "summary", "input": "summarize code:\ndef compress_data(data_bits: str) -> str:\n    lexicon = {\"0\": \"0\", \"1\": \"1\"}\n    result, curr_string = \"\", \"\"\n    index = len(lexicon)\n\n    for i in range(len(data_bits)):\n        curr_string += data_bits[i]\n        if curr_string not in lexicon:\n            continue\n\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n        add_key_to_lexicon(lexicon, curr_string, index, last_match_id)\n        index += 1\n        curr_string = \"\"\n\n    while curr_string != \"\" and curr_string not in lexicon:\n        curr_string += \"0\"\n\n    if curr_string != \"\":\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n\n    return result", "output": "Compresses given data_bits using Lempel-Ziv-Welch compression algorithm"}
{"task": "detection", "input": "classify code:\ndef binary_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return None", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCeq = 1/ (1/C1 + 1/C2 + ... + 1/Cn)\n\nChoices:\n0: def dijk(g, s):     dist, known, path = {s: 0}, set(), {s: 0}     while True:         if len(known) == len(g) - 1:             break         mini = 100000         for key, value in dist:             if key not in known and value < mini:                 mini = value                 u = key         known.add(u)         for v in g[u]:             if v[0] not in known and dist[u] + v[1] < dist.get(v[0], 100000):                 dist[v[0]] = dist[u] + v[1]                 path[v[0]] = u     for key, value in dist.items():         if key != s:             print(value)\n1: def capacitor_series(capacitors: list[float]) -> float:      first_sum = 0.0     for index, capacitor in enumerate(capacitors):         if capacitor <= 0:             msg = f\"Capacitor at index {index} has a negative or zero value!\"             raise ValueError(msg)         first_sum += 1 / capacitor     return 1 / first_sum\n2: def print_binary_search_tree(root, key, i, j, parent, is_left):     if i > j or i < 0 or j > len(root) - 1:         return      node = root[i][j]     if parent == -1:  # root does not have a parent         print(f\"{key[node]} is the root of the binary search tree.\")     elif is_left:         print(f\"{key[node]} is the left child of key {parent}.\")     else:         print(f\"{key[node]} is the right child of key {parent}.\")      print_binary_search_tree(root, key, i, node - 1, key[node], True)     print_binary_search_tree(root, key, node + 1, j, key[node], False)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef left_shift(data):\n    \"\"\"\n    >>> left_shift(\"0123456789\")\n    '1234567890'\n    \"\"\"\n    return data[1:] + data[0]", "output": "def left_shift(data):\n    \"\"\"\n    >>> left_shift(\"0123456789\")\n    '1234567890'\n    \"\"\"\n    return data[1:] + data[0]"}
{"task": "summary", "input": "summarize code:\ndef filter_except(validator, iterable, *exceptions):\n    for item in iterable:\n        try:\n            validator(item)\n        except exceptions:\n            pass\n        else:\n            yield item", "output": "Yield the items from *iterable* for which the *validator* function does"}
{"task": "detection", "input": "classify code:\ndef calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)", "output": "def decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)"}
{"task": "search", "input": "search code:\nReturns a shallow copy of the function, including code object,\n\nChoices:\n0: def get_filter_points(     sample_rate: int,     freq_min: int,     freq_high: int,     mel_filter_num: int = 10,     ftt_size: int = 1024, ) -> tuple[np.ndarray, np.ndarray]:     # Convert minimum and maximum frequencies to mel scale     fmin_mel = freq_to_mel(freq_min)     fmax_mel = freq_to_mel(freq_high)      logging.info(f\"MEL min: {fmin_mel}\")     logging.info(f\"MEL max: {fmax_mel}\")      # Generate equally spaced mel frequencies     mels = np.linspace(fmin_mel, fmax_mel, num=mel_filter_num + 2)      # Convert mel frequencies back to Hertz     freqs = mel_to_freq(mels)      # Calculate filter points as integer values     filter_points = np.floor((ftt_size + 1) / sample_rate * freqs).astype(int)      return filter_points, freqs\n1: def copy_function(orig, copy_dict=True):     ret = FunctionType(orig.__code__,                        orig.__globals__,                        name=orig.__name__,                        argdefs=getattr(orig, \"__defaults__\", None),                        closure=getattr(orig, \"__closure__\", None))     if hasattr(orig, \"__kwdefaults__\"):         ret.__kwdefaults__ = orig.__kwdefaults__     if copy_dict:         ret.__dict__.update(orig.__dict__)     return ret\n2: def update(highway_now: list, probability: float, max_speed: int) -> list:      number_of_cells = len(highway_now)     # Beforce calculations, the highway is empty     next_highway = [-1] * number_of_cells      for car_index in range(number_of_cells):         if highway_now[car_index] != -1:             # Add 1 to the current speed of the car and cap the speed             next_highway[car_index] = min(highway_now[car_index] + 1, max_speed)             # Number of empty cell before the next car             dn = get_distance(highway_now, car_index) - 1             # We can't have the car causing an accident             next_highway[car_index] = min(next_highway[car_index], dn)             if random() < probability:                 # Randomly, a driver will slow down                 next_highway[car_index] = max(next_highway[car_index] - 1, 0)     return next_highway", "output": "1"}
{"task": "search", "input": "search code:\nStrips values from the end of an iterable. Stripped items will\n\nChoices:\n0: def rstrip_iter(iterable, strip_value=None):     iterator = iter(iterable)     for i in iterator:         if i == strip_value:             cache = list()             cache.append(i)             broken = False             for i in iterator:                 if i == strip_value:                     cache.append(i)                 else:                     broken = True                     break             if not broken:  # Return to caller here because the end of the                 return     # iterator has been reached             yield from cache         yield i\n1: def solution(first_x_coord: float = 1.4, first_y_coord: float = -9.6) -> int:     num_reflections: int = 0     point_x: float = first_x_coord     point_y: float = first_y_coord     gradient: float = (10.1 - point_y) / (0.0 - point_x)      while not (-0.01 <= point_x <= 0.01 and point_y > 0):         point_x, point_y, gradient = next_point(point_x, point_y, gradient)         num_reflections += 1      return num_reflections\n2: def xor_gate(input_1: int, input_2: int) -> int:     return (input_1, input_2).count(0) % 2", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef slugify(text, delim='_', lower=True, ascii=False):\n    ret = delim.join(split_punct_ws(text)) or delim if text else ''\n    if ascii:\n        ret = asciify(ret)\n    if lower:\n        ret = ret.lower()\n    return ret", "output": "A basic function that turns text full of scary characters"}
{"task": "repair", "input": "fix bug:\ndef all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\n    \"\"\"\n    returns the list containing all the possible\n    combinations a string(`target`) can be constructed from\n    the given list of substrings(`word_bank`)\n\n    >>> all_construct(\"hello\", [\"he\", \"l\", \"o\"])\n    [['he', 'l', 'l', 'o']]\n    >>> all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"])\n    [['purp', 'le'], ['p', 'ur', 'p', 'le']]\n    \"\"\"\n\n    word_bank = word_bank or []\n    # create a table\n    table_size: int = len(target) + 1\n\n    table: list[list[list[str]]] = []\n    for _ in range(table_size):\n        table.append([])\n    # seed value\n    table[0] = [[]]  # because empty string has empty combination\n\n    # iterate through the indices\n    for i in range(table_size):\n        # condition\n        if table[i] != []:\n            for word in word_bank:\n                # slice condition\n                if target[i : i + len(word)] == word:\n                    new_combinations: list[list[str]] = [\n                        [word, *way] for way in table[i]\n                    ]\n                    # adds the word to every combination the current position holds\n                    # now,push that combination to the table[i+len(word)]\n                    table[i + len(word)] += new_combinations\n\n    # combinations are in reverse order so reverse for better output\n    for combination in table[len(target)]:\n        combination.reverse()\n\n    return table[len(target)]", "output": "def all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\n    \"\"\"\n    returns the list containing all the possible\n    combinations a string(`target`) can be constructed from\n    the given list of substrings(`word_bank`)\n\n    >>> all_construct(\"hello\", [\"he\", \"l\", \"o\"])\n    [['he', 'l', 'l', 'o']]\n    >>> all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"])\n    [['purp', 'le'], ['p', 'ur', 'p', 'le']]\n    \"\"\"\n\n    word_bank = word_bank or []\n    # create a table\n    table_size: int = len(target) + 1\n\n    table: list[list[list[str]]] = []\n    for _ in range(table_size):\n        table.append([])\n    # seed value\n    table[0] = [[]]  # because empty string has empty combination\n\n    # iterate through the indices\n    for i in range(table_size):\n        # condition\n        if table[i] != []:\n            for word in word_bank:\n                # slice condition\n                if target[i : i + len(word)] == word:\n                    new_combinations: list[list[str]] = [\n                        [word, *way] for way in table[i]\n                    ]\n                    # adds the word to every combination the current position holds\n                    # now,push that combination to the table[i+len(word)]\n                    table[i + len(word)] += new_combinations\n\n    # combinations are in reverse order so reverse for better output\n    for combination in table[len(target)]:\n        combination.reverse()\n\n    return table[len(target)]"}
{"task": "detection", "input": "classify code:\ndef text_from_bits(bits, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_from_bits('011011010111001101100111')\n    'msg'\n    \"\"\"\n    n = int(bits, 2)\n    return n.to_bytes((n.bit_length() + 7) // 8, \"big\").decode(encoding, errors) or \"\\0\"", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef nth_fibonacci_bruteforce(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_bruteforce(100)\n    354224848179261915075\n    >>> nth_fibonacci_bruteforce(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    fib0 = 0\n    fib1 = 1\n    for _ in range(2, n + 1):\n        fib0, fib1 = fib1, fib0 + fib1\n    return fib1", "output": "def nth_fibonacci_bruteforce(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_bruteforce(100)\n    354224848179261915075\n    >>> nth_fibonacci_bruteforce(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    fib0 = 0\n    fib1 = 1\n    for _ in range(2, n + 1):\n        fib0, fib1 = fib1, fib0 + fib1\n    return fib1"}
{"task": "summary", "input": "summarize code:\ndef lstrip(iterable, pred):\n    return dropwhile(pred, iterable)", "output": "Yield the items from *iterable*, but strip any from the beginning"}
{"task": "search", "input": "search code:\nGroup values in the *src* iterable by the value returned by *key*.\n\nChoices:\n0: def chunked(iterable, n, strict=False):     iterator = iter(partial(take, n, iter(iterable)), [])     if strict:         if n is None:             raise ValueError('n must not be None when using strict mode.')          def ret():             for chunk in iterator:                 if len(chunk) != n:                     raise ValueError('iterable is not divisible by n.')                 yield chunk          return ret()     else:         return iterator\n1: def bucketize(src, key=bool, value_transform=None, key_filter=None):     if not is_iterable(src):         raise TypeError('expected an iterable')     elif isinstance(key, list):         if len(key) != len(src):             raise ValueError(\"key and src have to be the same length\")         src = zip(key, src)      if isinstance(key, str):         def key_func(x): return getattr(x, key, x)     elif callable(key):         key_func = key     elif isinstance(key, list):         def key_func(x): return x[0]     else:         raise TypeError('expected key to be callable or a string or a list')      if value_transform is None:         def value_transform(x): return x     if not callable(value_transform):         raise TypeError('expected callable value transform function')     if isinstance(key, list):         f = value_transform         def value_transform(x): return f(x[1])      ret = {}     for val in src:         key_of_val = key_func(val)         if key_filter is None or key_filter(key_of_val):             ret.setdefault(key_of_val, []).append(value_transform(val))     return ret\n2: def find_set(x: Node) -> Node:     if x != x.parent:         x.parent = find_set(x.parent)     return x.parent", "output": "1"}
{"task": "detection", "input": "classify code:\ndef luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef backtrack(input_string: str, word_dict: set[str], start: int) -> bool:\n    \"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\n\n    # Base case: if the starting index has reached the end of the string\n    if start == len(input_string):\n        return True\n\n    # Try every possible substring from 'start' to 'end'\n    for end in range(start + 1, len(input_string) + 1):\n        if input_string[start:end] in word_dict and backtrack(\n            input_string, word_dict, end\n        ):\n            return True\n\n    return False", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum", "output": "def sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum"}
{"task": "search", "input": "search code:\nreturn the harmonic mean of series\n\nChoices:\n0: def interquartile_range_checker(train_user: list) -> float:     train_user.sort()     q1 = np.percentile(train_user, 25)     q3 = np.percentile(train_user, 75)     iqr = q3 - q1     low_lim = q1 - (iqr * 0.1)     return float(low_lim)\n1: def longest_common_substring(text1: str, text2: str) -> str:      if not (isinstance(text1, str) and isinstance(text2, str)):         raise ValueError(\"longest_common_substring() takes two strings for inputs\")      if not text1 or not text2:         return \"\"      text1_length = len(text1)     text2_length = len(text2)      dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]     end_pos = 0     max_length = 0      for i in range(1, text1_length + 1):         for j in range(1, text2_length + 1):             if text1[i - 1] == text2[j - 1]:                 dp[i][j] = 1 + dp[i - 1][j - 1]                 if dp[i][j] > max_length:                     end_pos = i                     max_length = dp[i][j]      return text1[end_pos - max_length : end_pos]\n2: def harmonic_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 0     for val in series:         answer += 1 / val     return len(series) / answer", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef geometric_mean(series: list) -> float:\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 1\n    for value in series:\n        answer *= value\n    return pow(answer, 1 / len(series))", "output": "return the geometric mean of series"}
{"task": "detection", "input": "classify code:\ndef get_totients(max_one: int) -> List[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "def calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]"}
{"task": "summary", "input": "summarize code:\ndef run_length_encode(text: str) -> list:\n    encoded = []\n    count = 1\n\n    for i in range(len(text)):\n        if i + 1 < len(text) and text[i] == text[i + 1]:\n            count += 1\n        else:\n            encoded.append((text[i], count))\n            count = 1\n\n    return encoded", "output": "Performs Run Length Encoding"}
{"task": "search", "input": "search code:\nA variant of :func:`takewhile` that allows complete access to the\n\nChoices:\n0: def before_and_after(predicate, it):     trues, after = tee(it)     trues = compress(takewhile(predicate, trues), zip(after))     return trues, after\n1: def reverse_letters(sentence: str, length: int = 0) -> str:     return \" \".join(         \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()     )\n2: def max_subarray_sum(     arr: Sequence[float], allow_empty_subarrays: bool = False ) -> float:     if not arr:         return 0      max_sum = 0 if allow_empty_subarrays else float(\"-inf\")     curr_sum = 0.0     for num in arr:         curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)         max_sum = max(max_sum, curr_sum)      return max_sum", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef equilibrium_index(arr: list[int], size: int) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr : The input array of integers.\n        size : The size of the array.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0], 7)\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5], 5)\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1], 5)\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3], 6)\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i in range(size):\n        total_sum -= arr[i]\n        if left_sum == total_sum:\n            return i\n        left_sum += arr[i]\n\n    return -1", "output": "def equilibrium_index(arr: list[int]) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5])\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1])\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3])\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i, value in enumerate(arr):\n        total_sum -= value\n        if left_sum == total_sum:\n            return i\n        left_sum += value\n\n    return -1"}
{"task": "detection", "input": "classify code:\ndef tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef benchmark() -> None:\n    from timeit import timeit\n\n    print(\"Running benchmarks\")\n    setup = (\n        \"from __main__ import count_negatives_binary_search, \"\n        \"count_negatives_brute_force, count_negatives_brute_force_with_break, grid\"\n    )\n    for func in (\n        \"count_negatives_binary_search\",  # took 0.7727 seconds\n        \"count_negatives_brute_force_with_break\",  # took 4.6505 seconds\n        \"count_negatives_brute_force\",  # took 12.8160 seconds\n    ):\n        time = timeit(f\"{func}(grid=grid)\", setup=setup, number=500)\n        print(f\"{func}() took {time:0.4f} seconds\")", "output": "Benchmark our functions next to each other"}
{"task": "search", "input": "search code:\nDriver function to execute PCA and display results.\n\nChoices:\n0: def encode(word: str) -> str:     encoded = \"\"     for letter in word.lower():         if letter.isalpha() or letter == \" \":             encoded += encode_dict[letter]         else:             raise Exception(\"encode() accepts only letters of the alphabet and spaces\")     return encoded\n1: def main() -> None:     data_x, _data_y = collect_dataset()      # Number of principal components to retain     n_components = 2      # Apply PCA     transformed_data, variance_ratio = apply_pca(data_x, n_components)      print(\"Transformed Dataset (First 5 rows):\")     print(transformed_data[:5])      print(\"\\nExplained Variance Ratio:\")     print(variance_ratio)\n2: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef calc_profit(profit: list, weight: list, max_weight: int) -> Union[str, int]:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain", "output": "def calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain"}
{"task": "detection", "input": "classify code:\ndef optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost", "output": "CORRECT"}
{"task": "search", "input": "search code:\nYields results from a function repeatedly until an exception is raised.\n\nChoices:\n0: def fibonacci(k: int) -> int:     if not isinstance(k, int):         raise TypeError(\"k must be an integer.\")     if k < 0:         raise ValueError(\"k integer must be greater or equal to zero.\")     if k == 0:         return 0     elif k == 1:         return 1     else:         return fibonacci(k - 1) + fibonacci(k - 2)\n1: def replace(iterable, pred, substitutes, count=None, window_size=1):     if window_size < 1:         raise ValueError('window_size must be at least 1')      # Save the substitutes iterable, since it's used more than once     substitutes = tuple(substitutes)      # Add padding such that the number of windows matches the length of the     # iterable     it = chain(iterable, repeat(_marker, window_size - 1))     windows = windowed(it, window_size)      n = 0     for w in windows:         # If the current window matches our predicate (and we haven't hit         # our maximum number of replacements), splice in the substitutes         # and then consume the following windows that overlap with this one.         # For example, if the iterable is (0, 1, 2, 3, 4...)         # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...         # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)         if pred(*w):             if (count is None) or (n < count):                 n += 1                 yield from substitutes                 consume(windows, window_size - 1)                 continue          # If there was no match (or we've reached the replacement limit),         # yield the first item from the window.         if w and (w[0] is not _marker):             yield w[0]\n2: def iter_except(func, exception, first=None):     with suppress(exception):         if first is not None:             yield first()         while True:             yield func()", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef first(iterable, default=_marker):\n    for item in iterable:\n        return item\n    if default is _marker:\n        raise ValueError(\n            'first() was called on an empty iterable, '\n            'and no default value was provided.'\n        )\n    return default", "output": "Return the first item of *iterable*, or *default* if *iterable* is"}
{"task": "detection", "input": "classify code:\ndef longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns all the possible families of digit replacements in a number which\n\nChoices:\n0: def patience_sort(collection: list) -> list:     stacks: list[Stack] = []     # sort into stacks     for element in collection:         new_stacks = Stack([element])         i = bisect_left(stacks, new_stacks)         if i != len(stacks):             stacks[i].append(element)         else:             stacks.append(new_stacks)      # use a heap-based merge to merge stack efficiently     collection[:] = merge(*(reversed(stack) for stack in stacks))     return collection\n1: def parse_token(token: str | float) -> float | str:     if token in OPERATORS:         return token     try:         return float(token)     except ValueError:         msg = f\"{token} is neither a number nor a valid operator\"         raise ValueError(msg)\n2: def digit_replacements(number: int) -> list[list[int]]:     number_str = str(number)     replacements = []     digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]      for duplicate in Counter(number_str) - Counter(set(number_str)):         family = [int(number_str.replace(duplicate, digit)) for digit in digits]         replacements.append(family)      return replacements", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef n31(a: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)", "output": "def n31(a: int) -> tuple[list[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    prev_numerator, prev_denominator = 1, 1\n    result = []\n    for i in range(1, n + 1):\n        numerator = prev_numerator + 2 * prev_denominator\n        denominator = prev_numerator + prev_denominator\n        if len(str(numerator)) > len(str(denominator)):\n            result.append(i)\n        prev_numerator = numerator\n        prev_denominator = denominator\n\n    return len(result)", "output": "returns number of fractions containing a numerator with more digits than"}
{"task": "detection", "input": "classify code:\ndef score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef check(number: int) -> bool:\n\n    check_last = [0] * 11\n    check_front = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    if not f:\n        return f\n\n    # mark first 9 numbers\n    number = int(str(number)[:9])\n\n    for _ in range(9):\n        check_front[int(number % 10)] = 1\n        number = number // 10\n\n    # check first 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_front[x + 1]:\n            f = False\n    return f", "output": "Takes a number and checks if it is pandigital both from start and end"}
{"task": "search", "input": "search code:\nValidates the adjacency list format for the graph.\n\nChoices:\n0: def validate_adjacency_list(graph: list[list[int | None]]) -> None:     if not isinstance(graph, list):         raise ValueError(\"Graph should be a list of lists.\")      for node_index, neighbors in enumerate(graph):         if not isinstance(neighbors, list):             no_neighbors_message: str = (                 f\"Node {node_index} should have a list of neighbors.\"             )             raise ValueError(no_neighbors_message)         for neighbor_index in neighbors:             if (                 not isinstance(neighbor_index, int)                 or neighbor_index < 0                 or neighbor_index >= len(graph)             ):                 invalid_neighbor_message: str = (                     f\"Invalid neighbor {neighbor_index} in node {node_index} \"                     f\"adjacency list.\"                 )                 raise ValueError(invalid_neighbor_message)\n1: def get_rotation(     img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int ) -> np.ndarray:     matrix = cv2.getAffineTransform(pt1, pt2)     return cv2.warpAffine(img, matrix, (rows, cols))\n2: def eval_exponential(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:     return np.exp(z_values) + c_parameter", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans", "output": "def three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans"}
{"task": "detection", "input": "classify code:\ndef abs_max(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef abbr(a: str, b: str) -> bool:\n    \"\"\"\n    >>> abbr(\"daBcd\", \"ABC\")\n    True\n    >>> abbr(\"dBcd\", \"ABC\")\n    False\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m + 1):\n            if dp[i][j]:\n                if j < m and a[i].upper() == b[j]:\n                    dp[i + 1][j + 1] = True\n                if a[i].islower():\n                    dp[i + 1][j] = True\n    return dp[n][m]", "output": "def abbr(a: str, b: str) -> bool:\n    \"\"\"\n    >>> abbr(\"daBcd\", \"ABC\")\n    True\n    >>> abbr(\"dBcd\", \"ABC\")\n    False\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m + 1):\n            if dp[i][j]:\n                if j < m and a[i].upper() == b[j]:\n                    dp[i + 1][j + 1] = True\n                if a[i].islower():\n                    dp[i + 1][j] = True\n    return dp[n][m]"}
{"task": "summary", "input": "summarize code:\ndef rotate(\n    x: float, y: float, z: float, axis: str, angle: float\n) -> tuple[float, float, float]:\n    if not isinstance(axis, str):\n        raise TypeError(\"Axis must be a str\")\n    input_variables = locals()\n    del input_variables[\"axis\"]\n    if not all(isinstance(val, (float, int)) for val in input_variables.values()):\n        msg = (\n            \"Input values except axis must either be float or int: \"\n            f\"{list(input_variables.values())}\"\n        )\n        raise TypeError(msg)\n    angle = (angle % 360) / 450 * 180 / math.pi\n    if axis == \"z\":\n        new_x = x * math.cos(angle) - y * math.sin(angle)\n        new_y = y * math.cos(angle) + x * math.sin(angle)\n        new_z = z\n    elif axis == \"x\":\n        new_y = y * math.cos(angle) - z * math.sin(angle)\n        new_z = z * math.cos(angle) + y * math.sin(angle)\n        new_x = x\n    elif axis == \"y\":\n        new_x = x * math.cos(angle) - z * math.sin(angle)\n        new_z = z * math.cos(angle) + x * math.sin(angle)\n        new_y = y\n    else:\n        raise ValueError(\"not a valid axis, choose one of 'x', 'y', 'z'\")\n\n    return new_x, new_y, new_z", "output": "rotate a point around a certain axis with a certain angle"}
{"task": "search", "input": "search code:\nA pure Python implementation of the insertion sort algorithm\n\nChoices:\n0: def insertion_sort[T: Comparable](collection: MutableSequence[T]) -> MutableSequence[T]:      for insert_index in range(1, len(collection)):         insert_value = collection[insert_index]         while insert_index > 0 and insert_value < collection[insert_index - 1]:             collection[insert_index] = collection[insert_index - 1]             insert_index -= 1         collection[insert_index] = insert_value     return collection\n1: def ceil(x: float) -> int:     return int(x) if x - int(x) <= 0 else int(x) + 1\n2: def collect_dataset():     response = httpx.get(         \"https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/\"         \"master/Week1/ADRvsRating.csv\",         timeout=10,     )     lines = response.text.splitlines()     data = []     for item in lines:         item = item.split(\",\")         data.append(item)     data.pop(0)  # This is for removing the labels from the list     dataset = np.matrix(data)     return dataset", "output": "0"}
{"task": "search", "input": "search code:\nReturns the sum of all the amicable numbers under n.\n\nChoices:\n0: def solution(n: int = 10000) -> int:     total = sum(         i         for i in range(1, n)         if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i     )     return total\n1: def ceil(x: float) -> int:     return int(x) if x - int(x) <= 0 else int(x) + 1\n2: def iter_index(iterable, value, start=0, stop=None):     seq_index = getattr(iterable, 'index', None)     if seq_index is None:         # Slow path for general iterables         iterator = islice(iterable, start, stop)         for i, element in enumerate(iterator, start):             if element is value or element == value:                 yield i     else:         # Fast path for sequences         stop = len(iterable) if stop is None else stop         i = start - 1         with suppress(ValueError):             while True:                 yield (i := seq_index(value, i + 1, stop))", "output": "0"}
{"task": "detection", "input": "classify code:\ndef is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef preprocess(edge_array):\n    for i in range(len(edge_array)):\n        for j in range(len(edge_array[i])):\n            t = edge_array[i][j].split(\"-\")\n            edge_array[i][j] = t", "output": "Preprocess the edge array"}
{"task": "repair", "input": "fix bug:\ndef _count_cross_inversions(p, q):\n    \"\"\"\n    Counts the inversions across two sorted arrays.\n    And combine the two arrays into one sorted array\n    For all 1<= i<=len(P) and for all 1 <= j <= len(Q),\n    if P[i] > Q[j], then (i, j) is a cross inversion\n    Parameters\n    ----------\n    P: array-like, sorted in non-decreasing order\n    Q: array-like, sorted in non-decreasing order\n    Returns\n    ------\n    R: array-like, a sorted array of the elements of `P` and `Q`\n    num_inversion: int, the number of inversions across `P` and `Q`\n    Examples\n    --------\n    >>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\n    ([0, 1, 2, 2, 3, 5], 4)\n    >>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\n    ([1, 2, 3, 3, 4, 5], 0)\n    \"\"\"\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion", "output": "def _count_cross_inversions(p, q):\n    \"\"\"\n    Counts the inversions across two sorted arrays.\n    And combine the two arrays into one sorted array\n    For all 1<= i<=len(P) and for all 1 <= j <= len(Q),\n    if P[i] > Q[j], then (i, j) is a cross inversion\n    Parameters\n    ----------\n    P: array-like, sorted in non-decreasing order\n    Q: array-like, sorted in non-decreasing order\n    Returns\n    ------\n    R: array-like, a sorted array of the elements of `P` and `Q`\n    num_inversion: int, the number of inversions across `P` and `Q`\n    Examples\n    --------\n    >>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\n    ([0, 1, 2, 2, 3, 5], 4)\n    >>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\n    ([1, 2, 3, 3, 4, 5], 0)\n    \"\"\"\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion"}
{"task": "detection", "input": "classify code:\ndef knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef binary_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return None", "output": "def binary_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1"}
{"task": "search", "input": "search code:\nFunction using divide and conquer to calculate a^b.\n\nChoices:\n0: def actual_power(a: int, b: int) -> int:     if b == 0:         return 1     half = actual_power(a, b // 2)      if (b % 2) == 0:         return half * half     else:         return a * half * half\n1: def main() -> None:     lower = int(input(\"Enter lower value : \").strip())     higher = int(input(\"Enter high value : \").strip())     guess = int(input(\"Enter value to guess : \").strip())     guess_the_number(lower, higher, guess)\n2: def surface_area_cube(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"surface_area_cube() only accepts non-negative values\")     return 6 * side_length**2", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef eval_exponential(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:\n    return np.exp(z_values) + c_parameter", "output": "Evaluate $e^z + c$."}
{"task": "repair", "input": "fix bug:\ndef filter_common_word(possibles: List[str], common_word: str) -> List[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]", "output": "def filter_common_word(possibles: list[str], common_word: str) -> list[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]"}
