{"task": "summary", "input": "summarize code:\ndef quote_fragment_part(text, full_quote=True):\n    if full_quote:\n        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')\n        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])\n    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t\n                     for t in text])", "output": "Quote the fragment part of the URL. Fragments don't have"}
{"task": "search", "input": "search code:\nSolves the integer weights knapsack problem returns one of\n\nChoices:\n0: def freq_to_mel(freq: float) -> float:     # Use the formula to convert frequency to the mel scale     return 2595.0 * np.log10(1.0 + freq / 700.0)\n1: def knapsack_with_example_solution(w: int, wt: list, val: list):     if not (isinstance(wt, (list, tuple)) and isinstance(val, (list, tuple))):         raise ValueError(             \"Both the weights and values vectors must be either lists or tuples\"         )      num_items = len(wt)     if num_items != len(val):         msg = (             \"The number of weights must be the same as the number of values.\\n\"             f\"But got {num_items} weights and {len(val)} values\"         )         raise ValueError(msg)     for i in range(num_items):         if not isinstance(wt[i], int):             msg = (                 \"All weights must be integers but got weight of \"                 f\"type {type(wt[i])} at index {i}\"             )             raise TypeError(msg)      optimal_val, dp_table = knapsack(w, wt, val, num_items)     example_optional_set: set = set()     _construct_solution(dp_table, wt, num_items, w, example_optional_set)      return optimal_val, example_optional_set\n2: def chunked(src, size, count=None, **kw):     chunk_iter = chunked_iter(src, size, **kw)     if count is None:         return list(chunk_iter)     else:         return list(itertools.islice(chunk_iter, count))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef is_9_pandigital(n: int) -> bool:\n    \"\"\"\n    Checks whether n is a 9-digit 1 to 9 pandigital number.\n    >>> is_9_pandigital(12345)\n    False\n    >>> is_9_pandigital(156284973)\n    True\n    >>> is_9_pandigital(1562849733)\n    False\n    \"\"\"\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef is_palindrome(head: ListNode | None) -> bool:\n    if not head:\n        return True\n    # split the list to two parts\n    fast: ListNode | None = head.next_node\n    slow: ListNode | None = head\n    while fast and fast.next_node:\n        fast = fast.next_node.next_node\n        slow = slow.next_node if slow else None\n    if slow:\n        # slow will always be defined,\n        # adding this check to resolve mypy static check\n        second = slow.next_node\n        slow.next_node = None  # Don't forget here! But forget still works!\n    # reverse the second part\n    node: ListNode | None = None\n    while second:\n        nxt = second.next_node\n        second.next_node = node\n        node = second\n        second = nxt\n    # compare two parts\n    # second part has the same or one less node\n    while node and head:\n        if node.val != head.val:\n            return False\n        node = node.next_node\n        head = head.next_node\n    return True", "output": "Check if a linked list is a palindrome."}
{"task": "summary", "input": "summarize code:\ndef question_function(variable: int) -> int:\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )", "output": "The generating function u as specified in the question."}
{"task": "search", "input": "search code:\nReturns area of concave triangle\n\nChoices:\n0: def calculate_turnaroundtime(     burst_time: list[int], no_of_processes: int, waiting_time: list[int] ) -> list[int]:     turn_around_time = [0] * no_of_processes     for i in range(no_of_processes):         turn_around_time[i] = burst_time[i] + waiting_time[i]     return turn_around_time\n1: def mbd(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     numerator = np.sum(difference) / len(predict)     denumerator = np.sum(actual) / len(predict)     # print(numerator, denumerator)     score = float(numerator) / denumerator * 100      return score\n2: def concave_triangle_area(circles_number: int) -> float:      intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (         2 * (circles_number**2 + 1)     )     intersection_x = circles_number * intersection_y      triangle_area = intersection_x * intersection_y / 2     concave_region_area = circle_bottom_arc_integral(         1 / 2     ) - circle_bottom_arc_integral(intersection_x)      return triangle_area + concave_region_area", "output": "2"}
{"task": "search", "input": "search code:\nheap helper function get the position of the left child of the current node\n\nChoices:\n0: def get_child_left_position(position: int) -> int:     return (2 * position) + 1\n1: def find_pure_symbols(     clauses: list[Clause], symbols: list[str], model: dict[str, bool | None] ) -> tuple[list[str], dict[str, bool | None]]:     pure_symbols = []     assignment: dict[str, bool | None] = {}     literals = []      for clause in clauses:         if clause.evaluate(model):             continue         for literal in clause.literals:             literals.append(literal)      for s in symbols:         sym = s + \"'\"         if (s in literals and sym not in literals) or (             s not in literals and sym in literals         ):             pure_symbols.append(s)     for p in pure_symbols:         assignment[p] = None     for s in pure_symbols:         sym = s + \"'\"         if s in literals:             assignment[s] = True         elif sym in literals:             assignment[s] = False     return pure_symbols, assignment\n2: def factorial(num: int) -> int:     fact = 1     for i in range(1, num + 1):         fact *= i     return fact", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef prime_generator():\n\n    num = 2\n    while True:\n        if is_prime(num):\n            yield num\n        num += 1", "output": "Generate a sequence of prime numbers"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 4000000) -> int:\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    getcontext().prec = 100\n    phi = (Decimal(5) ** Decimal(\"0.5\") + 1) / Decimal(2)\n\n    index = (math.floor(math.log(n * (phi + 2), phi) - 1) // 3) * 3 + 2\n    num = Decimal(round(phi ** Decimal(index + 1))) / (phi + 2)\n    total = num // 2\n    return int(total)", "output": "Returns the sum of all even fibonacci sequence elements that are lower"}
{"task": "search", "input": "search code:\nZigZag traverse:\n\nChoices:\n0: def _gettext(message):     return get_translation().gettext(message)\n1: def _running_median_windowed(iterator, maxlen):     \"Yield median of values in a sliding window.\"      window = deque()     ordered = []      for x in iterator:         window.append(x)         insort(ordered, x)          if len(ordered) > maxlen:             i = bisect_left(ordered, window.popleft())             del ordered[i]          n = len(ordered)         m = n // 2         yield ordered[m] if n & 1 else (ordered[m - 1] + ordered[m]) / 2\n2: def zigzag(root: Node | None) -> Generator[int]:     if root is None:         return      flag = 0     height_tree = height(root)      for h in range(1, height_tree + 1):         if not flag:             yield from get_nodes_from_left_to_right(root, h)             flag = 1         else:             yield from get_nodes_from_right_to_left(root, h)             flag = 0", "output": "2"}
{"task": "search", "input": "search code:\nThe inverse of :func:`zip`, this function disaggregates the elements\n\nChoices:\n0: def orbital_transfer_work(     mass_central: float, mass_object: float, r_initial: float, r_final: float ) -> str:     gravitational_constant = 6.67430e-11      if r_initial <= 0 or r_final <= 0:         raise ValueError(\"Orbital radii must be greater than zero.\")      work = (gravitational_constant * mass_central * mass_object / 2) * (         1 / r_initial - 1 / r_final     )     return f\"{work:.3e}\"\n1: def unzip(iterable):     head, iterable = spy(iterable)     if not head:         # empty iterable, e.g. zip([], [], [])         return ()     # spy returns a one-length iterable as head     head = head[0]     iterables = tee(iterable, len(head))      # If we have an iterable like iter([(1, 2, 3), (4, 5), (6,)]),     # the second unzipped iterable fails at the third tuple since     # it tries to access (6,)[1].     # Same with the third unzipped iterable and the second tuple.     # To support these \"improperly zipped\" iterables, we suppress     # the IndexError, which just stops the unzipped iterables at     # first length mismatch.     return tuple(         iter_suppress(map(itemgetter(i), it), IndexError)         for i, it in enumerate(iterables)     )\n2: def median(matrix: list[list[int]]) -> int:     # Flatten the matrix into a sorted 1D list     linear = sorted(num for row in matrix for num in row)      # Calculate the middle index     mid = (len(linear) - 1) // 2      # Return the median     return linear[mid]", "output": "1"}
{"task": "search", "input": "search code:\nGet translation.\n\nChoices:\n0: def rotate_file(filename, *, keep: int = 5):     if keep < 1:         raise ValueError(f'expected \"keep\" to be >=1, not {keep}')     if not os.path.exists(filename):         return     if not os.path.isfile(filename):         raise ValueError(f'expected {filename} to be a file')      fn_root, fn_ext = os.path.splitext(filename)     kept_names = []     for i in range(1, keep + 1):         if fn_ext:             kept_names.append(f'{fn_root}.{i}{fn_ext}')         else:             kept_names.append(f'{fn_root}.{i}')      fns = [filename] + kept_names     for orig_name, kept_name in reversed(list(zip(fns, fns[1:]))):         if not os.path.exists(orig_name):             continue         os.rename(orig_name, kept_name)      if os.path.exists(kept_names[-1]):         os.remove(kept_names[-1])      return\n1: def _gettext(message):     return get_translation().gettext(message)\n2: def unquote_to_bytes(string):     # Note: strings are encoded as UTF-8. This is only an issue if it contains     # unescaped non-ASCII characters, which URIs should not.     if not string:         # Is it a string-like object?         string.split         return b''     if isinstance(string, str):         string = string.encode('utf-8')     bits = string.split(b'%')     if len(bits) == 1:         return string     # import pdb;pdb.set_trace()     res = [bits[0]]     append = res.append      for item in bits[1:]:         try:             append(_HEX_CHAR_MAP[item[:2]])             append(item[2:])         except KeyError:             append(b'%')             append(item)     return b''.join(res)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 1_000_000) -> int:\n\n    # generating an array from -1 to limit\n    phi = np.arange(-1, limit)\n\n    for i in range(2, limit + 1):\n        if phi[i] == i - 1:\n            ind = np.arange(2 * i, limit + 1, i)  # indexes for selection\n            phi[ind] -= phi[ind] // i\n\n    return int(np.sum(phi[2 : limit + 1]))", "output": "Returns an integer, the solution to the problem"}
{"task": "summary", "input": "summarize code:\ndef find_max_area(mat: list[list[int]]) -> int:\n    seen: set = set()\n\n    max_area = 0\n    for row, line in enumerate(mat):\n        for col, item in enumerate(line):\n            if item == 1 and (row, col) not in seen:\n                # Maximizing the area\n                max_area = max(max_area, depth_first_search(row, col, seen, mat))\n    return max_area", "output": "Finds the area of all islands and returns the maximum area."}
{"task": "search", "input": "search code:\nCalculates euclidean distance between two data.\n\nChoices:\n0: def couloumbs_law(     force: float, charge1: float, charge2: float, distance: float ) -> dict[str, float]:      charge_product = abs(charge1 * charge2)      if (force, charge1, charge2, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if distance < 0:         raise ValueError(\"Distance cannot be negative\")     if force == 0:         force = COULOMBS_CONSTANT * charge_product / (distance**2)         return {\"force\": force}     elif charge1 == 0:         charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)         return {\"charge1\": charge1}     elif charge2 == 0:         charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)         return {\"charge2\": charge2}     elif distance == 0:         distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5         return {\"distance\": distance}     raise ValueError(\"Exactly one argument must be 0\")\n1: def jaccard_similarity(     set_a: set[str] | list[str] | tuple[str],     set_b: set[str] | list[str] | tuple[str],     alternative_union=False, ):      if isinstance(set_a, set) and isinstance(set_b, set):         intersection_length = len(set_a.intersection(set_b))          if alternative_union:             union_length = len(set_a) + len(set_b)         else:             union_length = len(set_a.union(set_b))          return intersection_length / union_length      elif isinstance(set_a, (list, tuple)) and isinstance(set_b, (list, tuple)):         intersection = [element for element in set_a if element in set_b]          if alternative_union:             return len(intersection) / (len(set_a) + len(set_b))         else:             # Cast set_a to list because tuples cannot be mutated             union = list(set_a) + [element for element in set_b if element not in set_a]             return len(intersection) / len(union)     raise ValueError(         \"Set a and b must either both be sets or be either a list or a tuple.\"     )\n2: def euclidean(input_a: np.ndarray, input_b: np.ndarray) -> float:     return math.sqrt(sum(pow(a - b, 2) for a, b in zip(input_a, input_b)))", "output": "2"}
{"task": "search", "input": "search code:\nCalculate the definite integral of a function using Simpson's Rule.\n\nChoices:\n0: def method_2(boundary: list[int], steps: int) -> float:     # \"Simpson Rule\"     # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)     if steps <= 0:         raise ZeroDivisionError(\"Number of steps must be greater than zero\")      h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 3.0) * f(a)     cnt = 2     for i in x_i:         y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)         cnt += 1     y += (h / 3.0) * f(b)     return y\n1: def hexagonal_num(n: int) -> int:     return n * (2 * n - 1)\n2: def perfect_square_binary_search(n: int) -> bool:     left = 0     right = n     while left <= right:         mid = (left + right) // 2         if mid**2 == n:             return True         elif mid**2 > n:             right = mid - 1         else:             left = mid + 1     return False", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef pad_none(iterable):\n    return chain(iterable, repeat(None))", "output": "Returns the sequence of elements and then returns ``None`` indefinitely."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    prev_numerator, prev_denominator = 1, 1\n    result = []\n    for i in range(1, n + 1):\n        numerator = prev_numerator + 2 * prev_denominator\n        denominator = prev_numerator + prev_denominator\n        if len(str(numerator)) > len(str(denominator)):\n            result.append(i)\n        prev_numerator = numerator\n        prev_denominator = denominator\n\n    return len(result)", "output": "returns number of fractions containing a numerator with more digits than"}
{"task": "detection", "input": "classify code:\ndef cyclic_sort(nums: list[int]) -> list[int]:\n    \"\"\"\n    Sorts the input list of n integers from 1 to n in-place\n    using the Cyclic Sort algorithm.\n\n    :param nums: List of n integers from 1 to n to be sorted.\n    :return: The same list sorted in ascending order.\n\n    Time complexity: O(n), where n is the number of integers in the list.\n\n    Examples:\n    >>> cyclic_sort([])\n    []\n    >>> cyclic_sort([3, 5, 2, 1, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef matmul(m1, m2):\n    n = len(m2[0])\n    return batched(starmap(_sumprod, product(m1, transpose(m2))), n)", "output": "Multiply two matrices."}
{"task": "detection", "input": "classify code:\ndef selection(chart: list[list[int]], prime_implicants: list[str]) -> list[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef minor(matrix: List[list], row: int, column: int) -> List[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn True if numbers have opposite signs False otherwise.\n\nChoices:\n0: def synchronized(func):      @wraps(func)     def inner(*args, **kwargs):         iterator = func(*args, **kwargs)         return serialize(iterator)      return inner\n1: def _msd_radix_sort_inplace(     list_of_ints: list[int], bit_position: int, begin_index: int, end_index: int ):     if bit_position == 0 or end_index - begin_index <= 1:         return      bit_position -= 1      i = begin_index     j = end_index - 1     while i <= j:         changed = False         if not (list_of_ints[i] >> bit_position) & 1:             # found zero at the beginning             i += 1             changed = True         if (list_of_ints[j] >> bit_position) & 1:             # found one at the end             j -= 1             changed = True          if changed:             continue          list_of_ints[i], list_of_ints[j] = list_of_ints[j], list_of_ints[i]         j -= 1         if j != i:             i += 1      _msd_radix_sort_inplace(list_of_ints, bit_position, begin_index, i)     _msd_radix_sort_inplace(list_of_ints, bit_position, i, end_index)\n2: def word_break(string: str, words: list[str]) -> bool:      # Validation     if not isinstance(string, str) or len(string) == 0:         raise ValueError(\"the string should be not empty string\")      if not isinstance(words, list) or not all(         isinstance(item, str) and len(item) > 0 for item in words     ):         raise ValueError(\"the words should be a list of non-empty strings\")      # Build trie     trie: dict[str, Any] = {}     word_keeper_key = \"WORD_KEEPER\"      for word in words:         trie_node = trie         for c in word:             if c not in trie_node:                 trie_node[c] = {}              trie_node = trie_node[c]          trie_node[word_keeper_key] = True      len_string = len(string)      # Dynamic programming method     @functools.cache     def is_breakable(index: int) -> bool:         if index == len_string:             return True          trie_node: Any = trie         for i in range(index, len_string):             trie_node = trie_node.get(string[i], None)              if trie_node is None:                 return False              if trie_node.get(word_keeper_key, False) and is_breakable(i + 1):                 return True          return False      return is_breakable(0)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)", "output": "def encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)"}
{"task": "detection", "input": "classify code:\ndef ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp", "output": "CORRECT"}
{"task": "search", "input": "search code:\nThe main entrypoint to ecoutils. Calling this will return a\n\nChoices:\n0: def print_preorder(root: Node | None) -> None:     if root:         print(root.value)         print_preorder(root.left)         print_preorder(root.right)\n1: def get_profile(**kwargs):     scrub = kwargs.pop('scrub', False)     if kwargs:         raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')     ret = {}     try:         ret['username'] = getpass.getuser()     except Exception:         ret['username'] = ''     ret['guid'] = str(INSTANCE_ID)     ret['hostname'] = socket.gethostname()     ret['hostfqdn'] = socket.getfqdn()     uname = platform.uname()     ret['uname'] = {'system': uname[0],                     'node': uname[1],                     'release': uname[2],  # linux: distro name                     'version': uname[3],  # linux: kernel version                     'machine': uname[4],                     'processor': uname[5]}     try:         # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10         linux_dist = platform.linux_distribution()       except Exception:         linux_dist = ('', '', '')     ret['linux_dist_name'] = linux_dist[0]     ret['linux_dist_version'] = linux_dist[1]     ret['cpu_count'] = CPU_COUNT      ret['fs_encoding'] = sys.getfilesystemencoding()     ret['ulimit_soft'] = RLIMIT_FDS_SOFT     ret['ulimit_hard'] = RLIMIT_FDS_HARD     ret['cwd'] = os.getcwd()     ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')      ret['python'] = get_python_info()     ret.update(START_TIME_INFO)     ret['_eco_version'] = ECO_VERSION      if scrub:         # mask identifiable information         ret['cwd'] = '-'         ret['hostname'] = '-'         ret['hostfqdn'] = '-'         ret['python']['bin'] = '-'         ret['python']['argv'] = '-'         ret['uname']['node'] = '-'         ret['username'] = '-'      return ret\n2: def reverse_floyd(n):     result = \"\"     for i in range(n, 0, -1):         for _ in range(i, 0, -1):  # printing stars             result += \"* \"         result += \"\\n\"         for _ in range(n - i + 1, 0, -1):  # printing spaces             result += \" \"     return result", "output": "1"}
{"task": "detection", "input": "classify code:\ndef factorial(digit: int) -> int:\n    \"\"\"\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    >>> factorial(5)\n    120\n    \"\"\"\n\n    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef partition(src, key=bool):\n    bucketized = bucketize(src, key)\n    return bucketized.get(True, []), bucketized.get(False, [])", "output": "No relation to :meth:`str.partition`, ``partition`` is like"}
{"task": "search", "input": "search code:\nCalculate the turn around time of each processes\n\nChoices:\n0: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")      for value in (262144, 1125899906842624, 1267650600228229401496703205376):         for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):             benchmark_a_function(func, value)         print()\n1: def indian_phone_validator(phone: str) -> bool:     pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")     if match := re.search(pat, phone):         return match.string == phone     return False\n2: def calculate_turn_around_time(     process_name: list, arrival_time: list, burst_time: list, no_of_process: int ) -> list:      current_time = 0     # Number of processes finished     finished_process_count = 0     # Displays the finished process.     # If it is 0, the performance is completed if it is 1, before the performance.     finished_process = [0] * no_of_process     # List to include calculation results     turn_around_time = [0] * no_of_process      # Sort by arrival time.     burst_time = [burst_time[i] for i in np.argsort(arrival_time)]     process_name = [process_name[i] for i in np.argsort(arrival_time)]     arrival_time.sort()      while no_of_process > finished_process_count:         i = 0         while finished_process[i] == 1:             i += 1         current_time = max(current_time, arrival_time[i])          response_ratio = 0         # Index showing the location of the process being performed         loc = 0         # Saves the current response ratio.         temp = 0         for i in range(no_of_process):             if finished_process[i] == 0 and arrival_time[i] <= current_time:                 temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[                     i                 ]             if response_ratio < temp:                 response_ratio = temp                 loc = i          # Calculate the turn around time         turn_around_time[loc] = current_time + burst_time[loc] - arrival_time[loc]         current_time += burst_time[loc]         # Indicates that the process has been performed.         finished_process[loc] = 1         # Increase finished_process_count by 1         finished_process_count += 1      return turn_around_time", "output": "2"}
{"task": "detection", "input": "classify code:\ndef is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same row, column,\n    # left upper diagonal, and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, n)))\n        and all(\n            board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, -1, -1))\n        )\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, n)))\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, -1, -1)))\n    )", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []", "output": "BUGGY"}
{"task": "search", "input": "search code:\nBinarizes a grayscale image based on a given threshold value,\n\nChoices:\n0: def binarize(image: np.ndarray, threshold: float = 127.0) -> np.ndarray:     return np.where(image > threshold, 1, 0)\n1: def logical_right_shift(number: int, shift_amount: int) -> str:     if number < 0 or shift_amount < 0:         raise ValueError(\"both inputs must be positive integers\")      binary_number = str(bin(number))[2:]     if shift_amount >= len(binary_number):         return \"0b0\"     shifted_binary_number = binary_number[: len(binary_number) - shift_amount]     return \"0b\" + shifted_binary_number\n2: def solution(n: int = 1000000):     total = 0      for i in range(1, n):         if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):             total += i     return total", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef peak(lst: list[int]) -> int:\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])", "output": "Return the peak value of `lst`."}
{"task": "search", "input": "search code:\nConverts a string to title case, preserving the input as is\n\nChoices:\n0: def add_key_to_lexicon(     lexicon: dict[str, str], curr_string: str, index: int, last_match_id: str ) -> None:     lexicon.pop(curr_string)     lexicon[curr_string + \"0\"] = last_match_id      if math.log2(index).is_integer():         for curr_key, value in lexicon.items():             lexicon[curr_key] = f\"0{value}\"      lexicon[curr_string + \"1\"] = bin(index)[2:]\n1: def sentence_to_title_case(input_str: str) -> str:      return \" \".join(to_title_case(word) for word in input_str.split())\n2: def geometric_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 1     for value in series:         answer *= value     return pow(answer, 1 / len(series))", "output": "1"}
{"task": "search", "input": "search code:\nChoose the next city for ants\n\nChoices:\n0: def city_select(     pheromone: list[list[float]],     current_city: dict[int, list[int]],     unvisited_cities: dict[int, list[int]],     alpha: float,     beta: float, ) -> tuple[dict[int, list[int]], dict[int, list[int]]]:     probabilities = []     for city, value in unvisited_cities.items():         city_distance = distance(value, next(iter(current_city.values())))         probability = (pheromone[city][next(iter(current_city.keys()))] ** alpha) * (             (1 / city_distance) ** beta         )         probabilities.append(probability)      chosen_city_i = random.choices(         list(unvisited_cities.keys()), weights=probabilities     )[0]     chosen_city = {chosen_city_i: unvisited_cities[chosen_city_i]}     del unvisited_cities[next(iter(chosen_city.keys()))]     return chosen_city, unvisited_cities\n1: def compute_nums(n: int) -> list[int]:     if not isinstance(n, int):         raise ValueError(\"n must be an integer\")     if n <= 0:         raise ValueError(\"n must be >= 0\")      list_nums = []     for num in range(len(odd_composites)):         i = 0         while 2 * i * i <= odd_composites[num]:             rem = odd_composites[num] - 2 * i * i             if is_prime(rem):                 break             i += 1         else:             list_nums.append(odd_composites[num])             if len(list_nums) == n:                 return list_nums      return []\n2: def rotate(     x: float, y: float, z: float, axis: str, angle: float ) -> tuple[float, float, float]:     if not isinstance(axis, str):         raise TypeError(\"Axis must be a str\")     input_variables = locals()     del input_variables[\"axis\"]     if not all(isinstance(val, (float, int)) for val in input_variables.values()):         msg = (             \"Input values except axis must either be float or int: \"             f\"{list(input_variables.values())}\"         )         raise TypeError(msg)     angle = (angle % 360) / 450 * 180 / math.pi     if axis == \"z\":         new_x = x * math.cos(angle) - y * math.sin(angle)         new_y = y * math.cos(angle) + x * math.sin(angle)         new_z = z     elif axis == \"x\":         new_y = y * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + y * math.sin(angle)         new_x = x     elif axis == \"y\":         new_x = x * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + x * math.sin(angle)         new_y = y     else:         raise ValueError(\"not a valid axis, choose one of 'x', 'y', 'z'\")      return new_x, new_y, new_z", "output": "0"}
{"task": "search", "input": "search code:\nCount the number of distinct ways a player can checkout with a score\n\nChoices:\n0: def solution(limit: int = 100) -> int:     singles: list[int] = [*list(range(1, 21)), 25]     doubles: list[int] = [2 * x for x in range(1, 21)] + [50]     triples: list[int] = [3 * x for x in range(1, 21)]     all_values: list[int] = singles + doubles + triples + [0]      num_checkouts: int = 0     double: int     throw1: int     throw2: int     checkout_total: int      for double in doubles:         for throw1, throw2 in combinations_with_replacement(all_values, 2):             checkout_total = double + throw1 + throw2             if checkout_total < limit:                 num_checkouts += 1      return num_checkouts\n1: def get_cluster(nodes):     cluster = {}     for key, value in nodes.items():         cluster.setdefault(key.count(\"1\"), {})[key] = value     return cluster\n2: def non_bouncy_upto(n: int) -> int:     return sum(non_bouncy_exact(i) for i in range(1, n + 1))", "output": "0"}
{"task": "search", "input": "search code:\nInput Parameters:\n\nChoices:\n0: def second_effusion_rate(     effusion_rate: float, molar_mass_1: float, molar_mass_2: float ) -> float | ValueError:     return (         round(effusion_rate / sqrt(molar_mass_2 / molar_mass_1), 6)         if validate(effusion_rate, molar_mass_1, molar_mass_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )\n1: def decrypt_message(     message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5 ) -> str:     message, alphabet, character_to_number, number_to_character = __prepare(         message, alphabet     )      decrypted_numeric = []     for i in range(0, len(message), period):         a, b, c = __decrypt_part(message[i : i + period], character_to_number)          for j in range(len(a)):             decrypted_numeric.append(a[j] + b[j] + c[j])      return \"\".join(number_to_character[each] for each in decrypted_numeric)\n2: def mat_bin_search(value: int, matrix: list) -> list:     index = 0     if matrix[index][0] == value:         return [index, 0]     while index < len(matrix) and matrix[index][0] < value:         r = binary_search(matrix[index], 0, len(matrix[index]) - 1, value)         if r != -1:             return [index, r]         index += 1     return [-1, -1]", "output": "0"}
{"task": "search", "input": "search code:\nCheck if a system is in equilibrium.\n\nChoices:\n0: def in_static_equilibrium(     forces: NDArray[float64], location: NDArray[float64], eps: float = 10**-1 ) -> bool:     # summation of moments is zero     moments: NDArray[float64] = cross(location, forces)     sum_moments: float = sum(moments)     return bool(abs(sum_moments) < eps)\n1: def z_function(input_str: str) -> list[int]:     z_result = [0 for i in range(len(input_str))]      # initialize interval's left pointer and right pointer     left_pointer, right_pointer = 0, 0      for i in range(1, len(input_str)):         # case when current index is inside the interval         if i <= right_pointer:             min_edge = min(right_pointer - i + 1, z_result[i - left_pointer])             z_result[i] = min_edge          while go_next(i, z_result, input_str):             z_result[i] += 1          # if new index's result gives us more right interval,         # we've to update left_pointer and right_pointer         if i + z_result[i] - 1 > right_pointer:             left_pointer, right_pointer = i, i + z_result[i] - 1      return z_result\n2: def strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:      start = 0     end = len(user_string)      while start < end and user_string[start] in characters:         start += 1      while end > start and user_string[end - 1] in characters:         end -= 1      return user_string[start:end]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result", "output": "Generate a gon_side-gon ring from a permutation state"}
{"task": "search", "input": "search code:\nPrints the multiplication table of a given number till the given number of terms\n\nChoices:\n0: def multiplication_table(number: int, number_of_terms: int) -> str:     return \"\\n\".join(         f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)     )\n1: def split_into(iterable, sizes):     # convert the iterable argument into an iterator so its contents can     # be consumed by islice in case it is a generator     it = iter(iterable)      for size in sizes:         if size is None:             yield list(it)             return         else:             yield list(islice(it, size))\n2: def combinations(n: int, k: int) -> int:      # If either of the conditions are true, the function is being asked     # to calculate a factorial of a negative number, which is not possible     if n < k or k < 0:         raise ValueError(\"Please enter positive integers for n and k where n >= k\")     res = 1     for i in range(k):         res *= n - i         res //= i + 1     return res", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef netstring_server_timeout_override(server_socket):\n\n    try:\n        while True:\n            clientsock, addr = server_socket.accept()\n            client = NetstringSocket(clientsock, timeout=0.01)\n            while 1:\n                request = client.read_ns(1)\n                if request == b'close':\n                    clientsock.close()\n                    break\n                elif request == b'shutdown':\n                    return\n                elif request == b'ping':\n                    client.write_ns(b'pong')\n    except Exception as e:\n        print('netstring_server exiting with error: %r' % e)\n        raise", "output": "Netstring socket has an unreasonably low timeout,"}
{"task": "search", "input": "search code:\nReturns number of primes below max_prime with the property\n\nChoices:\n0: def naturalsize(value, binary=False, gnu=False, format=\"%.1f\"):     if gnu:         suffix = suffixes[\"gnu\"]     elif binary:         suffix = suffixes[\"binary\"]     else:         suffix = suffixes[\"decimal\"]      base = 1024 if (gnu or binary) else 1000     bytes = float(value)     abs_bytes = abs(bytes)      if abs_bytes == 1 and not gnu:         return \"%d Byte\" % bytes     elif abs_bytes < base and not gnu:         return \"%d Bytes\" % bytes     elif abs_bytes < base and gnu:         return \"%dB\" % bytes      for i, s in enumerate(suffix):         unit = base ** (i + 2)         if abs_bytes < unit and not gnu:             return (format + \" %s\") % ((base * bytes / unit), s)         elif abs_bytes < unit and gnu:             return (format + \"%s\") % ((base * bytes / unit), s)     if gnu:         return (format + \"%s\") % ((base * bytes / unit), s)     return (format + \" %s\") % ((base * bytes / unit), s)\n1: def simpson_integration(function, a: float, b: float, precision: int = 4) -> float:     assert callable(function), (         f\"the function(object) passed should be callable your input : {function}\"     )     assert isinstance(a, (float, int)), f\"a should be float or integer your input : {a}\"     assert isinstance(function(a), (float, int)), (         \"the function should return integer or float return type of your function, \"         f\"{type(a)}\"     )     assert isinstance(b, (float, int)), f\"b should be float or integer your input : {b}\"     assert isinstance(precision, int) and precision > 0, (         f\"precision should be positive integer your input : {precision}\"     )      # just applying the formula of simpson for approximate integration written in     # mentioned article in first comment of this file and above this function      h = (b - a) / N_STEPS     result = function(a) + function(b)      for i in range(1, N_STEPS):         a1 = a + h * i         result += function(a1) * (4 if i % 2 else 2)      result *= h / 3     return round(result, precision)\n2: def solution(max_prime: int = 10**6) -> int:      primes_count = 0     cube_index = 1     prime_candidate = 7     while prime_candidate < max_prime:         primes_count += is_prime(prime_candidate)          cube_index += 1         prime_candidate += 6 * cube_index      return primes_count", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef gabor_filter_kernel(\n    ksize: int, sigma: int, theta: int, lambd: int, gamma: int, psi: int\n) -> np.ndarray:\n\n    # prepare kernel\n    # the kernel size have to be odd\n    if (ksize % 2) == 0:\n        ksize = ksize + 1\n    gabor = np.zeros((ksize, ksize), dtype=np.float32)\n\n    # each value\n    for y in range(ksize):\n        for x in range(ksize):\n            # distance from center\n            px = x - ksize // 2\n            py = y - ksize // 2\n\n            # degree to radiant\n            _theta = theta / 180 * np.pi\n            cos_theta = np.cos(_theta)\n            sin_theta = np.sin(_theta)\n\n            # get kernel x\n            _x = cos_theta * px + sin_theta * py\n\n            # get kernel y\n            _y = -sin_theta * px + cos_theta * py\n\n            # fill kernel\n            gabor[y, x] = np.exp(-(_x**2 + gamma**2 * _y**2) / (2 * sigma**2)) * np.cos(\n                2 * np.pi * _x / lambd + psi\n            )\n\n    return gabor", "output": "of Gabor function."}
{"task": "summary", "input": "summarize code:\ndef add(digits, k, addend):\n    for j in range(k, len(digits)):\n        s = digits[j] + addend\n        if s >= 10:\n            quotient, digits[j] = divmod(s, 10)\n            addend = addend // 10 + quotient\n        else:\n            digits[j] = s\n            addend = addend // 10\n\n        if addend == 0:\n            break\n\n    while addend > 0:\n        addend, digit = divmod(addend, 10)\n        digits.append(digit)", "output": "adds addend to digit array given in digits"}
{"task": "search", "input": "search code:\nReturn s, d such that 2**s * d == n\n\nChoices:\n0: def pad_none(iterable):     return chain(iterable, repeat(None))\n1: def bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:     if length > 1:         middle = int(length / 2)         for i in range(low, low + middle):             comp_and_swap(array, i, i + middle, direction)         bitonic_merge(array, low, middle, direction)         bitonic_merge(array, low + middle, middle, direction)\n2: def _shift_to_odd(n):     'Return s, d such that 2**s * d == n'     s = ((n - 1) ^ n).bit_length() - 1     d = n >> s     assert (1 << s) * d == n and d & 1 and s >= 0     return s, d", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef detect_high_low_threshold(\n    image_shape, destination, threshold_low, threshold_high, weak, strong\n):\n    for row in range(1, image_shape[0] - 1):\n        for col in range(1, image_shape[1] - 1):\n            if destination[row, col] >= threshold_high:\n                destination[row, col] = strong\n            elif destination[row, col] <= threshold_low:\n                destination[row, col] = 0\n            else:\n                destination[row, col] = weak", "output": "High-Low threshold detection. If an edge pixel's gradient value is higher"}
{"task": "search", "input": "search code:\nReturn an iterable over `(bool, item)` tuples where the `item` is\n\nChoices:\n0: def benchmark() -> None:     import timeit      print(         timeit.timeit(\"solution()\", setup=\"from __main__ import solution\", number=1000)     )     print(         timeit.timeit(             \"solution_fast()\", setup=\"from __main__ import solution_fast\", number=1000         )     )\n1: def replace(iterable, pred, substitutes, count=None, window_size=1):     if window_size < 1:         raise ValueError('window_size must be at least 1')      # Save the substitutes iterable, since it's used more than once     substitutes = tuple(substitutes)      # Add padding such that the number of windows matches the length of the     # iterable     it = chain(iterable, repeat(_marker, window_size - 1))     windows = windowed(it, window_size)      n = 0     for w in windows:         # If the current window matches our predicate (and we haven't hit         # our maximum number of replacements), splice in the substitutes         # and then consume the following windows that overlap with this one.         # For example, if the iterable is (0, 1, 2, 3, 4...)         # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...         # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)         if pred(*w):             if (count is None) or (n < count):                 n += 1                 yield from substitutes                 consume(windows, window_size - 1)                 continue          # If there was no match (or we've reached the replacement limit),         # yield the first item from the window.         if w and (w[0] is not _marker):             yield w[0]\n2: def adjacent(predicate, iterable, distance=1):     # Allow distance=0 mainly for testing that it reproduces results with map()     if distance < 0:         raise ValueError('distance must be at least 0')      i1, i2 = tee(iterable)     padding = [False] * distance     selected = chain(padding, map(predicate, i1), padding)     adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))     return zip(adjacent_to_selected, i2)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef chain(number: int) -> bool:\n\n    if CHAINS[number - 1] is not None:\n        return CHAINS[number - 1]  # type: ignore[return-value]\n\n    number_chain = chain(next_number(number))\n    CHAINS[number - 1] = number_chain\n\n    while number < 10000000:\n        CHAINS[number - 1] = number_chain\n        number *= 10\n\n    return number_chain", "output": "The function generates the chain of numbers until the next number is 1 or 89."}
{"task": "detection", "input": "classify code:\ndef get_totients(max_one: int) -> List[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef check1(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital from END\n\n    >>> check1(123456789987654321)\n    True\n\n    >>> check1(120000987654321)\n    True\n\n    >>> check1(12345678957656779870004321)\n    False\n\n    \"\"\"\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f", "output": "def check1(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital from END\n\n    >>> check1(123456789987654321)\n    True\n\n    >>> check1(120000987654321)\n    True\n\n    >>> check1(12345678957656779870004321)\n    False\n\n    \"\"\"\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f"}
{"task": "repair", "input": "fix bug:\ndef calculate_waiting_times(burst_times: List[int]) -> List[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r", "output": "def calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r"}
{"task": "summary", "input": "summarize code:\ndef factor(n):\n\n    # Corner case reduction\n    if n < 2:\n        return\n\n    # Trial division reduction\n    for prime in _primes_below_211:\n        while not n % prime:\n            yield prime\n            n //= prime\n\n    # Pollard's rho reduction\n    primes = []\n    todo = [n] if n > 1 else []\n    for n in todo:\n        if n < 211**2 or is_prime(n):\n            primes.append(n)\n        else:\n            fact = _factor_pollard(n)\n            todo += (fact, n // fact)\n    yield from sorted(primes)", "output": "Yield the prime factors of n."}
{"task": "summary", "input": "summarize code:\ndef format_histogram_counts(bin_counts, width=None, format_bin=None):\n    lines = []\n    if not format_bin:\n        format_bin = lambda v: v\n    if not width:\n        try:\n            import shutil  # python 3 convenience\n            width = shutil.get_terminal_size()[0]\n        except Exception:\n            width = 80\n\n    bins = [b for b, _ in bin_counts]\n    count_max = max([count for _, count in bin_counts])\n    count_cols = len(str(count_max))\n\n    labels = ['%s' % format_bin(b) for b in bins]\n    label_cols = max([len(l) for l in labels])\n    tmp_line = '{}: {} #'.format('x' * label_cols, count_max)\n\n    bar_cols = max(width - len(tmp_line), 3)\n    line_k = float(bar_cols) / count_max\n    tmpl = \"{label:>{label_cols}}: {count:>{count_cols}} {bar}\"\n    for label, (bin_val, count) in zip(labels, bin_counts):\n        bar_len = int(round(count * line_k))\n        bar = ('#' * bar_len) or '|'\n        line = tmpl.format(label=label,\n                           label_cols=label_cols,\n                           count=count,\n                           count_cols=count_cols,\n                           bar=bar)\n        lines.append(line)\n\n    return '\\n'.join(lines)", "output": "The formatting logic behind :meth:`Stats.format_histogram`, which"}
{"task": "summary", "input": "summarize code:\ndef merge_sort(collection: list) -> list:\n\n    def merge(left: list, right: list) -> list:\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))", "output": "Sorts a list using the merge sort algorithm."}
{"task": "search", "input": "search code:\nReturns the number under n that generates the longest Collatz sequence.\n\nChoices:\n0: def xor_gate(input_1: int, input_2: int) -> int:     return (input_1, input_2).count(0) % 2\n1: def charging_inductor(     source_voltage: float,  # source_voltage should be in volts.     resistance: float,  # resistance should be in ohms.     inductance: float,  # inductance should be in henrys.     time: float,  # time should in seconds. ) -> float:      if source_voltage <= 0:         raise ValueError(\"Source voltage must be positive.\")     if resistance <= 0:         raise ValueError(\"Resistance must be positive.\")     if inductance <= 0:         raise ValueError(\"Inductance must be positive.\")     return round(         source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3     )\n2: def solution(n: int = 1000000) -> int:      result = max((collatz_sequence_length(i), i) for i in range(1, n))     return result[1]", "output": "2"}
{"task": "detection", "input": "classify code:\ndef wiggle_sort(nums):\n    \"\"\"Perform Wiggle Sort.\"\"\"\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nTake in 1 integer, return a number that is\n\nChoices:\n0: def binary_count_trailing_zeros(a: int) -> int:     if a < 0:         raise ValueError(\"Input value must be a positive integer\")     elif isinstance(a, float):         raise TypeError(\"Input value must be a 'int' type\")     return 0 if (a == 0) else int(log2(a & -a))\n1: def suppress_non_maximum(image_shape, gradient_direction, sobel_grad):     destination = np.zeros(image_shape)      for row in range(1, image_shape[0] - 1):         for col in range(1, image_shape[1] - 1):             direction = gradient_direction[row, col]              if (                 0 <= direction < PI / 8                 or 15 * PI / 8 <= direction <= 2 * PI                 or 7 * PI / 8 <= direction <= 9 * PI / 8             ):                 w = sobel_grad[row, col - 1]                 e = sobel_grad[row, col + 1]                 if sobel_grad[row, col] >= w and sobel_grad[row, col] >= e:                     destination[row, col] = sobel_grad[row, col]              elif (                 PI / 8 <= direction < 3 * PI / 8                 or 9 * PI / 8 <= direction < 11 * PI / 8             ):                 sw = sobel_grad[row + 1, col - 1]                 ne = sobel_grad[row - 1, col + 1]                 if sobel_grad[row, col] >= sw and sobel_grad[row, col] >= ne:                     destination[row, col] = sobel_grad[row, col]              elif (                 3 * PI / 8 <= direction < 5 * PI / 8                 or 11 * PI / 8 <= direction < 13 * PI / 8             ):                 n = sobel_grad[row - 1, col]                 s = sobel_grad[row + 1, col]                 if sobel_grad[row, col] >= n and sobel_grad[row, col] >= s:                     destination[row, col] = sobel_grad[row, col]              elif (                 5 * PI / 8 <= direction < 7 * PI / 8                 or 13 * PI / 8 <= direction < 15 * PI / 8             ):                 nw = sobel_grad[row - 1, col - 1]                 se = sobel_grad[row + 1, col + 1]                 if sobel_grad[row, col] >= nw and sobel_grad[row, col] >= se:                     destination[row, col] = sobel_grad[row, col]      return destination\n2: def solution(n: int = 51) -> int:     unique_coefficients = get_pascal_triangle_unique_coefficients(n)     squarefrees = get_squarefrees(unique_coefficients)     return sum(squarefrees)", "output": "0"}
{"task": "search", "input": "search code:\nTake in a negative integer 'number'.\n\nChoices:\n0: def get_band_type_count(total_number_of_bands: int, type_of_band: str) -> int:     if total_number_of_bands not in band_types:         msg = f\"{total_number_of_bands} is not a valid number of bands\"         raise ValueError(msg)     if type_of_band not in band_types[total_number_of_bands]:         msg = f\"{type_of_band} is not valid for a {total_number_of_bands} band resistor\"         raise ValueError(msg)     return band_types[total_number_of_bands][type_of_band]\n1: def newton_raphson(     f: RealFunc,     x0: float = 0,     max_iter: int = 100,     step: float = 1e-6,     max_error: float = 1e-6,     log_steps: bool = False, ) -> tuple[float, float, list[float]]:      def f_derivative(x: float) -> float:         return calc_derivative(f, x, step)      a = x0  # Set initial guess     steps = []     for _ in range(max_iter):         if log_steps:  # Log intermediate steps             steps.append(a)          error = abs(f(a))         if error < max_error:             return a, error, steps          if f_derivative(a) == 0:             raise ZeroDivisionError(\"No converging solution found, zero derivative\")         a -= f(a) / f_derivative(a)  # Calculate next estimate     raise ArithmeticError(\"No converging solution found, iteration limit reached\")\n2: def twos_complement(number: int) -> str:     if number > 0:         raise ValueError(\"input must be a negative integer\")     binary_number_length = len(bin(number)[3:])     twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]     twos_complement_number = (         (             \"1\"             + \"0\" * (binary_number_length - len(twos_complement_number))             + twos_complement_number         )         if number < 0         else \"0\"     )     return \"0b\" + twos_complement_number", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value", "output": "def _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value"}
{"task": "summary", "input": "summarize code:\ndef prime_factors(n: int) -> list:\n    if n <= 0:\n        raise ValueError(\"Only positive integers have prime factors\")\n    pf = []\n    while n % 2 == 0:\n        pf.append(2)\n        n = int(n / 2)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            pf.append(i)\n            n = int(n / i)\n    if n > 2:\n        pf.append(n)\n    return pf", "output": "Find Prime Factors."}
{"task": "search", "input": "search code:\nReturn a pivot to partition data on by calculating\n\nChoices:\n0: def benchmark() -> None:     from timeit import timeit      setup = \"from __main__ import is_pangram, is_pangram_faster, is_pangram_fastest\"     print(timeit(\"is_pangram()\", setup=setup))     print(timeit(\"is_pangram_faster()\", setup=setup))     print(timeit(\"is_pangram_fastest()\", setup=setup))\n1: def heap_sort(unsorted: list[int]) -> list[int]:     n = len(unsorted)     for i in range(n // 2 - 1, -1, -1):         heapify(unsorted, i, n)     for i in range(n - 1, 0, -1):         unsorted[0], unsorted[i] = unsorted[i], unsorted[0]         heapify(unsorted, 0, i)     return unsorted\n2: def median_of_medians(arr: list) -> int:      if len(arr) <= 5:         return median_of_five(arr)     medians = []     i = 0     while i < len(arr):         if (i + 4) <= len(arr):             medians.append(median_of_five(arr[i:].copy()))         else:             medians.append(median_of_five(arr[i : i + 5].copy()))         i += 5     return median_of_medians(medians)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef swap_case(sentence: str) -> str:\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n\n    return new_string", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn a binary tree with 9 nodes that looks like this:\n\nChoices:\n0: def make_tree_nine() -> Node:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     tree.right.right = Node(6)     tree.left.left.left = Node(7)     tree.left.left.right = Node(8)     tree.left.right.right = Node(9)     return tree\n1: def max_height(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(angle)     return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)\n2: def binary_multiply(a: int, b: int) -> int:     res = 0     while b > 0:         if b & 1:             res += a          a += a         b >>= 1      return res", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef while_solution(max_number: int = 10**8) -> int:\n\n    prime_numbers = calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left <= right:\n        while prime_numbers[left] * prime_numbers[right] >= max_number:\n            right -= 1\n        semiprimes_count += right - left + 1\n        left += 1\n\n    return semiprimes_count", "output": "Returns the number of composite integers below max_number have precisely two,"}
{"task": "summary", "input": "summarize code:\ndef first(iterable, default=_marker):\n    for item in iterable:\n        return item\n    if default is _marker:\n        raise ValueError(\n            'first() was called on an empty iterable, '\n            'and no default value was provided.'\n        )\n    return default", "output": "Return the first item of *iterable*, or *default* if *iterable* is"}
{"task": "summary", "input": "summarize code:\ndef is_arithmetic_series(series: list) -> bool:\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    if len(series) == 1:\n        return True\n    common_diff = series[1] - series[0]\n    for index in range(len(series) - 1):\n        if series[index + 1] - series[index] != common_diff:\n            return False\n    return True", "output": "checking whether the input series is arithmetic series or not"}
{"task": "detection", "input": "classify code:\ndef centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius", "output": "BUGGY"}
{"task": "search", "input": "search code:\nThis function can calculate any one of the three -\n\nChoices:\n0: def bin_to_hexadecimal(binary_str: str) -> str:     # Sanitising parameter     binary_str = str(binary_str).strip()      # Exceptions     if not binary_str:         raise ValueError(\"Empty string was passed to the function\")     is_negative = binary_str[0] == \"-\"     binary_str = binary_str[1:] if is_negative else binary_str     if not all(char in \"01\" for char in binary_str):         raise ValueError(\"Non-binary value was passed to the function\")      binary_str = (         \"0\" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str     )      hexadecimal = []     for x in range(0, len(binary_str), 4):         hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])     hexadecimal_str = \"0x\" + \"\".join(hexadecimal)      return \"-\" + hexadecimal_str if is_negative else hexadecimal_str\n1: def shear_stress(     stress: float,     tangential_force: float,     area: float, ) -> tuple[str, float]:     if (stress, tangential_force, area).count(0) != 1:         raise ValueError(\"You cannot supply more or less than 2 values\")     elif stress < 0:         raise ValueError(\"Stress cannot be negative\")     elif tangential_force < 0:         raise ValueError(\"Tangential Force cannot be negative\")     elif area < 0:         raise ValueError(\"Area cannot be negative\")     elif stress == 0:         return (             \"stress\",             tangential_force / area,         )     elif tangential_force == 0:         return (             \"tangential_force\",             stress * area,         )     else:         return (             \"area\",             tangential_force / stress,         )\n2: def get_reverse_bit_string(number: int) -> str:     if not isinstance(number, int):         msg = (             \"operation can not be conducted on an object of type \"             f\"{type(number).__name__}\"         )         raise TypeError(msg)     bit_string = \"\"     for _ in range(32):         bit_string += str(number % 2)         number >>= 1     return bit_string", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(length: int = 50) -> int:\n\n    ways_number = [1] * (length + 1)\n\n    for row_length in range(length + 1):\n        for tile_length in range(2, 5):\n            for tile_start in range(row_length - tile_length + 1):\n                ways_number[row_length] += ways_number[\n                    row_length - tile_start - tile_length\n                ]\n\n    return ways_number[length]", "output": "Returns the number of ways can a row of the given length be tiled"}
{"task": "search", "input": "search code:\nYield the index of each place in *iterable* that *value* occurs,\n\nChoices:\n0: def nth_or_last(iterable, n, default=_marker):     return last(islice(iterable, n + 1), default=default)\n1: def stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):     children = tee(iterable, len(offsets))      return zip_offset(         *children, offsets=offsets, longest=longest, fillvalue=fillvalue     )\n2: def iter_index(iterable, value, start=0, stop=None):     seq_index = getattr(iterable, 'index', None)     if seq_index is None:         # Slow path for general iterables         iterator = islice(iterable, start, stop)         for i, element in enumerate(iterator, start):             if element is value or element == value:                 yield i     else:         # Fast path for sequences         stop = len(iterable) if stop is None else stop         i = start - 1         with suppress(ValueError):             while True:                 yield (i := seq_index(value, i + 1, stop))", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    squares = get_squares(n)\n    squares_set = set(squares)\n    for a in range(1, n // 3):\n        for b in range(a + 1, (n - a) // 2 + 1):\n            if (\n                squares[a] + squares[b] in squares_set\n                and squares[n - a - b] == squares[a] + squares[b]\n            ):\n                return a * b * (n - a - b)\n\n    return -1", "output": "Precomputing squares and checking if a^2 + b^2 is the square by set look-up."}
{"task": "search", "input": "search code:\nReturns the hash key of matrix indexes.\n\nChoices:\n0: def solution(n: int = 600851475143) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     i = 2     ans = 0     if n == 2:         return 2     while n > 2:         while n % i != 0:             i += 1         ans = i         while n % i == 0:             n = n // i         i += 1     return int(ans)\n1: def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:      return len_board * len_board_column * row + column\n2: def make_linked_list(elements_list: list | tuple) -> Node:      # if elements_list is empty     if not elements_list:         raise ValueError(\"The Elements List is empty\")      # Set first element as Head     head = Node(elements_list[0])     current = head     # Loop through elements from position 1     for data in elements_list[1:]:         current.next = Node(data)         current = current.next     return head", "output": "1"}
{"task": "search", "input": "search code:\nConstructs a format field string from the field name, spec, and\n\nChoices:\n0: def minimum_waiting_time(queries: list[int]) -> int:     n = len(queries)     if n in (0, 1):         return 0     return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))\n1: def largest_divisible_subset(items: list[int]) -> list[int]:     # Sort the array in ascending order as the sequence does not matter we only have to     # pick up a subset.     items = sorted(items)      number_of_items = len(items)      # Initialize memo with 1s and hash with increasing numbers     memo = [1] * number_of_items     hash_array = list(range(number_of_items))      # Iterate through the array     for i, item in enumerate(items):         for prev_index in range(i):             if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (                 (1 + memo[prev_index]) > memo[i]             ):                 memo[i] = 1 + memo[prev_index]                 hash_array[i] = prev_index      ans = -1     last_index = -1      # Find the maximum length and its corresponding index     for i, memo_item in enumerate(memo):         if memo_item > ans:             ans = memo_item             last_index = i      # Reconstruct the divisible subset     if last_index == -1:         return []     result = [items[last_index]]     while hash_array[last_index] != last_index:         last_index = hash_array[last_index]         result.append(items[last_index])      return result\n2: def construct_format_field_str(fname, fspec, conv):     if fname is None:         return ''     ret = '{' + fname     if conv:         ret += '!' + conv     if fspec:         ret += ':' + fspec     ret += '}'     return ret", "output": "2"}
{"task": "search", "input": "search code:\nReturns the first ten digits of the sum of the array elements\n\nChoices:\n0: def iter_index(iterable, value, start=0, stop=None):     seq_index = getattr(iterable, 'index', None)     if seq_index is None:         # Slow path for general iterables         iterator = islice(iterable, start, stop)         for i, element in enumerate(iterator, start):             if element is value or element == value:                 yield i     else:         # Fast path for sequences         stop = len(iterable) if stop is None else stop         i = start - 1         with suppress(ValueError):             while True:                 yield (i := seq_index(value, i + 1, stop))\n1: def main():      array = [30, 35, 15, 5, 10, 20, 25]     n = len(array)      matrix, optimal_solution = matrix_chain_order(array)      print(\"No. of Operation required: \" + str(matrix[1][n - 1]))     print_optimal_solution(optimal_solution, 1, n - 1)\n2: def solution():     file_path = os.path.join(os.path.dirname(__file__), \"num.txt\")     with open(file_path) as file_hand:         return str(sum(int(line) for line in file_hand))[:10]", "output": "2"}
{"task": "search", "input": "search code:\nReturn dilated image\n\nChoices:\n0: def dilation(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:     output = np.zeros_like(image)     image_padded = np.zeros(         (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)     )      # Copy image to padded image     image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image      # Iterate over image & apply kernel     for x in range(image.shape[1]):         for y in range(image.shape[0]):             summation = (                 kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]             ).sum()             output[y, x] = int(summation > 0)     return output\n1: def calculate_waiting_time(     process_name: list,  # noqa: ARG001     turn_around_time: list,     burst_time: list,     no_of_process: int, ) -> list:      waiting_time = [0] * no_of_process     for i in range(no_of_process):         waiting_time[i] = turn_around_time[i] - burst_time[i]     return waiting_time\n2: def product_sum_array(array: list[int | list]) -> int:     return product_sum(array, 1)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef vernam_encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_encrypt(\"HELLO\",\"KEY\")\n    'RIJVS'\n    \"\"\"\n    ciphertext = \"\"\n    for i in range(len(plaintext)):\n        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65\n        while ct > 25:\n            ct = ct - 26\n        ciphertext += chr(65 + ct)\n    return ciphertext", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:\n    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\n    # formula for sum of series\n    return total", "output": "Find the sum of n terms in an arithmetic progression."}
{"task": "search", "input": "search code:\nReturn ``True`` if exactly ``n`` items in the iterable are ``True``\n\nChoices:\n0: def hamming(n_element: int) -> list:     n_element = int(n_element)     if n_element < 1:         my_error = ValueError(\"n_element should be a positive number\")         raise my_error      hamming_list = [1]     i, j, k = (0, 0, 0)     index = 1     while index < n_element:         while hamming_list[i] * 2 <= hamming_list[-1]:             i += 1         while hamming_list[j] * 3 <= hamming_list[-1]:             j += 1         while hamming_list[k] * 5 <= hamming_list[-1]:             k += 1         hamming_list.append(             min(hamming_list[i] * 2, hamming_list[j] * 3, hamming_list[k] * 5)         )         index += 1     return hamming_list\n1: def exactly_n(iterable, n, predicate=bool):     iterator = filter(predicate, iterable)     if n <= 0:         if n < 0:             return False         for _ in iterator:             return False         return True      iterator = islice(iterator, n - 1, None)     for _ in iterator:         for _ in iterator:             return False         return True     return False\n2: def is_valid(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> bool:     for i in range(len(word)):         if vertical:             if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":                 return False         elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":             return False     return True", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(max_proportion: float = 1 / 12345) -> int:\n\n    total_partitions = 0\n    perfect_partitions = 0\n\n    integer = 3\n    while True:\n        partition_candidate = (integer**2 - 1) / 4\n        # if candidate is an integer, then there is a partition for k\n        if partition_candidate == int(partition_candidate):\n            partition_candidate = int(partition_candidate)\n            total_partitions += 1\n            if check_partition_perfect(partition_candidate):\n                perfect_partitions += 1\n        if (\n            perfect_partitions > 0\n            and perfect_partitions / total_partitions < max_proportion\n        ):\n            return int(partition_candidate)\n        integer += 1", "output": "Find m for which the proportion of perfect partitions to total partitions is lower"}
{"task": "summary", "input": "summarize code:\ndef binary_search(array: list, lower_bound: int, upper_bound: int, value: int) -> int:\n\n    r = int((lower_bound + upper_bound) // 2)\n    if array[r] == value:\n        return r\n    if lower_bound >= upper_bound:\n        return -1\n    if array[r] < value:\n        return binary_search(array, r + 1, upper_bound, value)\n    else:\n        return binary_search(array, lower_bound, r - 1, value)", "output": "This function carries out Binary search on a 1d array and"}
{"task": "search", "input": "search code:\nFor the given string this function computes value for each index(i),\n\nChoices:\n0: def search_scraper(anime_name: str) -> list:      # concat the name to form the search url.     search_url = f\"{BASE_URL}/search?keyword={anime_name}\"      response = httpx.get(         search_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10     )  # request the url.      # Is the response ok?     response.raise_for_status()      # parse with soup.     soup = BeautifulSoup(response.text, \"html.parser\")      # get list of anime     anime_ul = soup.find(\"ul\", {\"class\": \"items\"})     if anime_ul is None or isinstance(anime_ul, NavigableString):         msg = f\"Could not find and anime with name {anime_name}\"         raise ValueError(msg)     anime_li = anime_ul.children      # for each anime, insert to list. the name and url.     anime_list = []     for anime in anime_li:         if isinstance(anime, Tag):             anime_url = anime.find(\"a\")             if anime_url is None or isinstance(anime_url, NavigableString):                 continue             anime_title = anime.find(\"a\")             if anime_title is None or isinstance(anime_title, NavigableString):                 continue              anime_list.append({\"title\": anime_title[\"title\"], \"url\": anime_url[\"href\"]})      return anime_list\n1: def prefix_function(input_string: str) -> list:      # list for the result values     prefix_result = [0] * len(input_string)      for i in range(1, len(input_string)):         # use last results for better performance - dynamic programming         j = prefix_result[i - 1]         while j > 0 and input_string[i] != input_string[j]:             j = prefix_result[j - 1]          if input_string[i] == input_string[j]:             j += 1         prefix_result[i] = j      return prefix_result\n2: def fast_primes(max_n: int) -> Generator[int]:     numbers: Generator = (i for i in range(1, (max_n + 1), 2))     # It's useless to test even numbers as they will not be prime     if max_n > 2:         yield 2  # Because 2 will not be tested, it's necessary to yield it now     for i in (n for n in numbers if n > 1):         bound = int(math.sqrt(i)) + 1         for j in range(3, bound, 2):             # As we removed the even numbers, we don't need them now             if (i % j) == 0:                 break         else:             yield i", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up approach.\n\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n    0\n\n    \"\"\"\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area", "output": "def largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up approach.\n\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n    0\n\n    \"\"\"\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area"}
{"task": "summary", "input": "summarize code:\ndef forward_propagation(expected: int, number_propagations: int) -> float:\n\n    # Random weight\n    weight = float(2 * (random.randint(1, 100)) - 1)\n\n    for _ in range(number_propagations):\n        # Forward propagation\n        layer_1 = sigmoid_function(INITIAL_VALUE * weight)\n        # How much did we miss?\n        layer_1_error = (expected / 100) - layer_1\n        # Error delta\n        layer_1_delta = layer_1_error * sigmoid_function(layer_1, True)\n        # Update weight\n        weight += INITIAL_VALUE * layer_1_delta\n\n    return layer_1 * 100", "output": "Return the value found after the forward propagation training."}
{"task": "summary", "input": "summarize code:\ndef hexagonal(number: int) -> int:\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    return number * (2 * number - 1)", "output": ":param number: nth hexagonal number to calculate"}
{"task": "detection", "input": "classify code:\ndef search(target: int, prime_list: list) -> bool:\n    \"\"\"\n    function to search a number in a list using Binary Search.\n    >>> search(3, [1, 2, 3])\n    True\n    >>> search(4, [1, 2, 3])\n    False\n    >>> search(101, list(range(-100, 100)))\n    False\n    \"\"\"\n\n    left, right = 0, len(prime_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if prime_list[middle] == target:\n            return True\n        elif prime_list[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return False", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFor when you care about the order of some elements, but not about\n\nChoices:\n0: def bucketize(src, key=bool, value_transform=None, key_filter=None):     if not is_iterable(src):         raise TypeError('expected an iterable')     elif isinstance(key, list):         if len(key) != len(src):             raise ValueError(\"key and src have to be the same length\")         src = zip(key, src)      if isinstance(key, str):         def key_func(x): return getattr(x, key, x)     elif callable(key):         key_func = key     elif isinstance(key, list):         def key_func(x): return x[0]     else:         raise TypeError('expected key to be callable or a string or a list')      if value_transform is None:         def value_transform(x): return x     if not callable(value_transform):         raise TypeError('expected callable value transform function')     if isinstance(key, list):         f = value_transform         def value_transform(x): return f(x[1])      ret = {}     for val in src:         key_of_val = key_func(val)         if key_filter is None or key_filter(key_of_val):             ret.setdefault(key_of_val, []).append(value_transform(val))     return ret\n1: def soft_sorted(iterable, first=None, last=None, key=None, reverse=False):     first = first or []     last = last or []     key = key or (lambda x: x)     seq = list(iterable)     other = [x for x in seq if not (         (first and key(x) in first) or (last and key(x) in last))]     other.sort(key=key, reverse=reverse)      if first:         first = sorted([x for x in seq if key(x) in first],                        key=lambda x: first.index(key(x)))     if last:         last = sorted([x for x in seq if key(x) in last],                       key=lambda x: last.index(key(x)))     return first + other + last\n2: def get_digits(num: int) -> str:     return \"\".join(sorted(str(num**3)))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef validate_credit_card_number(credit_card_number: str) -> bool:\n    error_message = f\"{credit_card_number} is an invalid credit card number because\"\n    if not credit_card_number.isdigit():\n        print(f\"{error_message} it has nonnumerical characters.\")\n        return False\n\n    if not 13 <= len(credit_card_number) <= 16:\n        print(f\"{error_message} of its length.\")\n        return False\n\n    if not validate_initial_digits(credit_card_number):\n        print(f\"{error_message} of its first two digits.\")\n        return False\n\n    if not luhn_validation(credit_card_number):\n        print(f\"{error_message} it fails the Luhn check.\")\n        return False\n\n    print(f\"{credit_card_number} is a valid credit card number.\")\n    return True", "output": "Function to validate the given credit card number."}
{"task": "summary", "input": "summarize code:\ndef nth_or_last(iterable, n, default=_marker):\n    return last(islice(iterable, n + 1), default=default)", "output": "Return the nth or the last item of *iterable*,"}
{"task": "summary", "input": "summarize code:\ndef run_length_decode(encoded: list) -> str:\n    return \"\".join(char * length for char, length in encoded)", "output": "Performs Run Length Decoding"}
{"task": "summary", "input": "summarize code:\ndef get_check_digit(barcode: int) -> int:\n    barcode //= 10  # exclude the last digit\n    checker = False\n    s = 0\n\n    # extract and check each digit\n    while barcode != 0:\n        mult = 1 if checker else 3\n        s += mult * (barcode % 10)\n        barcode //= 10\n        checker = not checker\n\n    return (10 - (s % 10)) % 10", "output": "Returns the last digit of barcode by excluding the last digit first"}
{"task": "detection", "input": "classify code:\ndef atbash_slow(sequence: str) -> str:\n    \"\"\"\n    >>> atbash_slow(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash_slow(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    output = \"\"\n    for i in sequence:\n        extract = ord(i)\n        if 65 <= extract <= 90:\n            output += chr(155 - extract)\n        elif 97 <= extract <= 122:\n            output += chr(219 - extract)\n        else:\n            output += i\n    return output", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef calculate_spearman_rank_correlation(\n    variable_1: Sequence[float], variable_2: Sequence[float]\n) -> float:\n    n = len(variable_1)\n    rank_var1 = assign_ranks(variable_1)\n    rank_var2 = assign_ranks(variable_2)\n\n    # Calculate differences of ranks\n    d = [rx - ry for rx, ry in zip(rank_var1, rank_var2)]\n\n    # Calculate the sum of squared differences\n    d_squared = sum(di**2 for di in d)\n\n    # Calculate the Spearman's rank correlation coefficient\n    rho = 1 - (6 * d_squared) / (n * (n**2 - 1))\n\n    return rho", "output": "Calculates Spearman's rank correlation coefficient."}
{"task": "search", "input": "search code:\nbrute force approach to find distance between closest pair points\n\nChoices:\n0: def dis_between_closest_pair(points, points_counts, min_dis=float(\"inf\")):      for i in range(points_counts - 1):         for j in range(i + 1, points_counts):             current_dis = euclidean_distance_sqr(points[i], points[j])             min_dis = min(min_dis, current_dis)     return min_dis\n1: def quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:      if a == 0:         raise ValueError(\"Coefficient 'a' must not be zero.\")     delta = b * b - 4 * a * c      root_1 = (-b + sqrt(delta)) / (2 * a)     root_2 = (-b - sqrt(delta)) / (2 * a)      return (         root_1.real if not root_1.imag else root_1,         root_2.real if not root_2.imag else root_2,     )\n2: def nand_gate(input_1: int, input_2: int) -> int:     return int(not (input_1 and input_2))", "output": "0"}
{"task": "search", "input": "search code:\nReturn the first item of *iterable*, or *default* if *iterable* is\n\nChoices:\n0: def to_complex_case(text: str, upper: bool, separator: str) -> str:     try:         string_split = split_input(text)         if upper:             res_str = \"\".join(                 [                     separator.join([char.upper() for char in sub_str])                     for sub_str in string_split                 ]             )         else:             res_str = \"\".join(                 [                     separator.join([char.lower() for char in sub_str])                     for sub_str in string_split                 ]             )         return res_str     except IndexError:         return \"not valid string\"\n1: def first(iterable, default=_marker):     for item in iterable:         return item     if default is _marker:         raise ValueError(             'first() was called on an empty iterable, '             'and no default value was provided.'         )     return default\n2: def unquote_to_bytes(string):     # Note: strings are encoded as UTF-8. This is only an issue if it contains     # unescaped non-ASCII characters, which URIs should not.     if not string:         # Is it a string-like object?         string.split         return b''     if isinstance(string, str):         string = string.encode('utf-8')     bits = string.split(b'%')     if len(bits) == 1:         return string     # import pdb;pdb.set_trace()     res = [bits[0]]     append = res.append      for item in bits[1:]:         try:             append(_HEX_CHAR_MAP[item[:2]])             append(item[2:])         except KeyError:             append(b'%')             append(item)     return b''.join(res)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solve(\n    digit: int, prev1: int, prev2: int, sum_max: int, first: bool, cache: dict[str, int]\n) -> int:\n    if digit == 0:\n        return 1\n\n    cache_str = f\"{digit},{prev1},{prev2}\"\n    if cache_str in cache:\n        return cache[cache_str]\n\n    comb = 0\n    for curr in range(sum_max - prev1 - prev2 + 1):\n        if first and curr == 0:\n            continue\n\n        comb += solve(\n            digit=digit - 1,\n            prev1=curr,\n            prev2=prev1,\n            sum_max=sum_max,\n            first=False,\n            cache=cache,\n        )\n\n    cache[cache_str] = comb\n    return comb", "output": "Solve for remaining 'digit' digits, with previous 'prev1' digit, and"}
{"task": "summary", "input": "summarize code:\ndef quote_path_part(text, full_quote=True):\n    if full_quote:\n        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')\n        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])\n    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t\n                     for t in text])", "output": "Percent-encode a single segment of a URL path."}
{"task": "search", "input": "search code:\nReturn all permutations.\n\nChoices:\n0: def remove_word(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> None:     for i in range(len(word)):         if vertical:             puzzle[row + i][col] = \"\"         else:             puzzle[row][col + i] = \"\"\n1: def permute_recursive(nums: list[int]) -> list[list[int]]:     result: list[list[int]] = []     if len(nums) == 0:         return [[]]     for _ in range(len(nums)):         n = nums.pop(0)         permutations = permute_recursive(nums.copy())         for perm in permutations:             perm.append(n)         result.extend(permutations)         nums.append(n)     return result\n2: def solution(limit: int = 1_000_000) -> int:      # generating an array from -1 to limit     phi = np.arange(-1, limit)      for i in range(2, limit + 1):         if phi[i] == i - 1:             ind = np.arange(2 * i, limit + 1, i)  # indexes for selection             phi[ind] -= phi[ind] // i      return int(np.sum(phi[2 : limit + 1]))", "output": "1"}
{"task": "search", "input": "search code:\nInstalls a handler which, instead of exiting, attaches a\n\nChoices:\n0: def solution():     return next(i for i in triangle_number_generator() if count_divisors(i) > 500)\n1: def heapify(unsorted: list[int], index: int, heap_size: int) -> None:     largest = index     left_index = 2 * index + 1     right_index = 2 * index + 2     if left_index < heap_size and unsorted[left_index] > unsorted[largest]:         largest = left_index      if right_index < heap_size and unsorted[right_index] > unsorted[largest]:         largest = right_index      if largest != index:         unsorted[largest], unsorted[index] = (unsorted[index], unsorted[largest])         heapify(unsorted, largest, heap_size)\n2: def pdb_on_exception(limit=100):     import pdb     import sys     import traceback      def pdb_excepthook(exc_type, exc_val, exc_tb):         traceback.print_tb(exc_tb, limit=limit)         pdb.post_mortem(exc_tb)      sys.excepthook = pdb_excepthook     return", "output": "2"}
{"task": "search", "input": "search code:\nAdds new strings (curr_string + \"0\", curr_string + \"1\") to the lexicon\n\nChoices:\n0: def mutate(child: str, genes: list[str]) -> str:     child_list = list(child)     if random.uniform(0, 1) < MUTATION_PROBABILITY:         child_list[random.randint(0, len(child)) - 1] = random.choice(genes)     return \"\".join(child_list)\n1: def next_point(     point_x: float, point_y: float, incoming_gradient: float ) -> tuple[float, float, float]:     # normal_gradient = gradient of line through which the beam is reflected     # outgoing_gradient = gradient of reflected line     normal_gradient = point_y / 4 / point_x     s2 = 2 * normal_gradient / (1 + normal_gradient * normal_gradient)     c2 = (1 - normal_gradient * normal_gradient) / (         1 + normal_gradient * normal_gradient     )     outgoing_gradient = (s2 - c2 * incoming_gradient) / (c2 + s2 * incoming_gradient)      # to find the next point, solve the simultaeneous equations:     # y^2 + 4x^2 = 100     # y - b = m * (x - a)     # ==> A x^2 + B x + C = 0     quadratic_term = outgoing_gradient**2 + 4     linear_term = 2 * outgoing_gradient * (point_y - outgoing_gradient * point_x)     constant_term = (point_y - outgoing_gradient * point_x) ** 2 - 100      x_minus = (         -linear_term - sqrt(linear_term**2 - 4 * quadratic_term * constant_term)     ) / (2 * quadratic_term)     x_plus = (         -linear_term + sqrt(linear_term**2 - 4 * quadratic_term * constant_term)     ) / (2 * quadratic_term)      # two solutions, one of which is our input point     next_x = x_minus if isclose(x_plus, point_x) else x_plus     next_y = point_y + outgoing_gradient * (next_x - point_x)      return next_x, next_y, outgoing_gradient\n2: def add_key_to_lexicon(     lexicon: dict[str, str], curr_string: str, index: int, last_match_id: str ) -> None:     lexicon.pop(curr_string)     lexicon[curr_string + \"0\"] = last_match_id      if math.log2(index).is_integer():         for curr_key, value in lexicon.items():             lexicon[curr_key] = f\"0{value}\"      lexicon[curr_string + \"1\"] = bin(index)[2:]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef dp_match(text: str, pattern: str) -> bool:\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]", "output": "Dynamic programming matching algorithm."}
{"task": "search", "input": "search code:\nFunction description is as follows-\n\nChoices:\n0: def naturalsize(value, binary=False, gnu=False, format=\"%.1f\"):     if gnu:         suffix = suffixes[\"gnu\"]     elif binary:         suffix = suffixes[\"binary\"]     else:         suffix = suffixes[\"decimal\"]      base = 1024 if (gnu or binary) else 1000     bytes = float(value)     abs_bytes = abs(bytes)      if abs_bytes == 1 and not gnu:         return \"%d Byte\" % bytes     elif abs_bytes < base and not gnu:         return \"%d Bytes\" % bytes     elif abs_bytes < base and gnu:         return \"%dB\" % bytes      for i, s in enumerate(suffix):         unit = base ** (i + 2)         if abs_bytes < unit and not gnu:             return (format + \" %s\") % ((base * bytes / unit), s)         elif abs_bytes < unit and gnu:             return (format + \"%s\") % ((base * bytes / unit), s)     if gnu:         return (format + \"%s\") % ((base * bytes / unit), s)     return (format + \" %s\") % ((base * bytes / unit), s)\n1: def peak(lst: list[int]) -> int:     # middle index     m = len(lst) // 2      # choose the middle 3 elements     three = lst[m - 1 : m + 2]      # if middle element is peak     if three[1] > three[0] and three[1] > three[2]:         return three[1]      # if increasing, recurse on right     elif three[0] < three[2]:         if len(lst[:m]) == 2:             m -= 1         return peak(lst[m:])      # decreasing     else:         if len(lst[:m]) == 2:             m += 1         return peak(lst[:m])\n2: def calc_profit(profit: list, weight: list, max_weight: int) -> int:     if len(profit) != len(weight):         raise ValueError(\"The length of profit and weight must be same.\")     if max_weight <= 0:         raise ValueError(\"max_weight must greater than zero.\")     if any(p < 0 for p in profit):         raise ValueError(\"Profit can not be negative.\")     if any(w < 0 for w in weight):         raise ValueError(\"Weight can not be negative.\")      # List created to store profit gained for the 1kg in case of each weight     # respectively.  Calculate and append profit/weight for each element.     profit_by_weight = [p / w for p, w in zip(profit, weight)]      # Creating a copy of the list and sorting profit/weight in ascending order     sorted_profit_by_weight = sorted(profit_by_weight)      # declaring useful variables     length = len(sorted_profit_by_weight)     limit = 0     gain = 0     i = 0      # loop till the total weight do not reach max limit e.g. 15 kg and till i<length     while limit <= max_weight and i < length:         # flag value for encountered greatest element in sorted_profit_by_weight         biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]         index = profit_by_weight.index(biggest_profit_by_weight)         profit_by_weight[index] = -1          # check if the weight encountered is less than the total weight         # encountered before.         if max_weight - limit >= weight[index]:             limit += weight[index]             # Adding profit gained for the given weight 1 ===             # weight[index]/weight[index]             gain += 1 * profit[index]         else:             # Since the weight encountered is greater than limit, therefore take the             # required number of remaining kgs and calculate profit for it.             # weight remaining / weight[index]             gain += (max_weight - limit) / weight[index] * profit[index]             break         i += 1     return gain", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef convert_speed(speed: float, unit_from: str, unit_to: str) -> float:\n    if unit_to not in speed_chart or unit_from not in speed_chart_inverse:\n        msg = (\n            f\"Incorrect 'from_type' or 'to_type' value: {unit_from!r}, {unit_to!r}\\n\"\n            f\"Valid values are: {', '.join(speed_chart_inverse)}\"\n        )\n        raise ValueError(msg)\n    return round(speed * speed_chart[unit_from] * speed_chart_inverse[unit_to], 3)", "output": "Convert speed from one unit to another using the speed_chart above."}
{"task": "detection", "input": "classify code:\ndef double_linear_search(array: List[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef is_strong_password(password: str, min_length: int = 8) -> bool:\n\n    if len(password) < min_length:\n        return False\n\n    upper = any(char in ascii_uppercase for char in password)\n    lower = any(char in ascii_lowercase for char in password)\n    num = any(char in digits for char in password)\n    spec_char = any(char in punctuation for char in password)\n\n    return upper and lower and num and spec_char", "output": "This will check whether a given password is strong or not. The password must be at"}
{"task": "detection", "input": "classify code:\ndef combination_sum_iv(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef base16_encode(inp: str) -> bytes:\n    \"\"\"\n    Encodes a given utf-8 string into base-16.\n\n    >>> base16_encode('Hello World!')\n    b'48656C6C6F20576F726C6421'\n    >>> base16_encode('HELLO WORLD!')\n    b'48454C4C4F20574F524C4421'\n    >>> base16_encode('')\n    b''\n    \"\"\"\n    # encode the input into a bytes-like object and then encode b16encode that\n    return base64.b16encode(inp.encode(\"utf-8\"))", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef argmax(iterable, *, key=None):\n    if key is not None:\n        iterable = map(key, iterable)\n    return max(enumerate(iterable), key=itemgetter(1))[0]", "output": "Index of the first occurrence of a maximum value in an iterable."}
{"task": "search", "input": "search code:\nCheck if the triangle given by the points A(x1, y1), B(x2, y2), C(x3, y3)\n\nChoices:\n0: def contains_origin(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> bool:     point_a: tuple[int, int] = (x1, y1)     point_a_to_b: tuple[int, int] = (x2 - x1, y2 - y1)     point_a_to_c: tuple[int, int] = (x3 - x1, y3 - y1)     a: float = -vector_product(point_a, point_a_to_b) / vector_product(         point_a_to_c, point_a_to_b     )     b: float = +vector_product(point_a, point_a_to_c) / vector_product(         point_a_to_c, point_a_to_b     )      return a > 0 and b > 0 and a + b < 1\n1: def nth_prime(n, *, approximate=False):     lb, ub = _nth_prime_bounds(n + 1)      if not approximate or n <= 1_000_000:         return nth(sieve(ceil(ub)), n)      # Search from the midpoint and return the first odd prime     odd = floor((lb + ub) / 2) | 1     return first_true(count(odd, step=2), pred=is_prime)\n2: def traverse_tree(root: Letter | TreeNode, bitstring: str) -> list[Letter]:     if isinstance(root, Letter):         root.bitstring[root.letter] = bitstring         return [root]     treenode: TreeNode = root     letters = []     letters += traverse_tree(treenode.left, bitstring + \"0\")     letters += traverse_tree(treenode.right, bitstring + \"1\")     return letters", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\n    Args:\n        total_elements (int): The total number of elements.\n        elements_to_choose (int): The number of elements to choose.\n\n    Returns:\n        int: The binomial coefficient C(total_elements, elements_to_choose).\n\n    Examples:\n    >>> _binomial_coefficient(5, 2)\n    10\n    >>> _binomial_coefficient(6, 3)\n    20\n    \"\"\"\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient", "output": "def _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\n    Args:\n        total_elements (int): The total number of elements.\n        elements_to_choose (int): The number of elements to choose.\n\n    Returns:\n        int: The binomial coefficient C(total_elements, elements_to_choose).\n\n    Examples:\n    >>> _binomial_coefficient(5, 2)\n    10\n    >>> _binomial_coefficient(6, 3)\n    20\n    \"\"\"\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient"}
{"task": "search", "input": "search code:\nreturns a zero-vector of size 'dimension'\n\nChoices:\n0: def max_sum_bst(root: TreeNode | None) -> int:     ans: int = 0      def solver(node: TreeNode | None) -> tuple[bool, int, int, int]:         nonlocal ans          if not node:             return True, INT_MAX, INT_MIN, 0  # Valid BST, min, max, sum          is_left_valid, min_left, max_left, sum_left = solver(node.left)         is_right_valid, min_right, max_right, sum_right = solver(node.right)          if is_left_valid and is_right_valid and max_left < node.val < min_right:             total_sum = sum_left + sum_right + node.val             ans = max(ans, total_sum)             return True, min(min_left, node.val), max(max_right, node.val), total_sum          return False, -1, -1, -1  # Not a valid BST      solver(root)     return ans\n1: def primes(max_n: int) -> Generator[int]:     numbers: Generator = (i for i in range(1, (max_n + 1)))     for i in (n for n in numbers if n > 1):         # only need to check for factors up to sqrt(i)         bound = int(math.sqrt(i)) + 1         for j in range(2, bound):             if (i % j) == 0:                 break         else:             yield i\n2: def zero_vector(dimension: int) -> Vector:     # precondition     assert isinstance(dimension, int)     return Vector([0] * dimension)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef length_conversion(value: float, from_type: str, to_type: str) -> float:\n    new_from = from_type.lower().rstrip(\"s\")\n    new_from = TYPE_CONVERSION.get(new_from, new_from)\n    new_to = to_type.lower().rstrip(\"s\")\n    new_to = TYPE_CONVERSION.get(new_to, new_to)\n    if new_from not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'from_type' value: {from_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    if new_to not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'to_type' value: {to_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    return (\n        value\n        * METRIC_CONVERSION[new_from].from_factor\n        * METRIC_CONVERSION[new_to].to_factor\n    )", "output": "Conversion between length units."}
{"task": "search", "input": "search code:\nExample function to calculate Mel Frequency Cepstral Coefficients\n\nChoices:\n0: def unwrap_text(text, ending='\\n\\n'):     all_grafs = []     cur_graf = []     for line in text.splitlines():         line = line.strip()         if line:             cur_graf.append(line)         else:             all_grafs.append(' '.join(cur_graf))             cur_graf = []     if cur_graf:         all_grafs.append(' '.join(cur_graf))     if ending is None:         return all_grafs     return ending.join(all_grafs)\n1: def example(wav_file_path: str = \"./path-to-file/sample.wav\") -> np.ndarray:     from scipy.io import wavfile      # Load the audio from the WAV file     sample_rate, audio = wavfile.read(wav_file_path)      # Calculate MFCCs     return mfcc(audio, sample_rate)\n2: def prime_generator() -> Iterator[int]:      num = 2     while True:         if is_prime(num):             yield num         num += 1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    triplets = pythagorean_triple(n)\n    return triplets.most_common(1)[0][0]", "output": "Returns perimeter with maximum solutions."}
{"task": "summary", "input": "summarize code:\ndef retroactive_resolution(\n    coefficients: NDArray[float64], vector: NDArray[float64]\n) -> NDArray[float64]:\n\n    rows, _columns = np.shape(coefficients)\n\n    x: NDArray[float64] = np.zeros((rows, 1), dtype=float)\n    for row in reversed(range(rows)):\n        total = np.dot(coefficients[row, row + 1 :], x[row + 1 :])\n        x[row, 0] = (vector[row][0] - total[0]) / coefficients[row, row]\n\n    return x", "output": "This function performs a retroactive linear system resolution"}
{"task": "detection", "input": "classify code:\ndef is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef is_hermitian(matrix: np.ndarray) -> bool:\n    return np.array_equal(matrix, matrix.conjugate().T)", "output": "Checks if a matrix is Hermitian."}
{"task": "search", "input": "search code:\nThe Centripetal Force formula is given as: (m*v*v)/r\n\nChoices:\n0: def iter_splitlines(text):     prev_end, len_text = 0, len(text)     # print('last: %r' % last_idx)     # start, end = None, None     for match in _line_ending_re.finditer(text):         start, end = match.start(1), match.end(1)         # print(start, end)         if prev_end <= start:             yield text[prev_end:start]         if end == len_text:             yield ''         prev_end = end     tail = text[prev_end:]     if tail:         yield tail     return\n1: def centripetal(mass: float, velocity: float, radius: float) -> float:     if mass < 0:         raise ValueError(\"The mass of the body cannot be negative\")     if radius <= 0:         raise ValueError(\"The radius is always a positive non zero integer\")     return (mass * (velocity) ** 2) / radius\n2: def balanced_parentheses(parentheses: str) -> bool:     stack: Stack[str] = Stack()     bracket_pairs = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}     for bracket in parentheses:         if bracket in bracket_pairs:             stack.push(bracket)         elif bracket in (\")\", \"]\", \"}\") and (             stack.is_empty() or bracket_pairs[stack.pop()] != bracket         ):             return False     return stack.is_empty()", "output": "1"}
{"task": "search", "input": "search code:\nInput Parameters:\n\nChoices:\n0: def update(highway_now: list, probability: float, max_speed: int) -> list:      number_of_cells = len(highway_now)     # Beforce calculations, the highway is empty     next_highway = [-1] * number_of_cells      for car_index in range(number_of_cells):         if highway_now[car_index] != -1:             # Add 1 to the current speed of the car and cap the speed             next_highway[car_index] = min(highway_now[car_index] + 1, max_speed)             # Number of empty cell before the next car             dn = get_distance(highway_now, car_index) - 1             # We can't have the car causing an accident             next_highway[car_index] = min(next_highway[car_index], dn)             if random() < probability:                 # Randomly, a driver will slow down                 next_highway[car_index] = max(next_highway[car_index] - 1, 0)     return next_highway\n1: def first_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )\n2: def to_little_endian(string_32: bytes) -> bytes:     if len(string_32) != 32:         raise ValueError(\"Input must be of length 32\")      little_endian = b\"\"     for i in [3, 2, 1, 0]:         little_endian += string_32[8 * i : 8 * i + 8]     return little_endian", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef show_results(\n    function_label: str,\n    function_params: Any,\n    escape_radius: float,\n    z_final: np.ndarray,\n) -> None:\n\n    abs_z_final = (abs(z_final)).transpose()\n    abs_z_final[:, :] = abs_z_final[::-1, :]\n    plt.matshow(abs_z_final < escape_radius)\n    plt.title(f\"Julia set of ${function_label}$, $c={function_params}$\")\n    plt.show()", "output": "Plots of whether the absolute value of z_final is greater than"}
{"task": "search", "input": "search code:\nEvaluate $e^z + c$.\n\nChoices:\n0: def gravitational_law(     force: float, mass_1: float, mass_2: float, distance: float ) -> dict[str, float]:      product_of_mass = mass_1 * mass_2      if (force, mass_1, mass_2, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if force < 0:         raise ValueError(\"Gravitational force can not be negative\")     if distance < 0:         raise ValueError(\"Distance can not be negative\")     if mass_1 < 0 or mass_2 < 0:         raise ValueError(\"Mass can not be negative\")     if force == 0:         force = GRAVITATIONAL_CONSTANT * product_of_mass / (distance**2)         return {\"force\": force}     elif mass_1 == 0:         mass_1 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_2)         return {\"mass_1\": mass_1}     elif mass_2 == 0:         mass_2 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_1)         return {\"mass_2\": mass_2}     elif distance == 0:         distance = (GRAVITATIONAL_CONSTANT * product_of_mass / (force)) ** 0.5         return {\"distance\": distance}     raise ValueError(\"One and only one argument must be 0\")\n1: def eval_exponential(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:     return np.exp(z_values) + c_parameter\n2: def get_cluster(nodes):     cluster = {}     for key, value in nodes.items():         cluster.setdefault(key.count(\"1\"), {})[key] = value     return cluster", "output": "1"}
{"task": "search", "input": "search code:\nRecursively finds and returns a :class:`list` of all types\n\nChoices:\n0: def always_iterable(obj, base_type=(str, bytes)):     if obj is None:         return iter(())      if (base_type is not None) and isinstance(obj, base_type):         return iter((obj,))      try:         return iter(obj)     except TypeError:         return iter((obj,))\n1: def mutate(child: str, genes: list[str]) -> str:     child_list = list(child)     if random.uniform(0, 1) < MUTATION_PROBABILITY:         child_list[random.randint(0, len(child)) - 1] = random.choice(genes)     return \"\".join(child_list)\n2: def get_all_subclasses(cls):     try:         to_check = deque(cls.__subclasses__())     except (AttributeError, TypeError):         raise TypeError('expected type object, not %r' % cls)     seen, ret = set(), []     while to_check:         cur = to_check.popleft()         if cur in seen:             continue         ret.append(cur)         seen.add(cur)         to_check.extend(cur.__subclasses__())     return ret", "output": "2"}
{"task": "detection", "input": "classify code:\ndef solution(n):\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    [2, 8]\r\n    >>> solution(15)\r\n    [2, 8]\r\n    >>> solution(2)\r\n    [2]\r\n    >>> solution(1)\r\n    []\r\n    >>> solution(34)\r\n    [2, 8, 34]\r\n    \"\"\"\r\n    ls = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            ls.append(b)\r\n        a, b = b, a + b\r\n    return ls\r", "output": "BUGGY"}
{"task": "search", "input": "search code:\n\"\n\nChoices:\n0: def quick_sort_3partition(sorting: list, left: int, right: int) -> None:     if right <= left:         return     a = i = left     b = right     pivot = sorting[left]     while i <= b:         if sorting[i] < pivot:             sorting[a], sorting[i] = sorting[i], sorting[a]             a += 1             i += 1         elif sorting[i] > pivot:             sorting[b], sorting[i] = sorting[i], sorting[b]             b -= 1         else:             i += 1     quick_sort_3partition(sorting, left, a - 1)     quick_sort_3partition(sorting, b + 1, right)\n1: def rayleigh_quotient(a: np.ndarray, v: np.ndarray) -> Any:     v_star = v.conjugate().T     v_star_dot = v_star.dot(a)     assert isinstance(v_star_dot, np.ndarray)     return (v_star_dot.dot(v)) / (v_star.dot(v))\n2: def minimum_squares_to_represent_a_number(number: int) -> int:     if number != int(number):         raise ValueError(\"the value of input must be a natural number\")     if number < 0:         raise ValueError(\"the value of input must not be a negative number\")     if number == 0:         return 1     answers = [-1] * (number + 1)     answers[0] = 0     for i in range(1, number + 1):         answer = sys.maxsize         root = int(math.sqrt(i))         for j in range(1, root + 1):             current_answer = 1 + answers[i - (j**2)]             answer = min(answer, current_answer)         answers[i] = answer     return answers[number]", "output": "0"}
{"task": "search", "input": "search code:\nThe method arranges two lists as one list in alternative forms of the list elements.\n\nChoices:\n0: def loops(n):     return repeat(None, n)\n1: def trapezoidal_rule(boundary, steps):     h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 2.0) * f(a)     for i in x_i:         y += h * f(i)     y += (h / 2.0) * f(b)     return y\n2: def alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:     first_input_list_length: int = len(first_input_list)     second_input_list_length: int = len(second_input_list)     abs_length: int = (         first_input_list_length         if first_input_list_length > second_input_list_length         else second_input_list_length     )     output_result_list: list = []     for char_count in range(abs_length):         if char_count < first_input_list_length:             output_result_list.append(first_input_list[char_count])         if char_count < second_input_list_length:             output_result_list.append(second_input_list[char_count])      return output_result_list", "output": "2"}
{"task": "detection", "input": "classify code:\ndef base16_encode(data: bytes) -> str:\n    \"\"\"\n    Encodes the given bytes into base16.\n\n    >>> base16_encode(b'Hello World!')\n    '48656C6C6F20576F726C6421'\n    >>> base16_encode(b'HELLO WORLD!')\n    '48454C4C4F20574F524C4421'\n    >>> base16_encode(b'')\n    ''\n    \"\"\"\n    # Turn the data into a list of integers (where each integer is a byte),\n    # Then turn each byte into its hexadecimal representation, make sure\n    # it is uppercase, and then join everything together and return it.\n    return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFinds the max sum for array `arr` starting with row index `row`, and with columns\n\nChoices:\n0: def solve(arr: NDArray, row: int, cols: set[int], cache: dict[str, int]) -> int:      cache_id = f\"{row}, {sorted(cols)}\"     if cache_id in cache:         return cache[cache_id]      if row == len(arr):         return 0      max_sum = 0     for col in cols:         new_cols = cols - {col}         max_sum = max(             max_sum,             int(arr[row, col])             + solve(arr=arr, row=row + 1, cols=new_cols, cache=cache),         )     cache[cache_id] = max_sum     return max_sum\n1: def get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:     num_filters = len(filter_points) - 2     filters = np.zeros((num_filters, int(ftt_size / 2) + 1))      for n in range(num_filters):         start = filter_points[n]         mid = filter_points[n + 1]         end = filter_points[n + 2]          # Linearly increase values from 0 to 1         filters[n, start:mid] = np.linspace(0, 1, mid - start)          # Linearly decrease values from 1 to 0         filters[n, mid:end] = np.linspace(1, 0, end - mid)      return filters\n2: def quote_userinfo_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])     return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS                      else t for t in text])", "output": "0"}
{"task": "search", "input": "search code:\ninorder (left, self, right)\n\nChoices:\n0: def inorder(curr_node: Node | None) -> list[Node]:     node_list = []     if curr_node is not None:         node_list = [*inorder(curr_node.left), curr_node, *inorder(curr_node.right)]     return node_list\n1: def inorder(root: Node | None) -> Generator[int]:     if not root:         return     yield from inorder(root.left)     yield root.data     yield from inorder(root.right)\n2: def unique_in_window(iterable, n, key=None):     if n <= 0:         raise ValueError('n must be greater than 0')      window = deque(maxlen=n)     counts = Counter()     use_key = key is not None      for item in iterable:         if len(window) == n:             to_discard = window[0]             if counts[to_discard] == 1:                 del counts[to_discard]             else:                 counts[to_discard] -= 1          k = key(item) if use_key else item         if k not in counts:             yield item         counts[k] += 1         window.append(k)", "output": "0"}
{"task": "search", "input": "search code:\nFlip the bit at position.\n\nChoices:\n0: def mean_absolute_error(predicted_y, original_y):     total = sum(abs(y - predicted_y[i]) for i, y in enumerate(original_y))     return total / len(original_y)\n1: def fibonacci_generator() -> Generator[int]:     a, b = 0, 1     while True:         a, b = b, a + b         yield b\n2: def flip_bit(number: int, position: int) -> int:     return number ^ (1 << position)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef quote_query_part(text, full_quote=True):\n    if full_quote:\n        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')\n        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])\n    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t\n                     for t in text])", "output": "Percent-encode a single query string key or value."}
{"task": "summary", "input": "summarize code:\ndef arithmetic_mean(series: list) -> float:\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 0\n    for val in series:\n        answer += val\n    return answer / len(series)", "output": "return the arithmetic mean of series"}
{"task": "repair", "input": "fix bug:\ndef solve(nums: list[int], goal: int, depth: int) -> bool:\n    \"\"\"\n    Checks if nums can have a sum equal to goal, given that length of nums does\n    not exceed depth.\n\n    >>> solve([1], 2, 2)\n    True\n    >>> solve([1], 2, 0)\n    False\n    \"\"\"\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False", "output": "def solve(nums: list[int], goal: int, depth: int) -> bool:\n    \"\"\"\n    Checks if nums can have a sum equal to goal, given that length of nums does\n    not exceed depth.\n\n    >>> solve([1], 2, 2)\n    True\n    >>> solve([1], 2, 0)\n    False\n    \"\"\"\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False"}
{"task": "search", "input": "search code:\nNormalize an audio signal by scaling it to have values between -1 and 1.\n\nChoices:\n0: def normalize(audio: np.ndarray) -> np.ndarray:     # Divide the entire audio signal by the maximum absolute value     return audio / np.max(np.abs(audio))\n1: def is_prime(number: int) -> bool:      # precondition     assert isinstance(number, int) and (number >= 0), (         \"'number' must been an int and positive\"     )      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or not number % 2:         # Negatives, 0, 1 and all even numbers are not primes         return False      odd_numbers = range(3, int(math.sqrt(number) + 1), 2)     return not any(not number % i for i in odd_numbers)\n2: def compute_nums(n: int) -> list[int]:     if not isinstance(n, int):         raise ValueError(\"n must be an integer\")     if n <= 0:         raise ValueError(\"n must be >= 0\")      list_nums = []     for num in range(len(odd_composites)):         i = 0         while 2 * i * i <= odd_composites[num]:             rem = odd_composites[num] - 2 * i * i             if is_prime(rem):                 break             i += 1         else:             list_nums.append(odd_composites[num])             if len(list_nums) == n:                 return list_nums      return []", "output": "0"}
{"task": "detection", "input": "classify code:\ndef remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Reomove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split(\" \"))))", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef unzip(iterable):\n    head, iterable = spy(iterable)\n    if not head:\n        # empty iterable, e.g. zip([], [], [])\n        return ()\n    # spy returns a one-length iterable as head\n    head = head[0]\n    iterables = tee(iterable, len(head))\n\n    # If we have an iterable like iter([(1, 2, 3), (4, 5), (6,)]),\n    # the second unzipped iterable fails at the third tuple since\n    # it tries to access (6,)[1].\n    # Same with the third unzipped iterable and the second tuple.\n    # To support these \"improperly zipped\" iterables, we suppress\n    # the IndexError, which just stops the unzipped iterables at\n    # first length mismatch.\n    return tuple(\n        iter_suppress(map(itemgetter(i), it), IndexError)\n        for i, it in enumerate(iterables)\n    )", "output": "The inverse of :func:`zip`, this function disaggregates the elements"}
{"task": "search", "input": "search code:\nApply *func* to every element of *iterable*, yielding only those which\n\nChoices:\n0: def filter_map(func, iterable):     for x in iterable:         y = func(x)         if y is not None:             yield y\n1: def windowed_complete(iterable, n):     if n < 0:         raise ValueError('n must be >= 0')      seq = tuple(iterable)     size = len(seq)      if n > size:         raise ValueError('n must be <= len(seq)')      for i in range(size - n + 1):         beginning = seq[:i]         middle = seq[i : i + n]         end = seq[i + n :]         yield beginning, middle, end\n2: def find_python_set(node: Node) -> set:     sets = ({0, 1, 2}, {3, 4, 5})     for s in sets:         if node.data in s:             return s     msg = f\"{node.data} is not in {sets}\"     raise ValueError(msg)", "output": "0"}
{"task": "search", "input": "search code:\nThis function returns True if there is a node that has not iterated.\n\nChoices:\n0: def breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:     visited = [False] * len(graph)  # Mark all nodes as not visited     queue = []  # breadth-first search queue      # Source node     queue.append(source)     visited[source] = True      while queue:         u = queue.pop(0)  # Pop the front node         # Traverse all adjacent nodes of u         for ind, node in enumerate(graph[u]):             if visited[ind] is False and node > 0:                 queue.append(ind)                 visited[ind] = True                 parents[ind] = u     return visited[sink]\n1: def find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:     if len(nums) == 0:         raise ValueError(\"find_max_recursive() arg is an empty sequence\")     if (         left >= len(nums)         or left < -len(nums)         or right >= len(nums)         or right < -len(nums)     ):         raise IndexError(\"list index out of range\")     if left == right:         return nums[left]     mid = (left + right) >> 1  # the middle     left_max = find_max_recursive(nums, left, mid)  # find max in range[left, mid]     right_max = find_max_recursive(         nums, mid + 1, right     )  # find max in range[mid + 1, right]      return left_max if left_max >= right_max else right_max\n2: def luhn_validation(credit_card_number: str) -> bool:     cc_number = credit_card_number     total = 0     half_len = len(cc_number) - 2     for i in range(half_len, -1, -2):         #  double the value of every second digit         digit = int(cc_number[i])         digit *= 2         # If doubling of a number results in a two digit number         # i.e greater than 9(e.g., 6 x 2 = 12),         # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),         # to get a single digit number.         if digit > 9:             digit %= 10             digit += 1         cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]         total += digit      # Sum up the remaining digits     for i in range(len(cc_number) - 1, -1, -2):         total += int(cc_number[i])      return total % 10 == 0", "output": "0"}
{"task": "search", "input": "search code:\nCalculate the span values for a given list of stock prices.\n\nChoices:\n0: def gamma_iterative(num: float) -> float:     if num <= 0:         raise ValueError(\"math domain error\")      return quad(integrand, 0, inf, args=(num))[0]\n1: def calculate_span(price: list[int]) -> list[int]:     n = len(price)     s = [0] * n     # Create a stack and push index of fist element to it     st = []     st.append(0)      # Span value of first element is always 1     s[0] = 1      # Calculate span values for rest of the elements     for i in range(1, n):         # Pop elements from stack while stack is not         # empty and top of stack is smaller than price[i]         while len(st) > 0 and price[st[-1]] <= price[i]:             st.pop()          # If stack becomes empty, then price[i] is greater         # than all elements on left of it, i.e. price[0],         # price[1], ..price[i-1]. Else the price[i]  is         # greater than elements after top of stack         s[i] = i + 1 if len(st) <= 0 else (i - st[-1])          # Push this element to stack         st.append(i)      return s\n2: def solution(n: int = 1000) -> int:      return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)", "output": "1"}
{"task": "search", "input": "search code:\nFind the number of digits in a number.\n\nChoices:\n0: def _is_scalar(value, stringlike=(str, bytes)):     \"Scalars are bytes, strings, and non-iterables.\"     try:         iter(value)     except TypeError:         return True     return isinstance(value, stringlike)\n1: def num_digits(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      digits = 0     n = abs(n)     while True:         n = n // 10         digits += 1         if n == 0:             break     return digits\n2: def main():     print(\"Volumes:\")     print(f\"Cube: {vol_cube(2) = }\")  # = 8     print(f\"Cuboid: {vol_cuboid(2, 2, 2) = }\")  # = 8     print(f\"Cone: {vol_cone(2, 2) = }\")  # ~= 1.33     print(f\"Right Circular Cone: {vol_right_circ_cone(2, 2) = }\")  # ~= 8.38     print(f\"Prism: {vol_prism(2, 2) = }\")  # = 4     print(f\"Pyramid: {vol_pyramid(2, 2) = }\")  # ~= 1.33     print(f\"Sphere: {vol_sphere(2) = }\")  # ~= 33.5     print(f\"Hemisphere: {vol_hemisphere(2) = }\")  # ~= 16.75     print(f\"Circular Cylinder: {vol_circular_cylinder(2, 2) = }\")  # ~= 25.1     print(f\"Torus: {vol_torus(2, 2) = }\")  # ~= 157.9     print(f\"Conical Frustum: {vol_conical_frustum(2, 2, 4) = }\")  # ~= 58.6     print(f\"Spherical cap: {vol_spherical_cap(1, 2) = }\")  # ~= 5.24     print(f\"Spheres intersection: {vol_spheres_intersect(2, 2, 1) = }\")  # ~= 21.21     print(f\"Spheres union: {vol_spheres_union(2, 2, 1) = }\")  # ~= 45.81     print(         f\"Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }\"     )  # ~= 28.3     print(f\"Icosahedron: {vol_icosahedron(2.5) = }\")  # ~=34.09", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef mean_absolute_error(predicted_y, original_y):\n    total = sum(abs(y - predicted_y[i]) for i, y in enumerate(original_y))\n    return total / len(original_y)", "output": "Return sum of square error for error calculation"}
{"task": "search", "input": "search code:\n| `weights` - ``int`` list\n\nChoices:\n0: def next_number(number: int) -> int:      sum_of_digits_squared = 0     while number:         # Increased Speed Slightly by checking every 5 digits together.         sum_of_digits_squared += DIGITS_SQUARED[number % 100000]         number //= 100000      return sum_of_digits_squared\n1: def concave_triangle_area(circles_number: int) -> float:      intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (         2 * (circles_number**2 + 1)     )     intersection_x = circles_number * intersection_y      triangle_area = intersection_x * intersection_y / 2     concave_region_area = circle_bottom_arc_integral(         1 / 2     ) - circle_bottom_arc_integral(intersection_x)      return triangle_area + concave_region_area\n2: def procentual_proximity(     source_data: list[list[float]], weights: list[int] ) -> list[list[float]]:      data_lists = get_data(source_data)     score_lists = calculate_each_score(data_lists, weights)     final_scores = generate_final_scores(score_lists)      # append scores to source data     for i, ele in enumerate(final_scores):         source_data[i].append(ele)      return source_data", "output": "2"}
{"task": "search", "input": "search code:\nThe function returns the number of integers that end up being 89 in each chain.\n\nChoices:\n0: def singularize(word):     orig_word, word = word, word.strip().lower()     if not word or word in _IRR_S2P:         return orig_word      irr_singular = _IRR_P2S.get(word)     if irr_singular:         singular = irr_singular     elif not word.endswith('s'):         return orig_word     elif len(word) == 2:         singular = word[:-1]  # or just return word?     elif word.endswith('ies') and word[-4:-3] not in 'aeiou':         singular = word[:-3] + 'y'     elif word.endswith('es') and word[-3] == 's':         singular = word[:-2]     else:         singular = word[:-1]     return _match_case(orig_word, singular)\n1: def solution(number: int = 10000000) -> int:     for i in range(1, number):         if CHAINS[i] is None:             chain(i + 1)      return CHAINS[:number].count(False)\n2: def fibonacci_search(arr: list, val: int) -> int:     len_list = len(arr)     # Find m such that F_m >= n where F_i is the i_th fibonacci number.     i = 0     while True:         if fibonacci(i) >= len_list:             fibb_k = i             break         i += 1     offset = 0     while fibb_k > 0:         index_k = min(             offset + fibonacci(fibb_k - 1), len_list - 1         )  # Prevent out of range         item_k_1 = arr[index_k]         if item_k_1 == val:             return index_k         elif val < item_k_1:             fibb_k -= 1         elif val > item_k_1:             offset += fibonacci(fibb_k - 1)             fibb_k -= 2     return -1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef validate(n: int) -> bool:\n    return not (\n        len(str(n)) > 3\n        and (not is_prime(int(str(n)[-3:])) or not is_prime(int(str(n)[:3])))\n    )", "output": "To optimize the approach, we will rule out the numbers above 1000,"}
{"task": "summary", "input": "summarize code:\ndef min_steps_to_one(number: int) -> int:\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]", "output": "Minimum steps to 1 implemented using tabulation."}
{"task": "summary", "input": "summarize code:\ndef butterfly_pattern(n: int) -> str:\n    result = []\n\n    # Upper part\n    for i in range(1, n):\n        left_stars = \"*\" * i\n        spaces = \" \" * (2 * (n - i) - 1)\n        right_stars = \"*\" * i\n        result.append(left_stars + spaces + right_stars)\n\n    # Middle part\n    result.append(\"*\" * (2 * n - 1))\n\n    # Lower part\n    for i in range(n - 1, 0, -1):\n        left_stars = \"*\" * i\n        spaces = \" \" * (2 * (n - i) - 1)\n        right_stars = \"*\" * i\n        result.append(left_stars + spaces + right_stars)\n\n    return \"\\n\".join(result)", "output": "Creates a butterfly pattern of size n and returns it as a string."}
{"task": "summary", "input": "summarize code:\ndef args2cmd(args, sep=' '):\n    # technique description from subprocess below\n    result = []\n    needquote = False\n    for arg in args:\n        bs_buf = []\n\n        # Add a space to separate this argument from the others\n        if result:\n            result.append(' ')\n\n        needquote = (\" \" in arg) or (\"\\t\" in arg) or not arg\n        if needquote:\n            result.append('\"')\n\n        for c in arg:\n            if c == '\\\\':\n                # Don't know if we need to double yet.\n                bs_buf.append(c)\n            elif c == '\"':\n                # Double backslashes.\n                result.append('\\\\' * len(bs_buf)*2)\n                bs_buf = []\n                result.append('\\\\\"')\n            else:\n                # Normal char\n                if bs_buf:\n                    result.extend(bs_buf)\n                    bs_buf = []\n                result.append(c)\n\n        # Add remaining backslashes, if any.\n        if bs_buf:\n            result.extend(bs_buf)\n\n        if needquote:\n            result.extend(bs_buf)\n            result.append('\"')\n\n    return ''.join(result)", "output": "Return a shell-escaped string version of *args*, separated by"}
{"task": "summary", "input": "summarize code:\ndef maclaurin_cos(theta: float, accuracy: int = 30) -> float:\n\n    if not isinstance(theta, (int, float)):\n        raise ValueError(\"maclaurin_cos() requires either an int or float for theta\")\n\n    if not isinstance(accuracy, int) or accuracy <= 0:\n        raise ValueError(\"maclaurin_cos() requires a positive int for accuracy\")\n\n    theta = float(theta)\n    div = theta // (2 * pi)\n    theta -= 2 * div * pi\n    return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))", "output": "Finds the maclaurin approximation of cos"}
{"task": "search", "input": "search code:\nTakes a number and checks if it is pandigital both from start and end\n\nChoices:\n0: def freq_subgraphs_edge_list(paths):     freq_sub_el = []     for edges in paths:         el = []         for j in range(len(edges) - 1):             temp = list(edges[j])             for e in temp:                 edge = (e[0], e[1])                 el.append(edge)         freq_sub_el.append(el)     return freq_sub_el\n1: def astar(world, start, goal):     _open = []     _closed = []     _open.append(start)      while _open:         min_f = np.argmin([n.f for n in _open])         current = _open[min_f]         _closed.append(_open.pop(min_f))         if current == goal:             break         for n in world.get_neighbours(current):             for c in _closed:                 if c == n:                     continue             n.g = current.g + 1             x1, y1 = n.position             x2, y2 = goal.position             n.h = (y2 - y1) ** 2 + (x2 - x1) ** 2             n.f = n.h + n.g              for c in _open:                 if c == n and c.f < n.f:                     continue             _open.append(n)     path = []     while current.parent is not None:         path.append(current.position)         current = current.parent     path.append(current.position)     return path[::-1]\n2: def check(number: int) -> bool:      check_last = [0] * 11     check_front = [0] * 11      # mark last 9 numbers     for _ in range(9):         check_last[int(number % 10)] = 1         number = number // 10     # flag     f = True      # check last 9 numbers for pandigitality      for x in range(9):         if not check_last[x + 1]:             f = False     if not f:         return f      # mark first 9 numbers     number = int(str(number)[:9])      for _ in range(9):         check_front[int(number % 10)] = 1         number = number // 10      # check first 9 numbers for pandigitality      for x in range(9):         if not check_front[x + 1]:             f = False     return f", "output": "2"}
{"task": "detection", "input": "classify code:\ndef is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    return subset[arr_len][required_sum]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nProvides option 'string' or 'file' to take input\n\nChoices:\n0: def main() -> None:      # unittest.main()      import doctest      doctest.testmod()      parser = argparse.ArgumentParser()     parser.add_argument(         \"-s\",         \"--string\",         dest=\"input_string\",         default=\"Hello World!! Welcome to Cryptography\",         help=\"Hash the string\",     )     parser.add_argument(         \"-f\", \"--file\", dest=\"input_file\", help=\"Hash contents of a file\"     )      args = parser.parse_args()      input_string = args.input_string      # hash input should be a bytestring     if args.input_file:         with open(args.input_file, \"rb\") as f:             hash_input = f.read()     else:         hash_input = bytes(input_string, \"utf-8\")      print(SHA256(hash_input).hash)\n1: def insert(node: BinaryTreeNode | None, new_value: int) -> BinaryTreeNode | None:     if node is None:         node = BinaryTreeNode(new_value)         return node      # binary search tree is not empty,     # so we will insert it into the tree     # if new_value is less than value of data in node,     #  add it to left subtree and proceed recursively     if new_value < node.data:         node.left_child = insert(node.left_child, new_value)     else:         # if new_value is greater than value of data in node,         #  add it to right subtree and proceed recursively         node.right_child = insert(node.right_child, new_value)     return node\n2: def rotate_array(arr: list[int], steps: int) -> list[int]:      n = len(arr)     if n == 0:         return arr      steps = steps % n      if steps < 0:         steps += n      def reverse(start: int, end: int) -> None:          while start < end:             arr[start], arr[end] = arr[end], arr[start]             start += 1             end -= 1      reverse(0, n - 1)     reverse(0, steps - 1)     reverse(steps, n - 1)      return arr", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef scaled_exponential_linear_unit(\n    vector: np.ndarray, alpha: float = 1.6732, lambda_: float = 1.0507\n) -> np.ndarray:\n    return lambda_ * np.where(vector > 0, vector, alpha * (np.exp(vector) - 1))", "output": "Applies the Scaled Exponential Linear Unit function to each element of the vector."}
{"task": "summary", "input": "summarize code:\ndef find_set(x: Node) -> Node:\n    if x != x.parent:\n        x.parent = find_set(x.parent)\n    return x.parent", "output": "Return the parent of x"}
{"task": "summary", "input": "summarize code:\ndef ipv4_to_decimal(ipv4_address: str) -> int:\n\n    octets = [int(octet) for octet in ipv4_address.split(\".\")]\n    if len(octets) != 4:\n        raise ValueError(\"Invalid IPv4 address format\")\n\n    decimal_ipv4 = 0\n    for octet in octets:\n        if not 0 <= octet <= 255:\n            raise ValueError(f\"Invalid IPv4 octet {octet}\")  # noqa: EM102\n        decimal_ipv4 = (decimal_ipv4 << 8) + int(octet)\n\n    return decimal_ipv4", "output": "Convert an IPv4 address to its decimal representation."}
{"task": "summary", "input": "summarize code:\ndef mse(predict, actual):\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    square_diff = np.square(difference)\n\n    score = square_diff.mean()\n    return score", "output": "Examples(rounded for precision):"}
{"task": "detection", "input": "classify code:\ndef combination_sum_iv_dp_array(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef tf_idf(tf: int, idf: int) -> float:\n    return round(tf * idf, 3)", "output": "Combine the term frequency"}
{"task": "summary", "input": "summarize code:\ndef gamma_recursive(num: float) -> float:\n    if num <= 0:\n        raise ValueError(\"math domain error\")\n    if num > 171.5:\n        raise OverflowError(\"math range error\")\n    elif num - int(num) not in (0, 0.5):\n        raise NotImplementedError(\"num must be an integer or a half-integer\")\n    elif num == 0.5:\n        return math.sqrt(math.pi)\n    else:\n        return 1.0 if num == 1 else (num - 1) * gamma_recursive(num - 1)", "output": "Calculates the value of Gamma function of num"}
{"task": "search", "input": "search code:\nDefine n count list and loop over delta, y to get the counts, then check\n\nChoices:\n0: def _construct_points(     list_of_tuples: list[Point] | list[list[float]] | Iterable[list[float]], ) -> list[Point]:      points: list[Point] = []     if list_of_tuples:         for p in list_of_tuples:             if isinstance(p, Point):                 points.append(p)             else:                 try:                     points.append(Point(p[0], p[1]))                 except (IndexError, TypeError):                     print(                         f\"Ignoring deformed point {p}. All points\"                         \" must have at least 2 coordinates.\"                     )     return points\n1: def solution(n_limit: int = 50 * 10**6) -> int:     n_sol = [0] * n_limit      for delta in range(1, (n_limit + 1) // 4 + 1):         for y in range(4 * delta - 1, delta, -1):             n = y * (4 * delta - y)             if n >= n_limit:                 break             n_sol[n] += 1      ans = 0     for i in range(n_limit):         if n_sol[i] == 1:             ans += 1      return ans\n2: def solution(n: int = 4) -> int | None:     results = run(n)     return results[0] if len(results) else None", "output": "1"}
{"task": "search", "input": "search code:\nWe can find Catalan number many ways but here we use Binomial Coefficient because it\n\nChoices:\n0: def normalization(data: list, ndigits: int = 3) -> list:     # variables for calculation     x_min = min(data)     x_max = max(data)     # normalize data     return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]\n1: def recursive_match(text: str, pattern: str) -> bool:     if not pattern:         return not text      if not text:         return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])      if text[-1] == pattern[-1] or pattern[-1] == \".\":         return recursive_match(text[:-1], pattern[:-1])      if pattern[-1] == \"*\":         return recursive_match(text[:-1], pattern) or recursive_match(             text, pattern[:-2]         )      return False\n2: def catalan_number(node_count: int) -> int:     return binomial_coefficient(2 * node_count, node_count) // (node_count + 1)", "output": "2"}
{"task": "search", "input": "search code:\nCapitalizes the first letter of a sentence or word.\n\nChoices:\n0: def capitalize(sentence: str) -> str:     if not sentence:         return \"\"      # Capitalize the first character if it's a lowercase letter     # Concatenate the capitalized character with the rest of the string     return sentence[0].upper() + sentence[1:]\n1: def chain_length(n: int, previous: set | None = None) -> int:     previous = previous or set()     if n in CHAIN_LENGTH_CACHE:         return CHAIN_LENGTH_CACHE[n]     next_number = sum_digit_factorials(n)     if next_number in previous:         CHAIN_LENGTH_CACHE[n] = 0         return 0     else:         previous.add(n)         ret = 1 + chain_length(next_number, previous)         CHAIN_LENGTH_CACHE[n] = ret         return ret\n2: def solution(max_n: int = 100) -> int:     pre_numerator = 1     cur_numerator = 2      for i in range(2, max_n + 1):         temp = pre_numerator         e_cont = 2 * i // 3 if i % 3 == 0 else 1         pre_numerator = cur_numerator         cur_numerator = e_cont * pre_numerator + temp      return sum_digits(cur_numerator)", "output": "0"}
{"task": "search", "input": "search code:\nFinds the maclaurin approximation of cos\n\nChoices:\n0: def soboleva_modified_hyperbolic_tangent(     vector: np.ndarray, a_value: float, b_value: float, c_value: float, d_value: float ) -> np.ndarray:      # Separate the numerator and denominator for simplicity     # Calculate the numerator and denominator element-wise     numerator = np.exp(a_value * vector) - np.exp(-b_value * vector)     denominator = np.exp(c_value * vector) + np.exp(-d_value * vector)      # Calculate and return the final result element-wise     return numerator / denominator\n1: def maclaurin_cos(theta: float, accuracy: int = 30) -> float:      if not isinstance(theta, (int, float)):         raise ValueError(\"maclaurin_cos() requires either an int or float for theta\")      if not isinstance(accuracy, int) or accuracy <= 0:         raise ValueError(\"maclaurin_cos() requires a positive int for accuracy\")      theta = float(theta)     div = theta // (2 * pi)     theta -= 2 * div * pi     return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))\n2: def interact_treap(root: Node | None, args: str) -> Node | None:     for arg in args.split():         if arg[0] == \"+\":             root = insert(root, int(arg[1:]))          elif arg[0] == \"-\":             root = erase(root, int(arg[1:]))          else:             print(\"Unknown command\")      return root", "output": "1"}
{"task": "search", "input": "search code:\nReturn gray image from rgb image\n\nChoices:\n0: def solution() -> int:     limit = 7 * factorial(9) + 1     return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)\n1: def get_all_subclasses(cls):     try:         to_check = deque(cls.__subclasses__())     except (AttributeError, TypeError):         raise TypeError('expected type object, not %r' % cls)     seen, ret = set(), []     while to_check:         cur = to_check.popleft()         if cur in seen:             continue         ret.append(cur)         seen.add(cur)         to_check.extend(cur.__subclasses__())     return ret\n2: def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:     r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]     return 0.2989 * r + 0.5870 * g + 0.1140 * b", "output": "2"}
{"task": "detection", "input": "classify code:\ndef is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef find_minimum_partitions(string: str) -> int:\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]", "output": "Returns the minimum cuts needed for a palindrome partitioning of string"}
{"task": "detection", "input": "classify code:\ndef load_data() -> list[list[str]]:\n    \"\"\"\n    Returns a sample transaction dataset.\n\n    >>> load_data()\n    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]\n    \"\"\"\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculate the number of non-bouncy numbers with at most n digits.\n\nChoices:\n0: def covariance_between_classes(     features: np.ndarray, labels: np.ndarray, classes: int ) -> np.ndarray:      general_data_mean = features.mean(1)     covariance_sum = np.nan     for i in range(classes):         data = features[:, labels == i]         device_data = data.shape[1]         data_mean = data.mean(1)         if i > 0:             # If covariance_sum is not None             covariance_sum += device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )         else:             # If covariance_sum is np.nan (i.e. first loop)             covariance_sum = device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )      return covariance_sum / features.shape[1]\n1: def fizz_buzz(number: int, iterations: int) -> str:     if not isinstance(iterations, int):         raise ValueError(\"iterations must be defined as integers\")     if not isinstance(number, int) or not number >= 1:         raise ValueError(         )     if not iterations >= 1:         raise ValueError(\"Iterations must be done more than 0 times to play FizzBuzz\")      out = \"\"     while number <= iterations:         if number % 3 == 0:             out += \"Fizz\"         if number % 5 == 0:             out += \"Buzz\"         if 0 not in (number % 3, number % 5):             out += str(number)          # print(out)         number += 1         out += \" \"     return out\n2: def non_bouncy_exact(n: int) -> int:     return choose(8 + n, n) + choose(9 + n, n) - 10", "output": "2"}
{"task": "search", "input": "search code:\nSplit an audio signal into overlapping frames.\n\nChoices:\n0: def mode(input_list: list) -> list[Any]:     if not input_list:         return []     result = [input_list.count(value) for value in input_list]     y = max(result)  # Gets the maximum count in the input list.     # Gets values of modes     return sorted({input_list[i] for i, value in enumerate(result) if value == y})\n1: def audio_frames(     audio: np.ndarray,     sample_rate: int,     hop_length: int = 20,     ftt_size: int = 1024, ) -> np.ndarray:      hop_size = np.round(sample_rate * hop_length / 1000).astype(int)      # Pad the audio signal to handle edge cases     audio = np.pad(audio, int(ftt_size / 2), mode=\"reflect\")      # Calculate the number of frames     frame_count = int((len(audio) - ftt_size) / hop_size) + 1      # Initialize an array to store the frames     frames = np.zeros((frame_count, ftt_size))      # Split the audio signal into frames     for n in range(frame_count):         frames[n] = audio[n * hop_size : n * hop_size + ftt_size]      return frames\n2: def longest_subsequence(array: list[int]) -> list[int]:     n = len(array)     # The longest increasing subsequence ending at array[i]     longest_increasing_subsequence = []     for i in range(n):         longest_increasing_subsequence.append([array[i]])      for i in range(1, n):         for prev in range(i):             # If array[prev] is less than or equal to array[i], then             # longest_increasing_subsequence[prev] + array[i]             # is a valid increasing subsequence              # longest_increasing_subsequence[i] is only set to             # longest_increasing_subsequence[prev] + array[i] if the length is longer.              if array[prev] <= array[i] and len(                 longest_increasing_subsequence[prev]             ) + 1 > len(longest_increasing_subsequence[i]):                 longest_increasing_subsequence[i] = copy.copy(                     longest_increasing_subsequence[prev]                 )                 longest_increasing_subsequence[i].append(array[i])      result: list[int] = []     for i in range(n):         if len(longest_increasing_subsequence[i]) > len(result):             result = longest_increasing_subsequence[i]      return result", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef cosine_similarity(input_a: np.ndarray, input_b: np.ndarray) -> float:\n    return float(np.dot(input_a, input_b) / (norm(input_a) * norm(input_b)))", "output": "Calculates cosine similarity between two data."}
{"task": "detection", "input": "classify code:\ndef get_distance(highway_now: list, car_index: int) -> int:\n    \"\"\"\n    Get the distance between a car (at index car_index) and the next car\n    >>> get_distance([6, -1, 6, -1, 6], 2)\n    1\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n    3\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n    4\n    \"\"\"\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef breadth_first_search(graph: dict, start: str) -> list[str]:\n    explored = {start}\n    result = [start]\n    queue: Queue = Queue()\n    queue.put(start)\n    while not queue.empty():\n        v = queue.get()\n        for w in graph[v]:\n            if w not in explored:\n                explored.add(w)\n                result.append(w)\n                queue.put(w)\n    return result", "output": "Implementation of breadth first search using queue.Queue."}
{"task": "search", "input": "search code:\nRemove leading and trailing characters (whitespace by default) from a string.\n\nChoices:\n0: def emails_from_url(url: str = \"https://github.com\") -> list[str]:     # Get the base domain from the url     domain = get_domain_name(url)      # Initialize the parser     parser = Parser(domain)      try:         # Open URL         r = httpx.get(url, timeout=10, follow_redirects=True)          # pass the raw HTML to the parser to get links         parser.feed(r.text)          # Get links and loop through         valid_emails = set()         for link in parser.urls:             # open URL.             # Check if the link is already absolute             if not link.startswith(\"http://\") and not link.startswith(\"https://\"):                 # Prepend protocol only if link starts with domain, normalize otherwise                 if link.startswith(domain):                     link = f\"https://{link}\"                 else:                     link = parse.urljoin(f\"https://{domain}\", link)             try:                 read = httpx.get(link, timeout=10, follow_redirects=True)                 # Get the valid email.                 emails = re.findall(\"[a-zA-Z0-9]+@\" + domain, read.text)                 # If not in list then append it.                 for email in emails:                     valid_emails.add(email)             except ValueError:                 pass     except ValueError:         raise SystemExit(1)      # Finally return a sorted list of email addresses with no duplicates.     return sorted(valid_emails)\n1: def _running_median_windowed(iterator, maxlen):     \"Yield median of values in a sliding window.\"      window = deque()     ordered = []      for x in iterator:         window.append(x)         insort(ordered, x)          if len(ordered) > maxlen:             i = bisect_left(ordered, window.popleft())             del ordered[i]          n = len(ordered)         m = n // 2         yield ordered[m] if n & 1 else (ordered[m - 1] + ordered[m]) / 2\n2: def strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:      start = 0     end = len(user_string)      while start < end and user_string[start] in characters:         start += 1      while end > start and user_string[end - 1] in characters:         end -= 1      return user_string[start:end]", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to pressure.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_pressure(0.82, 3, 300)\n      90\n      >>> moles_to_pressure(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (volume)))", "output": "def moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to pressure.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_pressure(0.82, 3, 300)\n      90\n      >>> moles_to_pressure(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (volume)))"}
{"task": "summary", "input": "summarize code:\ndef slow_primes(max_n: int) -> Generator[int]:\n    numbers: Generator = (i for i in range(1, (max_n + 1)))\n    for i in (n for n in numbers if n > 1):\n        for j in range(2, i):\n            if (i % j) == 0:\n                break\n        else:\n            yield i", "output": "Return a list of all primes numbers up to max."}
{"task": "summary", "input": "summarize code:\ndef combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:\n\n    dp_array = [0] * (target + 1)\n    dp_array[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - array[j] >= 0:\n                dp_array[i] += dp_array[i - array[j]]\n\n    return dp_array[target]", "output": "Function checks the all possible combinations with using bottom up approach,"}
{"task": "summary", "input": "summarize code:\ndef euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:\n    return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)", "output": "Calculate the distance between the two endpoints of two vectors without numpy."}
{"task": "search", "input": "search code:\nYield the items from *iterable*, but strip any from the beginning\n\nChoices:\n0: def tf_idf(tf: int, idf: int) -> float:     return round(tf * idf, 3)\n1: def lstrip(iterable, pred):     return dropwhile(pred, iterable)\n2: def compute_nums(n: int) -> list[int]:     if not isinstance(n, int):         raise ValueError(\"n must be an integer\")     if n <= 0:         raise ValueError(\"n must be >= 0\")      list_nums = []     for num in range(len(odd_composites)):         i = 0         while 2 * i * i <= odd_composites[num]:             rem = odd_composites[num] - 2 * i * i             if is_prime(rem):                 break             i += 1         else:             list_nums.append(odd_composites[num])             if len(list_nums) == n:                 return list_nums      return []", "output": "1"}
{"task": "search", "input": "search code:\nTwo way partition the data into smaller and greater lists,\n\nChoices:\n0: def get_factors(     number: int, factors: Counter | None = None, factor: int = 2 ) -> Counter:      match number:         case int(number) if number == 1:             return Counter({1: 1})         case int(num) if number > 0:             number = num         case _:             raise TypeError(\"number must be integer and greater than zero\")      factors = factors or Counter()      if number == factor:  # break condition         # all numbers are factors of itself         factors[factor] += 1         return factors      if number % factor > 0:         # if it is greater than zero         # so it is not a factor of number and we check next number         return get_factors(number, factors, factor + 1)      factors[factor] += 1     # else we update factors (that is Counter(dict-like) type) and check again     return get_factors(number // factor, factors, factor)\n1: def quick_select(arr: list, target: int) -> int:      # Invalid Input     if target > len(arr):         return -1      # x is the estimated pivot by median of medians algorithm     x = median_of_medians(arr)     left = []     right = []     check = False     for i in range(len(arr)):         if arr[i] < x:             left.append(arr[i])         elif arr[i] > x:             right.append(arr[i])         elif arr[i] == x and not check:             check = True         else:             right.append(arr[i])     rank_x = len(left) + 1     if rank_x == target:         answer = x     elif rank_x > target:         answer = quick_select(left, target)     elif rank_x < target:         answer = quick_select(right, target - rank_x)     return answer\n2: def square_zero_matrix(n: int) -> Matrix:     ans: list[list[float]] = [[0] * n for _ in range(n)]     return Matrix(ans, n, n)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef concurrent_tee(iterable, n=2):\n\n    if n < 0:\n        raise ValueError\n    if n == 0:\n        return ()\n    iterator = _concurrent_tee(iterable)\n    result = [iterator]\n    for _ in range(n - 1):\n        result.append(_concurrent_tee(iterator))\n    return tuple(result)", "output": "Variant of itertools.tee() but with guaranteed threading semantics."}
{"task": "detection", "input": "classify code:\ndef identity(n: int) -> list[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nsubreddit : Subreddit to query\n\nChoices:\n0: def validate_initial_digits(credit_card_number: str) -> bool:     return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))\n1: def get_subreddit_data(     subreddit: str, limit: int = 1, age: str = \"new\", wanted_data: list | None = None ) -> dict:     wanted_data = wanted_data or []     if invalid_search_terms := \", \".join(sorted(set(wanted_data) - valid_terms)):         msg = f\"Invalid search term: {invalid_search_terms}\"         raise ValueError(msg)     response = httpx.get(         f\"https://www.reddit.com/r/{subreddit}/{age}.json?limit={limit}\",         headers={\"User-agent\": \"A random string\"},         timeout=10,     )     response.raise_for_status()     if response.status_code == 429:         raise httpx.HTTPError(response=response)      data = response.json()     if not wanted_data:         return {id_: data[\"data\"][\"children\"][id_] for id_ in range(limit)}      data_dict = {}     for id_ in range(limit):         data_dict[id_] = {             item: data[\"data\"][\"children\"][id_][\"data\"][item] for item in wanted_data         }     return data_dict\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:\n    img_paths = []\n    labels = []\n    for label_file in glob.glob(os.path.join(label_dir, \"*.txt\")):\n        label_name = label_file.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        with open(label_file) as in_file:\n            obj_lists = in_file.readlines()\n        img_path = os.path.join(img_dir, f\"{label_name}.jpg\")\n\n        boxes = []\n        for obj_list in obj_lists:\n            obj = obj_list.rstrip(\"\\n\").split(\" \")\n            xmin = float(obj[1]) - float(obj[3]) / 2\n            ymin = float(obj[2]) - float(obj[4]) / 2\n            xmax = float(obj[1]) + float(obj[3]) / 2\n            ymax = float(obj[2]) + float(obj[4]) / 2\n\n            boxes.append([int(obj[0]), xmin, ymin, xmax, ymax])\n        if not boxes:\n            continue\n        img_paths.append(img_path)\n        labels.append(boxes)\n    return img_paths, labels", "output": "- label_dir <type: str>: Path to label include annotation of images"}
{"task": "search", "input": "search code:\nReturns the solution of the problem\n\nChoices:\n0: def alternative_string_arrange(first_str: str, second_str: str) -> str:     first_str_length: int = len(first_str)     second_str_length: int = len(second_str)     abs_length: int = (         first_str_length if first_str_length > second_str_length else second_str_length     )     output_list: list = []     for char_count in range(abs_length):         if char_count < first_str_length:             output_list.append(first_str[char_count])         if char_count < second_str_length:             output_list.append(second_str[char_count])     return \"\".join(output_list)\n1: def charging_inductor(     source_voltage: float,  # source_voltage should be in volts.     resistance: float,  # resistance should be in ohms.     inductance: float,  # inductance should be in henrys.     time: float,  # time should in seconds. ) -> float:      if source_voltage <= 0:         raise ValueError(\"Source voltage must be positive.\")     if resistance <= 0:         raise ValueError(\"Resistance must be positive.\")     if inductance <= 0:         raise ValueError(\"Inductance must be positive.\")     return round(         source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3     )\n2: def solution(family_length: int = 8) -> int:     numbers_checked = set()      # Filter primes with less than 3 replaceable digits     primes = {         x for x in set(prime_sieve(1_000_000)) if len(str(x)) - len(set(str(x))) >= 3     }      for prime in primes:         if prime in numbers_checked:             continue          replacements = digit_replacements(prime)          for family in replacements:             numbers_checked.update(family)             primes_in_family = primes.intersection(family)              if len(primes_in_family) != family_length:                 continue              return min(primes_in_family)      return -1", "output": "2"}
{"task": "search", "input": "search code:\nGiven the numerators and denominators of three fractions, return the\n\nChoices:\n0: def sum_digits(num: int) -> int:     digit_sum = 0     while num > 0:         digit_sum += num % 10         num //= 10     return digit_sum\n1: def product_sum_array(array: list[int | list]) -> int:     return product_sum(array, 1)\n2: def add_three(     x_num: int, x_den: int, y_num: int, y_den: int, z_num: int, z_den: int ) -> tuple[int, int]:     top: int = x_num * y_den * z_den + y_num * x_den * z_den + z_num * x_den * y_den     bottom: int = x_den * y_den * z_den     hcf: int = gcd(top, bottom)     top //= hcf     bottom //= hcf     return top, bottom", "output": "2"}
{"task": "search", "input": "search code:\nSolve the crossword puzzle using backtracking.\n\nChoices:\n0: def solve_crossword(puzzle: list[list[str]], words: list[str]) -> bool:     for row in range(len(puzzle)):         for col in range(len(puzzle[0])):             if puzzle[row][col] == \"\":                 for word in words:                     for vertical in [True, False]:                         if is_valid(puzzle, word, row, col, vertical):                             place_word(puzzle, word, row, col, vertical)                             words.remove(word)                             if solve_crossword(puzzle, words):                                 return True                             words.append(word)                             remove_word(puzzle, word, row, col, vertical)                 return False     return True\n1: def ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:     if (voltage, current, resistance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance < 0:         raise ValueError(\"Resistance cannot be negative\")     if voltage == 0:         return {\"voltage\": float(current * resistance)}     elif current == 0:         return {\"current\": voltage / resistance}     elif resistance == 0:         return {\"resistance\": voltage / current}     else:         raise ValueError(\"Exactly one argument must be 0\")\n2: def filter_common_word(possibles: list[str], common_word: str) -> list[str]:     return [possible for possible in possibles if common_word in possible.lower()]", "output": "0"}
{"task": "search", "input": "search code:\nDeciphers a message given a cipher map\n\nChoices:\n0: def decipher(message: str, cipher_map: dict[str, str]) -> str:     # Reverse our cipher mappings     rev_cipher_map = {v: k for k, v in cipher_map.items()}     return \"\".join(rev_cipher_map.get(ch, ch) for ch in message.upper())\n1: def random_derangement(iterable):     seq = tuple(iterable)     if len(seq) < 2:         if len(seq) == 0:             return ()         raise IndexError('No derangments to choose from')     perm = list(range(len(seq)))     start = tuple(perm)     while True:         shuffle(perm)         if not any(map(is_, start, perm)):             return itemgetter(*perm)(seq)\n2: def bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:     if length > 1:         middle = int(length / 2)         for i in range(low, low + middle):             comp_and_swap(array, i, i + middle, direction)         bitonic_merge(array, low, middle, direction)         bitonic_merge(array, low + middle, middle, direction)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFunction returns the right side view of binary tree.\n\nChoices:\n0: def solution(limit: float = 1e10) -> int:     primes = sieve()      n = 1     while True:         prime = next(primes)         if (2 * prime * n) > limit:             return n         # Ignore the next prime as the reminder will be 2.         next(primes)         n += 2\n1: def binary_tree_right_side_view(root: TreeNode) -> list[int]:      def depth_first_search(         root: TreeNode | None, depth: int, right_view: list[int]     ) -> None:         if not root:             return          if depth == len(right_view):             right_view.append(root.val)          depth_first_search(root.right, depth + 1, right_view)         depth_first_search(root.left, depth + 1, right_view)      right_view: list = []     if not root:         return right_view      depth_first_search(root, 0, right_view)     return right_view\n2: def solution() -> float:      peter_totals_frequencies = total_frequency_distribution(         sides_number=4, dice_number=9     )     colin_totals_frequencies = total_frequency_distribution(         sides_number=6, dice_number=6     )      peter_wins_count = 0     min_peter_total = 9     max_peter_total = 4 * 9     min_colin_total = 6     for peter_total in range(min_peter_total, max_peter_total + 1):         peter_wins_count += peter_totals_frequencies[peter_total] * sum(             colin_totals_frequencies[min_colin_total:peter_total]         )      total_games_number = (4**9) * (6**6)     peter_win_probability = peter_wins_count / total_games_number      rounded_peter_win_probability = round(peter_win_probability, ndigits=7)      return rounded_peter_win_probability", "output": "1"}
{"task": "search", "input": "search code:\nReturn the sum of N(n) for 1 <= n <= n_limit.\n\nChoices:\n0: def find_median(nums: list[int | float]) -> float:     div, mod = divmod(len(nums), 2)     if mod:         return nums[div]     return (nums[div] + nums[(div) - 1]) / 2\n1: def solution(t_limit: int = 1000000, n_limit: int = 10) -> int:     count: defaultdict = defaultdict(int)      for outer_width in range(3, (t_limit // 4) + 2):         if outer_width * outer_width > t_limit:             hole_width_lower_bound = max(                 ceil(sqrt(outer_width * outer_width - t_limit)), 1             )         else:             hole_width_lower_bound = 1          hole_width_lower_bound += (outer_width - hole_width_lower_bound) % 2          for hole_width in range(hole_width_lower_bound, outer_width - 1, 2):             count[outer_width * outer_width - hole_width * hole_width] += 1      return sum(1 for n in count.values() if 1 <= n <= n_limit)\n2: def find_freq_subgraph_given_support(s, cluster, graph):     k = int(s / 100 * (len(cluster) - 1))     for i in cluster[k]:         my_dfs(graph, tuple(cluster[k][i]), ([\"Header\"],))", "output": "1"}
{"task": "search", "input": "search code:\nIntersperse filler element *e* among the items in *iterable*, leaving\n\nChoices:\n0: def intersperse(e, iterable, n=1):     if n == 0:         raise ValueError('n must be > 0')     elif n == 1:         # interleave(repeat(e), iterable) -> e, x_0, e, x_1, e, x_2...         # islice(..., 1, None) -> x_0, e, x_1, e, x_2...         return islice(interleave(repeat(e), iterable), 1, None)     else:         # interleave(filler, chunks) -> [e], [x_0, x_1], [e], [x_2, x_3]...         # islice(..., 1, None) -> [x_0, x_1], [e], [x_2, x_3]...         # flatten(...) -> x_0, x_1, e, x_2, x_3...         filler = repeat([e])         chunks = chunked(iterable, n)         return flatten(islice(interleave(filler, chunks), 1, None))\n1: def decimal_to_ipv4(decimal_ipv4: int) -> str:      if not (0 <= decimal_ipv4 <= 4294967295):         raise ValueError(\"Invalid decimal IPv4 address\")      ip_parts = []     for _ in range(4):         ip_parts.append(str(decimal_ipv4 & 255))         decimal_ipv4 >>= 8      return \".\".join(reversed(ip_parts))\n2: def maclaurin_sin(theta: float, accuracy: int = 30) -> float:      if not isinstance(theta, (int, float)):         raise ValueError(\"maclaurin_sin() requires either an int or float for theta\")      if not isinstance(accuracy, int) or accuracy <= 0:         raise ValueError(\"maclaurin_sin() requires a positive int for accuracy\")      theta = float(theta)     div = theta // (2 * pi)     theta -= 2 * div * pi     return sum(         (-1) ** r * theta ** (2 * r + 1) / factorial(2 * r + 1) for r in range(accuracy)     )", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]", "output": "Function updates the largest_square_area[0], if recursive call found"}
{"task": "summary", "input": "summarize code:\ndef display_billionaires(forbes_billionaires: list[dict[str, int | str]]) -> None:\n\n    table = rich_table.Table(\n        title=f\"Forbes Top {LIMIT} Real-Time Billionaires at {TODAY:%Y-%m-%d %H:%M}\",\n        style=\"green\",\n        highlight=True,\n        box=box.SQUARE,\n    )\n    for key in forbes_billionaires[0]:\n        table.add_column(key)\n\n    for billionaire in forbes_billionaires:\n        table.add_row(*billionaire.values())\n\n    rich_console.Console().print(table)", "output": "Display Forbes real-time billionaires in a rich table."}
{"task": "search", "input": "search code:\nCompute low-dimensional affinities (Q matrix) using a Student-t distribution.\n\nChoices:\n0: def reactive_power(apparent_power: float, power_factor: float) -> float:     if (         not isinstance(power_factor, (int, float))         or power_factor < -1         or power_factor > 1     ):         raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")     return apparent_power * math.sqrt(1 - power_factor**2)\n1: def compute_low_dim_affinities(embedding_matrix: ndarray) -> tuple[ndarray, ndarray]:     squared_sum = np.sum(np.square(embedding_matrix), axis=1)     numerator_matrix = 1 / (         1         + np.add(             np.add(-2 * np.dot(embedding_matrix, embedding_matrix.T), squared_sum).T,             squared_sum,         )     )     np.fill_diagonal(numerator_matrix, 0)      q_matrix = numerator_matrix / np.sum(numerator_matrix)     return q_matrix, numerator_matrix\n2: def resolve_path_parts(path_parts):     # TODO: what to do with multiple slashes     ret = []      for part in path_parts:         if part == '.':             pass         elif part == '..':             if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting                 ret.pop()         else:             ret.append(part)      if list(path_parts[-1:]) in (['.'], ['..']):         ret.append('')      return ret", "output": "1"}
{"task": "search", "input": "search code:\nConverts the given data to the appropriate number if it is indeed a number, else\n\nChoices:\n0: def generate_sum_of_subsets_solutions(nums: list[int], max_sum: int) -> list[list[int]]:      result: list[list[int]] = []     path: list[int] = []     num_index = 0     remaining_nums_sum = sum(nums)     create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)     return result\n1: def compress(source_path: str, destination_path: str) -> None:     data_bits = read_file_binary(source_path)     compressed = compress_data(data_bits)     compressed = add_file_length(source_path, compressed)     write_file_binary(destination_path, compressed)\n2: def parse_token(token: str | float) -> float | str:     if token in OPERATORS:         return token     try:         return float(token)     except ValueError:         msg = f\"{token} is neither a number nor a valid operator\"         raise ValueError(msg)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef get_black_and_white_rgb(distance: float) -> tuple:\n    \"\"\"\n    Black&white color-coding that ignores the relative distance. The Mandelbrot\n    set is black, everything else is white.\n\n    >>> get_black_and_white_rgb(0)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(0.5)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return (255, 255, 255)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef generate_large_matrix() -> list[list[int]]:\n    \"\"\"\n    >>> generate_large_matrix() # doctest: +ELLIPSIS\n    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]\n    \"\"\"\n    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFor each neighbour check if the coloring constraint is satisfied\n\nChoices:\n0: def polynomial_from_roots(roots):      # This recipe differs from the one in itertools docs in that it     # applies list() after each call to convolve().  This avoids     # hitting stack limits with nested generators.      poly = [1]     for root in roots:         poly = list(convolve(poly, (1, -root)))     return poly\n1: def harmonic_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 0     for val in series:         answer += 1 / val     return len(series) / answer\n2: def valid_coloring(     neighbours: list[int], colored_vertices: list[int], color: int ) -> bool:     # Does any neighbour not satisfy the constraints     return not any(         neighbour == 1 and colored_vertices[i] == color         for i, neighbour in enumerate(neighbours)     )", "output": "2"}
{"task": "search", "input": "search code:\nConvert to fractional number.\n\nChoices:\n0: def fractional(value):     try:         number = float(value)     except (TypeError, ValueError):         return value     whole_number = int(number)     frac = Fraction(number - whole_number).limit_denominator(1000)     numerator = frac._numerator     denominator = frac._denominator     if whole_number and not numerator and denominator == 1:         # this means that an integer was passed in         # (or variants of that integer like 1.0000)         return f\"{whole_number:.0f}\"     elif not whole_number:         return f\"{numerator:.0f}/{denominator:.0f}\"     else:         return f\"{whole_number:.0f} {numerator:.0f}/{denominator:.0f}\"\n1: def get_path(root, path, default=_UNSET):     if isinstance(path, str):         path = path.split('.')     cur = root     try:         for seg in path:             try:                 cur = cur[seg]             except (KeyError, IndexError) as exc:                 raise PathAccessError(exc, seg, path)             except TypeError as exc:                 # either string index in a list, or a parent that                 # doesn't support indexing                 try:                     seg = int(seg)                     cur = cur[seg]                 except (ValueError, KeyError, IndexError, TypeError):                     if not is_iterable(cur):                         exc = TypeError('%r object is not indexable'                                         % type(cur).__name__)                     raise PathAccessError(exc, seg, path)     except PathAccessError:         if default is _UNSET:             raise         return default     return cur\n2: def root_mean_square_error(original: np.ndarray, reference: np.ndarray) -> float:     return float(np.sqrt(((original - reference) ** 2).mean()))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef norm_squared(vector: ndarray) -> float:\n    return np.dot(vector, vector)", "output": "Return the squared second norm of vector"}
{"task": "search", "input": "search code:\nGenerate all valid combinations of parentheses (Iterative Approach).\n\nChoices:\n0: def generate_parentheses_iterative(length: int) -> list:     result = []     stack = []      # Each element in stack is a tuple (current_combination, open_count, close_count)     stack.append((\"\", 0, 0))      while stack:         current_combination, open_count, close_count = stack.pop()          if len(current_combination) == 2 * length:             result.append(current_combination)          if open_count < length:             stack.append((current_combination + \"(\", open_count + 1, close_count))          if close_count < open_count:             stack.append((current_combination + \")\", open_count, close_count + 1))      return result\n1: def sum_32(a: int, b: int) -> int:     return (a + b) % 2**32\n2: def multiply_matrix_vector(     graph: list[list[int | None]], vector: np.ndarray ) -> np.ndarray:     num_nodes: int = len(graph)     if vector.shape[0] != num_nodes:         raise ValueError(\"Vector length must match the number of nodes in the graph.\")      result: np.ndarray = np.zeros(num_nodes)     for node_index, neighbors in enumerate(graph):         for neighbor_index in neighbors:             result[node_index] += vector[neighbor_index]     return result", "output": "0"}
{"task": "detection", "input": "classify code:\ndef luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef pheromone_update(\n    pheromone: list[list[float]],\n    cities: dict[int, list[int]],\n    pheromone_evaporation: float,\n    ants_route: list[list[int]],\n    q: float,  # Pheromone system parameters Q, which is a constant\n    best_path: list[int],\n    best_distance: float,\n) -> tuple[list[list[float]], list[int], float]:\n    for a in range(len(cities)):  # Update the volatilization of pheromone on all routes\n        for b in range(len(cities)):\n            pheromone[a][b] *= pheromone_evaporation\n    for ant_route in ants_route:\n        total_distance = 0.0\n        for i in range(len(ant_route) - 1):  # Calculate total distance\n            total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])\n        delta_pheromone = q / total_distance\n        for i in range(len(ant_route) - 1):  # Update pheromones\n            pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone\n            pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][\n                ant_route[i + 1]\n            ]\n\n        if total_distance < best_distance:\n            best_path = ant_route\n            best_distance = total_distance\n\n    return pheromone, best_path, best_distance", "output": "Update pheromones on the route and update the best route"}
{"task": "search", "input": "search code:\nCalculate the volume of the union of two spheres that possibly intersect.\n\nChoices:\n0: def some(seq):     for e in seq:         if e:             return e     return False\n1: def get_nodes(frequency_table):     nodes = {}     for _, item in enumerate(frequency_table):         nodes.setdefault(item[2], []).append(item[0])     return nodes\n2: def vol_spheres_union(     radius_1: float, radius_2: float, centers_distance: float ) -> float:      if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:         raise ValueError(             \"vol_spheres_union() only accepts non-negative values, non-zero radius\"         )      if centers_distance == 0:         return vol_sphere(max(radius_1, radius_2))      return (         vol_sphere(radius_1)         + vol_sphere(radius_2)         - vol_spheres_intersect(radius_1, radius_2, centers_distance)     )", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]", "output": "Implements the Damerau-Levenshtein distance algorithm that measures"}
{"task": "summary", "input": "summarize code:\ndef adler32(plain_text: str) -> int:\n    a = 1\n    b = 0\n    for plain_chr in plain_text:\n        a = (a + ord(plain_chr)) % MOD_ADLER\n        b = (b + a) % MOD_ADLER\n    return (b << 16) | a", "output": "Function implements adler-32 hash."}
{"task": "summary", "input": "summarize code:\ndef sum_digit_factorials(n: int) -> int:\n    if n in CACHE_SUM_DIGIT_FACTORIALS:\n        return CACHE_SUM_DIGIT_FACTORIALS[n]\n    ret = sum(DIGIT_FACTORIALS[let] for let in str(n))\n    CACHE_SUM_DIGIT_FACTORIALS[n] = ret\n    return ret", "output": "Return the sum of the factorial of the digits of n."}
{"task": "summary", "input": "summarize code:\ndef _is_scalar(value, stringlike=(str, bytes)):\n    \"Scalars are bytes, strings, and non-iterables.\"\n    try:\n        iter(value)\n    except TypeError:\n        return True\n    return isinstance(value, stringlike)", "output": "Scalars are bytes, strings, and non-iterables."}
{"task": "search", "input": "search code:\nA pure implementation of patience sort algorithm in Python\n\nChoices:\n0: def windowed_iter(src, size, fill=_UNSET):     tees = itertools.tee(src, size)     if fill is _UNSET:         try:             for i, t in enumerate(tees):                 for _ in range(i):                     next(t)         except StopIteration:             return zip([])         return zip(*tees)      for i, t in enumerate(tees):         for _ in range(i):             try:                 next(t)             except StopIteration:                 continue     return zip_longest(*tees, fillvalue=fill)\n1: def patience_sort(collection: list) -> list:     stacks: list[Stack] = []     # sort into stacks     for element in collection:         new_stacks = Stack([element])         i = bisect_left(stacks, new_stacks)         if i != len(stacks):             stacks[i].append(element)         else:             stacks.append(new_stacks)      # use a heap-based merge to merge stack efficiently     collection[:] = merge(*(reversed(stack) for stack in stacks))     return collection\n2: def emitter_converter(size_par, data):     if size_par + len(data) <= 2**size_par - (len(data) - 1):         raise ValueError(\"size of parity don't match with size of data\")      data_out = []     parity = []     bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]      # sorted information data for the size of the output data     data_ord = []     # data position template + parity     data_out_gab = []     # parity bit counter     qtd_bp = 0     # counter position of data bits     cont_data = 0      for x in range(1, size_par + len(data) + 1):         # Performs a template of bit positions - who should be given,         # and who should be parity         if qtd_bp < size_par:             if (np.log(x) / np.log(2)).is_integer():                 data_out_gab.append(\"P\")                 qtd_bp = qtd_bp + 1             else:                 data_out_gab.append(\"D\")         else:             data_out_gab.append(\"D\")          # Sorts the data to the new output size         if data_out_gab[-1] == \"D\":             data_ord.append(data[cont_data])             cont_data += 1         else:             data_ord.append(None)      # Calculates parity     qtd_bp = 0  # parity bit counter     for bp in range(1, size_par + 1):         # Bit counter one for a given parity         cont_bo = 0         # counter to control the loop reading         for cont_loop, x in enumerate(data_ord):             if x is not None:                 try:                     aux = (bin_pos[cont_loop])[-1 * (bp)]                 except IndexError:                     aux = \"0\"                 if aux == \"1\" and x == \"1\":                     cont_bo += 1         parity.append(cont_bo % 2)          qtd_bp += 1      # Mount the message     cont_bp = 0  # parity bit counter     for x in range(size_par + len(data)):         if data_ord[x] is None:             data_out.append(str(parity[cont_bp]))             cont_bp += 1         else:             data_out.append(data_ord[x])      return data_out", "output": "1"}
{"task": "detection", "input": "classify code:\ndef exchange_sort(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Uses exchange sort to sort a list of numbers.\n    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    >>> exchange_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([-1, -2, -3])\n    [-3, -2, -1]\n    >>> exchange_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([0, 10, -2, 5, 3])\n    [-2, 0, 3, 5, 10]\n    >>> exchange_sort([])\n    []\n    \"\"\"\n    numbers_length = len(numbers)\n    for i in range(numbers_length):\n        for j in range(i + 1, numbers_length):\n            if numbers[j] < numbers[i]:\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n    return numbers", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFunction updates the largest_square_area[0], if recursive call found\n\nChoices:\n0: def color(graph: list[list[int]], max_colors: int) -> list[int]:     colored_vertices = [-1] * len(graph)      if util_color(graph, max_colors, colored_vertices, 0):         return colored_vertices      return []\n1: def largest_square_area_in_matrix_top_down_approch(     rows: int, cols: int, mat: list[list[int]] ) -> int:      def update_area_of_max_square(row: int, col: int) -> int:         # BASE CASE         if row >= rows or col >= cols:             return 0          right = update_area_of_max_square(row, col + 1)         diagonal = update_area_of_max_square(row + 1, col + 1)         down = update_area_of_max_square(row + 1, col)          if mat[row][col]:             sub_problem_sol = 1 + min([right, diagonal, down])             largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)             return sub_problem_sol         else:             return 0      largest_square_area = [0]     update_area_of_max_square(0, 0)     return largest_square_area[0]\n2: def decrypt_message(     message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5 ) -> str:     message, alphabet, character_to_number, number_to_character = __prepare(         message, alphabet     )      decrypted_numeric = []     for i in range(0, len(message), period):         a, b, c = __decrypt_part(message[i : i + period], character_to_number)          for j in range(len(a)):             decrypted_numeric.append(a[j] + b[j] + c[j])      return \"\".join(number_to_character[each] for each in decrypted_numeric)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef pigeon_sort(array):\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:\n    arr = np.array(arr)\n    if arr.shape[0] != arr.shape[1]:\n        raise ValueError(\"The input array is not a square matrix\")\n    i = 0\n    j = 0\n    mat_i = 0\n    mat_j = 0\n\n    # compute the shape of the output matrix\n    avgpool_shape = (arr.shape[0] - size) // stride + 1\n    # initialize the output matrix with zeros of shape avgpool_shape\n    updated_arr = np.zeros((avgpool_shape, avgpool_shape))\n\n    while i < arr.shape[0]:\n        # if the end of the matrix is reached, break\n        if i + size > arr.shape[0]:\n            break\n        while j < arr.shape[1]:\n            # if the end of the matrix is reached, break\n            if j + size > arr.shape[1]:\n                break\n            # compute the average of the pooling matrix\n            updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))\n            # shift the pooling matrix by stride of column pixels\n            j += stride\n            mat_j += 1\n\n        # shift the pooling matrix by stride of row pixels\n        i += stride\n        mat_i += 1\n        # reset the column index to 0\n        j = 0\n        mat_j = 0\n\n    return updated_arr", "output": "This function is used to perform avgpooling on the input array of 2D matrix(image)"}
{"task": "summary", "input": "summarize code:\ndef duplicates_everseen(iterable, key=None):\n    seen_set = set()\n    seen_list = []\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seen_set:\n                seen_set.add(k)\n            else:\n                yield element\n        except TypeError:\n            if k not in seen_list:\n                seen_list.append(k)\n            else:\n                yield element", "output": "Yield duplicate elements after their first appearance."}
{"task": "detection", "input": "classify code:\ndef backtrack(input_string: str, word_dict: set[str], start: int) -> bool:\n    \"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\n\n    # Base case: if the starting index has reached the end of the string\n    if start == len(input_string):\n        return True\n\n    # Try every possible substring from 'start' to 'end'\n    for end in range(start + 1, len(input_string) + 1):\n        if input_string[start:end] in word_dict and backtrack(\n            input_string, word_dict, end\n        ):\n            return True\n\n    return False", "output": "BUGGY"}
{"task": "search", "input": "search code:\nBreak *iterable* into sub-iterables with *n* elements each.\n\nChoices:\n0: def solution() -> int:      for a in range(300):         for b in range(a + 1, 400):             for c in range(b + 1, 500):                 if (a + b + c) == 1000 and (a**2) + (b**2) == (c**2):                     return a * b * c      return -1\n1: def windowed(src, size, fill=_UNSET):     return list(windowed_iter(src, size, fill=fill))\n2: def ichunked(iterable, n):     iterator = iter(iterable)     while True:         # Create new chunk         chunk, materialize_next = _ichunk(iterator, n)          # Check to see whether we're at the end of the source iterable         if not materialize_next():             return          yield chunk          # Fill previous chunk's cache         materialize_next(None)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef construct_format_field_str(fname, fspec, conv):\n    if fname is None:\n        return ''\n    ret = '{' + fname\n    if conv:\n        ret += '!' + conv\n    if fspec:\n        ret += ':' + fspec\n    ret += '}'\n    return ret", "output": "Constructs a format field string from the field name, spec, and"}
{"task": "repair", "input": "fix bug:\ndef equality(iterable: list) -> bool:\n    \"\"\"\n    Check the equality of ALL elements in an iterable\n    >>> equality([1, 2, 3, 4])\n    False\n    >>> equality([2, 2, 2, 2])\n    True\n    >>> equality([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    return len(set(iterable)) in (0, 1)", "output": "def equality(iterable: list) -> bool:\n    \"\"\"\n    Check the equality of ALL elements in an iterable\n    >>> equality([1, 2, 3, 4])\n    False\n    >>> equality([2, 2, 2, 2])\n    True\n    >>> equality([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    return len(set(iterable)) in (0, 1)"}
{"task": "summary", "input": "summarize code:\ndef check_direction(\n    starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int]\n) -> Direction:\n    x0, y0 = starting\n    x1, y1 = via\n    x2, y2 = target\n    via_angle = degrees(atan2(y1 - y0, x1 - x0))\n    via_angle %= 360\n    target_angle = degrees(atan2(y2 - y0, x2 - x0))\n    target_angle %= 360\n    # t-\n    #  \\ \\\n    #   \\ v\n    #    \\|\n    #     s\n    # via_angle is always lower than target_angle, if direction is left.\n    # If they are same, it means they are on a same line of convex hull.\n    if target_angle > via_angle:\n        return Direction.left\n    elif target_angle == via_angle:\n        return Direction.straight\n    else:\n        return Direction.right", "output": "Return the direction toward to the line from via to target from starting"}
{"task": "summary", "input": "summarize code:\ndef solution(length: int = 50) -> int:\n\n    different_colour_ways_number = [[0] * 3 for _ in range(length + 1)]\n\n    for row_length in range(length + 1):\n        for tile_length in range(2, 5):\n            for tile_start in range(row_length - tile_length + 1):\n                different_colour_ways_number[row_length][tile_length - 2] += (\n                    different_colour_ways_number[row_length - tile_start - tile_length][\n                        tile_length - 2\n                    ]\n                    + 1\n                )\n\n    return sum(different_colour_ways_number[length])", "output": "Returns the number of different ways can the grey tiles in a row"}
{"task": "summary", "input": "summarize code:\ndef make_linked_list(elements_list: Iterable[int]) -> LinkedList:\n    if not elements_list:\n        raise Exception(\"The Elements List is empty\")\n\n    linked_list = LinkedList()\n    linked_list.extend(elements_list)\n    return linked_list", "output": "Creates a Linked List from the elements of the given sequence"}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def integer_square_root(num: int) -> int:     if not isinstance(num, int) or num < 0:         raise ValueError(\"num must be non-negative integer\")      if num < 2:         return num      left_bound = 0     right_bound = num // 2      while left_bound <= right_bound:         mid = left_bound + (right_bound - left_bound) // 2         mid_squared = mid * mid         if mid_squared == num:             return mid          if mid_squared < num:             left_bound = mid + 1         else:             right_bound = mid - 1      return right_bound\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def naturalsize(value, binary=False, gnu=False, format=\"%.1f\"):     if gnu:         suffix = suffixes[\"gnu\"]     elif binary:         suffix = suffixes[\"binary\"]     else:         suffix = suffixes[\"decimal\"]      base = 1024 if (gnu or binary) else 1000     bytes = float(value)     abs_bytes = abs(bytes)      if abs_bytes == 1 and not gnu:         return \"%d Byte\" % bytes     elif abs_bytes < base and not gnu:         return \"%d Bytes\" % bytes     elif abs_bytes < base and gnu:         return \"%dB\" % bytes      for i, s in enumerate(suffix):         unit = base ** (i + 2)         if abs_bytes < unit and not gnu:             return (format + \" %s\") % ((base * bytes / unit), s)         elif abs_bytes < unit and gnu:             return (format + \"%s\") % ((base * bytes / unit), s)     if gnu:         return (format + \"%s\") % ((base * bytes / unit), s)     return (format + \" %s\") % ((base * bytes / unit), s)", "output": "1"}
{"task": "search", "input": "search code:\nConstructs a bottom-up dynamic programming solution for the rod-cutting problem\n\nChoices:\n0: def bottom_up_cut_rod(n: int, prices: list):     _enforce_args(n, prices)      # length(max_rev) = n + 1, to accommodate for the revenue obtainable from a rod of     # length 0.     max_rev = [float(\"-inf\") for _ in range(n + 1)]     max_rev[0] = 0      for i in range(1, n + 1):         max_revenue_i = max_rev[i]         for j in range(1, i + 1):             max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])          max_rev[i] = max_revenue_i      return max_rev[n]\n1: def main() -> None:      # unittest.main()      import doctest      doctest.testmod()      parser = argparse.ArgumentParser()     parser.add_argument(         \"-s\",         \"--string\",         dest=\"input_string\",         default=\"Hello World!! Welcome to Cryptography\",         help=\"Hash the string\",     )     parser.add_argument(         \"-f\", \"--file\", dest=\"input_file\", help=\"Hash contents of a file\"     )      args = parser.parse_args()      input_string = args.input_string      # hash input should be a bytestring     if args.input_file:         with open(args.input_file, \"rb\") as f:             hash_input = f.read()     else:         hash_input = bytes(input_string, \"utf-8\")      print(SHA256(hash_input).hash)\n2: def sin(     angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10 ) -> float:     # Simplify the angle to be between 360 and -360 degrees.     angle_in_degrees = angle_in_degrees - ((angle_in_degrees // 360.0) * 360.0)      # Converting from degrees to radians     angle_in_radians = radians(angle_in_degrees)      result = angle_in_radians     a = 3     b = -1      for _ in range(accuracy):         result += (b * (angle_in_radians**a)) / factorial(a)          b = -b  # One positive term and the next will be negative and so on...         a += 2  # Increased by 2 for every term.      return round(result, rounded_values_count)", "output": "0"}
{"task": "search", "input": "search code:\nUsage examples:\n\nChoices:\n0: def sliding_window(iterable, n):     if n > 20:         return _sliding_window_deque(iterable, n)     elif n > 2:         return _sliding_window_islice(iterable, n)     elif n == 2:         return pairwise(iterable)     elif n == 1:         return zip(iterable)     else:         raise ValueError(f'n should be at least one, not {n}')\n1: def astable_frequency(     resistance_1: float, resistance_2: float, capacitance: float ) -> float:      if resistance_1 <= 0 or resistance_2 <= 0 or capacitance <= 0:         raise ValueError(\"All values must be positive\")     return (1.44 / ((resistance_1 + 2 * resistance_2) * capacitance)) * 10**6\n2: def length_conversion(value: float, from_type: str, to_type: str) -> float:     new_from = from_type.lower().rstrip(\"s\")     new_from = TYPE_CONVERSION.get(new_from, new_from)     new_to = to_type.lower().rstrip(\"s\")     new_to = TYPE_CONVERSION.get(new_to, new_to)     if new_from not in METRIC_CONVERSION:         msg = (             f\"Invalid 'from_type' value: {from_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     if new_to not in METRIC_CONVERSION:         msg = (             f\"Invalid 'to_type' value: {to_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     return (         value         * METRIC_CONVERSION[new_from].from_factor         * METRIC_CONVERSION[new_to].to_factor     )", "output": "1"}
{"task": "detection", "input": "classify code:\ndef xor(a, b):\n    \"\"\"\n    >>> xor(\"01010101\", \"00001111\")\n    '01011010'\n    \"\"\"\n    res = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            res += \"0\"\n        else:\n            res += \"1\"\n    return res", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPrivate helper function to implement the summation\n\nChoices:\n0: def gunzip_bytes(bytestring):     return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)\n1: def _subsum(     digit_pos_to_extract: int, denominator_addend: int, precision: int ) -> float:     # only care about first digit of fractional part; don't need decimal     total = 0.0     for sum_index in range(digit_pos_to_extract + precision):         denominator = 8 * sum_index + denominator_addend         if sum_index < digit_pos_to_extract:             # if the exponential term is an integer and we mod it by the denominator             # before dividing, only the integer part of the sum will change;             # the fractional part will not             exponential_term = pow(                 16, digit_pos_to_extract - 1 - sum_index, denominator             )         else:             exponential_term = pow(16, digit_pos_to_extract - 1 - sum_index)         total += exponential_term / denominator     return total\n2: def word_break(string: str, words: list[str]) -> bool:      # Validation     if not isinstance(string, str) or len(string) == 0:         raise ValueError(\"the string should be not empty string\")      if not isinstance(words, list) or not all(         isinstance(item, str) and len(item) > 0 for item in words     ):         raise ValueError(\"the words should be a list of non-empty strings\")      # Build trie     trie: dict[str, Any] = {}     word_keeper_key = \"WORD_KEEPER\"      for word in words:         trie_node = trie         for c in word:             if c not in trie_node:                 trie_node[c] = {}              trie_node = trie_node[c]          trie_node[word_keeper_key] = True      len_string = len(string)      # Dynamic programming method     @functools.cache     def is_breakable(index: int) -> bool:         if index == len_string:             return True          trie_node: Any = trie         for i in range(index, len_string):             trie_node = trie_node.get(string[i], None)              if trie_node is None:                 return False              if trie_node.get(word_keeper_key, False) and is_breakable(i + 1):                 return True          return False      return is_breakable(0)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)", "output": "def tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)"}
{"task": "summary", "input": "summarize code:\ndef calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain", "output": "Function description is as follows-"}
{"task": "summary", "input": "summarize code:\ndef arithmetic_right_shift(number: int, shift_amount: int) -> str:\n    if number >= 0:  # Get binary representation of positive number\n        binary_number = \"0\" + str(bin(number)).strip(\"-\")[2:]\n    else:  # Get binary (2's complement) representation of negative number\n        binary_number_length = len(bin(number)[3:])  # Find 2's complement of number\n        binary_number = bin(abs(number) - (1 << binary_number_length))[3:]\n        binary_number = (\n            \"1\" + \"0\" * (binary_number_length - len(binary_number)) + binary_number\n        )\n\n    if shift_amount >= len(binary_number):\n        return \"0b\" + binary_number[0] * len(binary_number)\n    return (\n        \"0b\"\n        + binary_number[0] * shift_amount\n        + binary_number[: len(binary_number) - shift_amount]\n    )", "output": "Take in 2 integers."}
{"task": "detection", "input": "classify code:\ndef three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 15) -> int:\n    total = 0\n    for m in range(2, n + 1):\n        x1 = 2 / (m + 1)\n        p = 1.0\n        for i in range(1, m + 1):\n            xi = i * x1\n            p *= xi**i\n        total += int(p)\n    return total", "output": "Calculate sum of |_ P_m _| for m from 2 to n."}
{"task": "detection", "input": "classify code:\ndef validate(*values: float) -> bool:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> validate(2.016, 4.002)\n    True\n    >>> validate(-2.016, 4.002)\n    False\n    >>> validate()\n    False\n    \"\"\"\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn an iterator over the results of ``func(start)``,\n\nChoices:\n0: def root_mean_square_error(original: np.ndarray, reference: np.ndarray) -> float:     return float(np.sqrt(((original - reference) ** 2).mean()))\n1: def tabulate(function, start=0):     return map(function, count(start))\n2: def get_initial_centroids(data, k, seed=None):     # useful for obtaining consistent results     rng = np.random.default_rng(seed)     n = data.shape[0]  # number of data points      # Pick K indices from range [0, N).     rand_indices = rng.integers(0, n, k)      # Keep centroids as dense format, as many entries will be nonzero due to averaging.     # As long as at least one document in a cluster contains a word,     # it will carry a nonzero weight in the TF-IDF vector of the centroid.     centroids = data[rand_indices, :]      return centroids", "output": "1"}
{"task": "search", "input": "search code:\nA pure Python implementation of a recursive linear search algorithm\n\nChoices:\n0: def format_histogram_counts(bin_counts, width=None, format_bin=None):     lines = []     if not format_bin:         format_bin = lambda v: v     if not width:         try:             import shutil  # python 3 convenience             width = shutil.get_terminal_size()[0]         except Exception:             width = 80      bins = [b for b, _ in bin_counts]     count_max = max([count for _, count in bin_counts])     count_cols = len(str(count_max))      labels = ['%s' % format_bin(b) for b in bins]     label_cols = max([len(l) for l in labels])     tmp_line = '{}: {} #'.format('x' * label_cols, count_max)      bar_cols = max(width - len(tmp_line), 3)     line_k = float(bar_cols) / count_max     tmpl = \"{label:>{label_cols}}: {count:>{count_cols}} {bar}\"     for label, (bin_val, count) in zip(labels, bin_counts):         bar_len = int(round(count * line_k))         bar = ('#' * bar_len) or '|'         line = tmpl.format(label=label,                            label_cols=label_cols,                            count=count,                            count_cols=count_cols,                            bar=bar)         lines.append(line)      return '\\n'.join(lines)\n1: def rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:     if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):         raise Exception(\"Invalid upper or lower bound!\")     if high < low:         return -1     if sequence[low] == target:         return low     if sequence[high] == target:         return high     return rec_linear_search(sequence, low + 1, high - 1, target)\n2: def solution(ratio: float = 0.1) -> int:      j = 3     primes = 3      while primes / (2 * j - 1) >= ratio:         for i in range(j * j + j + 1, (j + 2) * (j + 2), j + 1):             primes += is_prime(i)         j += 2     return j", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef fibonacci_digits_index(n: int) -> int:\n    digits = 0\n    index = 2\n\n    while digits < n:\n        index += 1\n        digits = len(str(fibonacci(index)))\n\n    return index", "output": "Computes incrementing Fibonacci numbers starting from 3 until the length"}
{"task": "summary", "input": "summarize code:\ndef apriori(data: list[list[str]], min_support: int) -> list[tuple[list[str], int]]:\n    itemset = [list(transaction) for transaction in data]\n    frequent_itemsets = []\n    length = 1\n\n    while itemset:\n        # Count itemset support\n        counts = [0] * len(itemset)\n        for transaction in data:\n            for j, candidate in enumerate(itemset):\n                if all(item in transaction for item in candidate):\n                    counts[j] += 1\n\n        # Prune infrequent itemsets\n        itemset = [item for i, item in enumerate(itemset) if counts[i] >= min_support]\n\n        # Append frequent itemsets (as a list to maintain order)\n        for i, item in enumerate(itemset):\n            frequent_itemsets.append((sorted(item), counts[i]))\n\n        length += 1\n        itemset = prune(itemset, list(combinations(itemset, length)), length)\n\n    return frequent_itemsets", "output": "Returns a list of frequent itemsets and their support counts."}
{"task": "search", "input": "search code:\nCalculates force from `mass` and `acceleration`\n\nChoices:\n0: def newtons_second_law_of_motion(mass: float, acceleration: float) -> float:     force = 0.0     try:         force = mass * acceleration     except Exception:         return -0.0     return force\n1: def prim(graph: list, root: Vertex) -> list:     a = []     for u in graph:         u.key = math.inf         u.pi = None     root.key = 0     q = graph[:]     while q:         u = min(q)         q.remove(u)         for v in u.neighbors:             if (v in q) and (u.edges[v.id] < v.key):                 v.pi = u                 v.key = u.edges[v.id]     for i in range(1, len(graph)):         a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))     return a\n2: def substrings_indexes(seq, reverse=False):     r = range(1, len(seq) + 1)     if reverse:         r = reversed(r)     return (         (seq[i : i + L], i, i + L) for L in r for i in range(len(seq) - L + 1)     )", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\n    \"\"\"\n    returns the list containing all the possible\n    combinations a string(`target`) can be constructed from\n    the given list of substrings(`word_bank`)\n\n    >>> all_construct(\"hello\", [\"he\", \"l\", \"o\"])\n    [['he', 'l', 'l', 'o']]\n    >>> all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"])\n    [['purp', 'le'], ['p', 'ur', 'p', 'le']]\n    \"\"\"\n\n    word_bank = word_bank or []\n    # create a table\n    table_size: int = len(target) + 1\n\n    table: list[list[list[str]]] = []\n    for _ in range(table_size):\n        table.append([])\n    # seed value\n    table[0] = [[]]  # because empty string has empty combination\n\n    # iterate through the indices\n    for i in range(table_size):\n        # condition\n        if table[i] != []:\n            for word in word_bank:\n                # slice condition\n                if target[i : i + len(word)] == word:\n                    new_combinations: list[list[str]] = [\n                        [word, *way] for way in table[i]\n                    ]\n                    # adds the word to every combination the current position holds\n                    # now,push that combination to the table[i+len(word)]\n                    table[i + len(word)] += new_combinations\n\n    # combinations are in reverse order so reverse for better output\n    for combination in table[len(target)]:\n        combination.reverse()\n\n    return table[len(target)]", "output": "def all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\n    \"\"\"\n    returns the list containing all the possible\n    combinations a string(`target`) can be constructed from\n    the given list of substrings(`word_bank`)\n\n    >>> all_construct(\"hello\", [\"he\", \"l\", \"o\"])\n    [['he', 'l', 'l', 'o']]\n    >>> all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"])\n    [['purp', 'le'], ['p', 'ur', 'p', 'le']]\n    \"\"\"\n\n    word_bank = word_bank or []\n    # create a table\n    table_size: int = len(target) + 1\n\n    table: list[list[list[str]]] = []\n    for _ in range(table_size):\n        table.append([])\n    # seed value\n    table[0] = [[]]  # because empty string has empty combination\n\n    # iterate through the indices\n    for i in range(table_size):\n        # condition\n        if table[i] != []:\n            for word in word_bank:\n                # slice condition\n                if target[i : i + len(word)] == word:\n                    new_combinations: list[list[str]] = [\n                        [word, *way] for way in table[i]\n                    ]\n                    # adds the word to every combination the current position holds\n                    # now,push that combination to the table[i+len(word)]\n                    table[i + len(word)] += new_combinations\n\n    # combinations are in reverse order so reverse for better output\n    for combination in table[len(target)]:\n        combination.reverse()\n\n    return table[len(target)]"}
{"task": "search", "input": "search code:\nReturns tuples with length *size* which represent a sliding\n\nChoices:\n0: def swap_odd_even_bits(num: int) -> int:     # Get all even bits - 0xAAAAAAAA is a 32-bit number with all even bits set to 1     even_bits = num & 0xAAAAAAAA      # Get all odd bits - 0x55555555 is a 32-bit number with all odd bits set to 1     odd_bits = num & 0x55555555      # Right shift even bits and left shift odd bits and swap them     return even_bits >> 1 | odd_bits << 1\n1: def rmse(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     square_diff = np.square(difference)     mean_square_diff = square_diff.mean()     score = np.sqrt(mean_square_diff)     return score\n2: def windowed_iter(src, size, fill=_UNSET):     tees = itertools.tee(src, size)     if fill is _UNSET:         try:             for i, t in enumerate(tees):                 for _ in range(i):                     next(t)         except StopIteration:             return zip([])         return zip(*tees)      for i, t in enumerate(tees):         for _ in range(i):             try:                 next(t)             except StopIteration:                 continue     return zip_longest(*tees, fillvalue=fill)", "output": "2"}
{"task": "search", "input": "search code:\nFunction to compute the covariance matrix between multiple classes\n\nChoices:\n0: def surface_area_conical_frustum(     radius_1: float, radius_2: float, height: float ) -> float:     if radius_1 < 0 or radius_2 < 0 or height < 0:         raise ValueError(             \"surface_area_conical_frustum() only accepts non-negative values\"         )     slant_height = (height**2 + (radius_1 - radius_2) ** 2) ** 0.5     return pi * ((slant_height * (radius_1 + radius_2)) + radius_1**2 + radius_2**2)\n1: def covariance_between_classes(     features: np.ndarray, labels: np.ndarray, classes: int ) -> np.ndarray:      general_data_mean = features.mean(1)     covariance_sum = np.nan     for i in range(classes):         data = features[:, labels == i]         device_data = data.shape[1]         data_mean = data.mean(1)         if i > 0:             # If covariance_sum is not None             covariance_sum += device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )         else:             # If covariance_sum is np.nan (i.e. first loop)             covariance_sum = device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )      return covariance_sum / features.shape[1]\n2: def map_except(function, iterable, *exceptions):     for item in iterable:         try:             yield function(item)         except exceptions:             pass", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef comp_and_swap(array: list[int], index1: int, index2: int, direction: int) -> None:\n    if (direction == 1 and array[index1] > array[index2]) or (\n        direction == 0 and array[index1] < array[index2]\n    ):\n        array[index1], array[index2] = array[index2], array[index1]", "output": "Compare the value at given index1 and index2 of the array and swap them as per"}
{"task": "search", "input": "search code:\nMake a random puzzle with N or more assignments. Restart on contradictions.\n\nChoices:\n0: def run(canvas: list[list[bool]]) -> list[list[bool]]:     current_canvas = np.array(canvas)     next_gen_canvas = np.array(create_canvas(current_canvas.shape[0]))     for r, row in enumerate(current_canvas):         for c, pt in enumerate(row):             next_gen_canvas[r][c] = __judge_point(                 pt, current_canvas[r - 1 : r + 2, c - 1 : c + 2]             )      return next_gen_canvas.tolist()\n1: def random_puzzle(assignments=17):     values = dict.fromkeys(squares, digits)     for s in shuffled(squares):         if not assign(values, s, random.choice(values[s])):             break         ds = [values[s] for s in squares if len(values[s]) == 1]         if len(ds) >= assignments and len(set(ds)) >= 8:             return \"\".join(values[s] if len(values[s]) == 1 else \".\" for s in squares)     return random_puzzle(assignments)  ## Give up and make a new puzzle\n2: def compress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         add_key_to_lexicon(lexicon, curr_string, index, last_match_id)         index += 1         curr_string = \"\"      while curr_string != \"\" and curr_string not in lexicon:         curr_string += \"0\"      if curr_string != \"\":         last_match_id = lexicon[curr_string]         result += last_match_id      return result", "output": "1"}
{"task": "search", "input": "search code:\nApply Ohm's Law, on any two given electrical values, which can be voltage, current,\n\nChoices:\n0: def ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:     if (voltage, current, resistance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance < 0:         raise ValueError(\"Resistance cannot be negative\")     if voltage == 0:         return {\"voltage\": float(current * resistance)}     elif current == 0:         return {\"current\": voltage / resistance}     elif resistance == 0:         return {\"resistance\": voltage / current}     else:         raise ValueError(\"Exactly one argument must be 0\")\n1: def encipher(message: str, cipher_map: dict[str, str]) -> str:     return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())\n2: def solution(func: Callable[[int], int] = question_function, order: int = 10) -> int:     data_points: list[int] = [func(x_val) for x_val in range(1, order + 1)]      polynomials: list[Callable[[int], int]] = [         interpolate(data_points[:max_coeff]) for max_coeff in range(1, order + 1)     ]      ret: int = 0     poly: Callable[[int], int]     x_val: int      for poly in polynomials:         x_val = 1         while func(x_val) == poly(x_val):             x_val += 1          ret += poly(x_val)      return ret", "output": "0"}
{"task": "search", "input": "search code:\nThe formatting logic behind :meth:`Stats.format_histogram`, which\n\nChoices:\n0: def solution() -> int:      for a in range(300):         for b in range(a + 1, 400):             for c in range(b + 1, 500):                 if (a + b + c) == 1000 and (a**2) + (b**2) == (c**2):                     return a * b * c      return -1\n1: def display(values):     width = 1 + max(len(values[s]) for s in squares)     line = \"+\".join([\"-\" * (width * 3)] * 3)     for r in rows:         print(             \"\".join(                 values[r + c].center(width) + (\"|\" if c in \"36\" else \"\") for c in cols             )         )         if r in \"CF\":             print(line)     print()\n2: def format_histogram_counts(bin_counts, width=None, format_bin=None):     lines = []     if not format_bin:         format_bin = lambda v: v     if not width:         try:             import shutil  # python 3 convenience             width = shutil.get_terminal_size()[0]         except Exception:             width = 80      bins = [b for b, _ in bin_counts]     count_max = max([count for _, count in bin_counts])     count_cols = len(str(count_max))      labels = ['%s' % format_bin(b) for b in bins]     label_cols = max([len(l) for l in labels])     tmp_line = '{}: {} #'.format('x' * label_cols, count_max)      bar_cols = max(width - len(tmp_line), 3)     line_k = float(bar_cols) / count_max     tmpl = \"{label:>{label_cols}}: {count:>{count_cols}} {bar}\"     for label, (bin_val, count) in zip(labels, bin_counts):         bar_len = int(round(count * line_k))         bar = ('#' * bar_len) or '|'         line = tmpl.format(label=label,                            label_cols=label_cols,                            count=count,                            count_cols=count_cols,                            bar=bar)         lines.append(line)      return '\\n'.join(lines)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef prim(graph: list, root: Vertex) -> list:\n    a = []\n    for u in graph:\n        u.key = math.inf\n        u.pi = None\n    root.key = 0\n    q = graph[:]\n    while q:\n        u = min(q)\n        q.remove(u)\n        for v in u.neighbors:\n            if (v in q) and (u.edges[v.id] < v.key):\n                v.pi = u\n                v.key = u.edges[v.id]\n    for i in range(1, len(graph)):\n        a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))\n    return a", "output": "Prim's Algorithm."}
{"task": "detection", "input": "classify code:\ndef generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn a sorted array.\n\nChoices:\n0: def exactly_n(iterable, n, predicate=bool):     iterator = filter(predicate, iterable)     if n <= 0:         if n < 0:             return False         for _ in iterator:             return False         return True      iterator = islice(iterator, n - 1, None)     for _ in iterator:         for _ in iterator:             return False         return True     return False\n1: def stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):     children = tee(iterable, len(offsets))      return zip_offset(         *children, offsets=offsets, longest=longest, fillvalue=fillvalue     )\n2: def merge(arr: list[int]) -> list[int]:     if len(arr) > 1:         middle_length = len(arr) // 2  # Finds the middle of the array         left_array = arr[             :middle_length         ]  # Creates an array of the elements in the first half.         right_array = arr[             middle_length:         ]  # Creates an array of the elements in the second half.         left_size = len(left_array)         right_size = len(right_array)         merge(left_array)  # Starts sorting the left.         merge(right_array)  # Starts sorting the right         left_index = 0  # Left Counter         right_index = 0  # Right Counter         index = 0  # Position Counter         while (             left_index < left_size and right_index < right_size         ):  # Runs until the lowers size of the left and right are sorted.             if left_array[left_index] < right_array[right_index]:                 arr[index] = left_array[left_index]                 left_index += 1             else:                 arr[index] = right_array[right_index]                 right_index += 1             index += 1         while (             left_index < left_size         ):  # Adds the left over elements in the left half of the array             arr[index] = left_array[left_index]             left_index += 1             index += 1         while (             right_index < right_size         ):  # Adds the left over elements in the right half of the array             arr[index] = right_array[right_index]             right_index += 1             index += 1     return arr", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26", "output": "A Pangram String contains all the alphabets at least once."}
{"task": "summary", "input": "summarize code:\ndef compute_transform_tables(\n    source_string: str,\n    destination_string: str,\n    copy_cost: int,\n    replace_cost: int,\n    delete_cost: int,\n    insert_cost: int,\n) -> tuple[list[list[int]], list[list[str]]]:\n    source_seq = list(source_string)\n    destination_seq = list(destination_string)\n    len_source_seq = len(source_seq)\n    len_destination_seq = len(destination_seq)\n    costs = [\n        [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n    ops = [\n        [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n\n    for i in range(1, len_source_seq + 1):\n        costs[i][0] = i * delete_cost\n        ops[i][0] = f\"D{source_seq[i - 1]}\"\n\n    for i in range(1, len_destination_seq + 1):\n        costs[0][i] = i * insert_cost\n        ops[0][i] = f\"I{destination_seq[i - 1]}\"\n\n    for i in range(1, len_source_seq + 1):\n        for j in range(1, len_destination_seq + 1):\n            if source_seq[i - 1] == destination_seq[j - 1]:\n                costs[i][j] = costs[i - 1][j - 1] + copy_cost\n                ops[i][j] = f\"C{source_seq[i - 1]}\"\n            else:\n                costs[i][j] = costs[i - 1][j - 1] + replace_cost\n                ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])\n\n            if costs[i - 1][j] + delete_cost < costs[i][j]:\n                costs[i][j] = costs[i - 1][j] + delete_cost\n                ops[i][j] = f\"D{source_seq[i - 1]}\"\n\n            if costs[i][j - 1] + insert_cost < costs[i][j]:\n                costs[i][j] = costs[i][j - 1] + insert_cost\n                ops[i][j] = f\"I{destination_seq[j - 1]}\"\n\n    return costs, ops", "output": "Finds the most cost efficient sequence"}
{"task": "search", "input": "search code:\nCalculates the first n (0-indexed) Fibonacci numbers using iteration\n\nChoices:\n0: def max_subarray_sum(     arr: Sequence[float], allow_empty_subarrays: bool = False ) -> float:     if not arr:         return 0      max_sum = 0 if allow_empty_subarrays else float(\"-inf\")     curr_sum = 0.0     for num in arr:         curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)         max_sum = max(max_sum, curr_sum)      return max_sum\n1: def fib_iterative(n: int) -> list[int]:     if n < 0:         raise ValueError(\"n is negative\")     if n == 0:         return [0]     fib = [0, 1]     for _ in range(n - 1):         fib.append(fib[-1] + fib[-2])     return fib\n2: def breadth_first_search(graph: dict, start: str) -> list[str]:     explored = {start}     result = [start]     queue: Queue = Queue()     queue.put(start)     while not queue.empty():         v = queue.get()         for w in graph[v]:             if w not in explored:                 explored.add(w)                 result.append(w)                 queue.put(w)     return result", "output": "1"}
{"task": "detection", "input": "classify code:\ndef increment_score(count: int) -> int:\n    \"\"\"\n    Calculates the score for a move based on the number of elements removed.\n\n    >>> increment_score(3)\n    6\n    >>> increment_score(0)\n    0\n    \"\"\"\n    return int(count * (count + 1) / 2)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef get_data(source_data: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])\n    [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]\n    \"\"\"\n    data_lists: list[list[float]] = []\n    for data in source_data:\n        for i, el in enumerate(data):\n            if len(data_lists) < i + 1:\n                data_lists.append([])\n            data_lists[i].append(float(el))\n    return data_lists", "output": "BUGGY"}
{"task": "search", "input": "search code:\nParse a file into a list of strings, separated by sep.\n\nChoices:\n0: def from_file(filename, sep=\"\\n\"):     \"Parse a file into a list of strings, separated by sep.\"     with open(filename) as file:         return file.read().strip().split(sep)\n1: def main():      array = [30, 35, 15, 5, 10, 20, 25]     n = len(array)      matrix, optimal_solution = matrix_chain_order(array)      print(\"No. of Operation required: \" + str(matrix[1][n - 1]))     print_optimal_solution(optimal_solution, 1, n - 1)\n2: def harmonic_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 0     for val in series:         answer += 1 / val     return len(series) / answer", "output": "0"}
{"task": "search", "input": "search code:\nReturns the string concatenated with the delimiter we provide.\n\nChoices:\n0: def lexical_order(max_number: int) -> Iterator[int]:      stack = [1]      while stack:         num = stack.pop()         if num > max_number:             continue          yield num         if (num % 10) != 9:             stack.append(num + 1)          stack.append(num * 10)\n1: def to_complex_case(text: str, upper: bool, separator: str) -> str:     try:         string_split = split_input(text)         if upper:             res_str = \"\".join(                 [                     separator.join([char.upper() for char in sub_str])                     for sub_str in string_split                 ]             )         else:             res_str = \"\".join(                 [                     separator.join([char.lower() for char in sub_str])                     for sub_str in string_split                 ]             )         return res_str     except IndexError:         return \"not valid string\"\n2: def decimal_to_ipv4(decimal_ipv4: int) -> str:      if not (0 <= decimal_ipv4 <= 4294967295):         raise ValueError(\"Invalid decimal IPv4 address\")      ip_parts = []     for _ in range(4):         ip_parts.append(str(decimal_ipv4 & 255))         decimal_ipv4 >>= 8      return \".\".join(reversed(ip_parts))", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef prefix_function(input_string: str) -> list:\n    \"\"\"\n    For the given string this function computes value for each index(i),\n    which represents the longest coincidence of prefix and suffix\n    for given substring (input_str[0...i])\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> prefix_function(\"aabcdaabc\")\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\n    >>> prefix_function(\"asdasdad\")\n    [0, 0, 0, 1, 2, 3, 4, 0]\n    \"\"\"\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result", "output": "def prefix_function(input_string: str) -> list:\n    \"\"\"\n    For the given string this function computes value for each index(i),\n    which represents the longest coincidence of prefix and suffix\n    for given substring (input_str[0...i])\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> prefix_function(\"aabcdaabc\")\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\n    >>> prefix_function(\"asdasdad\")\n    [0, 0, 0, 1, 2, 3, 4, 0]\n    \"\"\"\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result"}
{"task": "detection", "input": "classify code:\ndef move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:\n    \"\"\"\n    Shifts all columns leftward when an entire column becomes empty.\n\n    >>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2)\n    [['A', '-'], ['-', '-'], ['-', 'C']]\n    \"\"\"\n\n    empty_columns = []\n\n    for column in range(size - 1, -1, -1):\n        if all(matrix_g[row][column] == \"-\" for row in range(size)):\n            empty_columns.append(column)\n\n    for column in empty_columns:\n        for col in range(column + 1, size):\n            for row in range(size):\n                matrix_g[row][col - 1] = matrix_g[row][col]\n        for row in range(size):\n            matrix_g[row][-1] = \"-\"\n\n    return matrix_g", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)"}
{"task": "repair", "input": "fix bug:\ndef coulombs_law(q1: float, q2: float, radius: float) -> float:\n    \"\"\"\n    Calculate the electrostatic force of attraction or repulsion\n    between two point charges\n\n    >>> coulombs_law(15.5, 20, 15)\n    12382849136.06\n    >>> coulombs_law(1, 15, 5)\n    5392531075.38\n    >>> coulombs_law(20, -50, 15)\n    -39944674632.44\n    >>> coulombs_law(-5, -8, 10)\n    3595020716.92\n    >>> coulombs_law(50, 100, 50)\n    17975103584.6\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)", "output": "def coulombs_law(q1: float, q2: float, radius: float) -> float:\n    \"\"\"\n    Calculate the electrostatic force of attraction or repulsion\n    between two point charges\n\n    >>> coulombs_law(15.5, 20, 15)\n    12382849136.06\n    >>> coulombs_law(1, 15, 5)\n    5392531075.38\n    >>> coulombs_law(20, -50, 15)\n    -39944674632.44\n    >>> coulombs_law(-5, -8, 10)\n    3595020716.92\n    >>> coulombs_law(50, 100, 50)\n    17975103584.6\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)"}
{"task": "repair", "input": "fix bug:\ndef largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We aren't using dp_array here, so the time complexity would be exponential.\n\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]", "output": "def largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We aren't using dp_array here, so the time complexity would be exponential.\n\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]"}
{"task": "summary", "input": "summarize code:\ndef decimal_to_negative_base_2(num: int) -> int:\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)", "output": "This function returns the number negative base 2"}
{"task": "search", "input": "search code:\nRetrieve a value from a nested object via a tuple representing the\n\nChoices:\n0: def zigzag(root: Node | None) -> Generator[int]:     if root is None:         return      flag = 0     height_tree = height(root)      for h in range(1, height_tree + 1):         if not flag:             yield from get_nodes_from_left_to_right(root, h)             flag = 1         else:             yield from get_nodes_from_right_to_left(root, h)             flag = 0\n1: def insert_node(head: Node | None, data: int) -> Node:     new_node = Node(data)     # If the linked list is empty, the new_node becomes the head     if head is None:         return new_node      temp_node = head     while temp_node.next_node:         temp_node = temp_node.next_node      temp_node.next_node = new_node     return head\n2: def get_path(root, path, default=_UNSET):     if isinstance(path, str):         path = path.split('.')     cur = root     try:         for seg in path:             try:                 cur = cur[seg]             except (KeyError, IndexError) as exc:                 raise PathAccessError(exc, seg, path)             except TypeError as exc:                 # either string index in a list, or a parent that                 # doesn't support indexing                 try:                     seg = int(seg)                     cur = cur[seg]                 except (ValueError, KeyError, IndexError, TypeError):                     if not is_iterable(cur):                         exc = TypeError('%r object is not indexable'                                         % type(cur).__name__)                     raise PathAccessError(exc, seg, path)     except PathAccessError:         if default is _UNSET:             raise         return default     return cur", "output": "2"}
{"task": "detection", "input": "classify code:\ndef largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn a sliding window of width *n* over *iterable*.\n\nChoices:\n0: def is_prime(number: int) -> bool:      return all(number % divisor != 0 for divisor in range(2, isqrt(number) + 1))\n1: def sliding_window(iterable, n):     if n > 20:         return _sliding_window_deque(iterable, n)     elif n > 2:         return _sliding_window_islice(iterable, n)     elif n == 2:         return pairwise(iterable)     elif n == 1:         return zip(iterable)     else:         raise ValueError(f'n should be at least one, not {n}')\n2: def solution(n: int = 10000) -> int:     count_odd_periods = 0     for i in range(2, n + 1):         sr = sqrt(i)         if sr - floor(sr) != 0 and continuous_fraction_period(i) % 2 == 1:             count_odd_periods += 1     return count_odd_periods", "output": "1"}
{"task": "search", "input": "search code:\nReturns least value of n\n\nChoices:\n0: def matrix_pow_np(m: ndarray, power: int) -> ndarray:     result = np.array([[1, 0], [0, 1]], dtype=int)  # Identity Matrix     base = m     if power < 0:  # Negative power is not allowed         raise ValueError(\"power is negative\")     while power:         if power % 2 == 1:             result = np.dot(result, base)         base = np.dot(base, base)         power //= 2     return result\n1: def kmeans(     data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False ):     centroids = initial_centroids[:]     prev_cluster_assignment = None      for itr in range(maxiter):         if verbose:             print(itr, end=\"\")          # 1. Make cluster assignments using nearest centroids         cluster_assignment = assign_clusters(data, centroids)          # 2. Compute a new centroid for each of the k clusters, averaging all data         #    points assigned to that cluster.         centroids = revise_centroids(data, k, cluster_assignment)          # Check for convergence: if none of the assignments changed, stop         if (             prev_cluster_assignment is not None             and (prev_cluster_assignment == cluster_assignment).all()         ):             break          # Print number of new assignments         if prev_cluster_assignment is not None:             num_changed = np.sum(prev_cluster_assignment != cluster_assignment)             if verbose:                 print(                     f\"    {num_changed:5d} elements changed their cluster assignment.\"                 )          # Record heterogeneity convergence metric         if record_heterogeneity is not None:             # YOUR CODE HERE             score = compute_heterogeneity(data, k, centroids, cluster_assignment)             record_heterogeneity.append(score)          prev_cluster_assignment = cluster_assignment[:]      return centroids, cluster_assignment\n2: def solution(fraction: float = 1 / 1000) -> int:      l_section_area = (1 - pi / 4) / 4      for n in count(1):         if concave_triangle_area(n) / l_section_area < fraction:             return n      return -1", "output": "2"}
{"task": "search", "input": "search code:\nCalculate the variance\n\nChoices:\n0: def is_safe(board: list[list[int]], row: int, column: int) -> bool:      n = len(board)  # Size of the board      # Check if there is any queen in the same upper column,     # left upper diagonal and right upper diagonal     return (         all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))         )         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))         )     )\n1: def calculate_variance(items: list, means: list, total_count: int) -> float:     squared_diff = []  # An empty list to store all squared differences     # iterate over number of elements in items     for i in range(len(items)):         # for loop iterates over number of elements in inner layer of items         for j in range(len(items[i])):             # appending squared differences to 'squared_diff' list             squared_diff.append((items[i][j] - means[i]) ** 2)      # one divided by (the number of all instances - number of classes) multiplied by     # sum of all squared differences     n_classes = len(means)  # Number of classes in dataset     return 1 / (total_count - n_classes) * sum(squared_diff)\n2: def partition(pred, iterable):     if pred is None:         pred = bool      t1, t2, p = tee(iterable, 3)     p1, p2 = tee(map(pred, p))     return (compress(t1, map(not_, p1)), compress(t2, p2))", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    \"\"\"\n    The method arranges two lists as one list in alternative forms of the list elements.\n    :param first_input_list:\n    :param second_input_list:\n    :return: List\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\n    >>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\n    >>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list", "output": "def alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    \"\"\"\n    The method arranges two lists as one list in alternative forms of the list elements.\n    :param first_input_list:\n    :param second_input_list:\n    :return: List\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\n    >>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\n    >>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list"}
{"task": "summary", "input": "summarize code:\ndef alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list", "output": "The method arranges two lists as one list in alternative forms of the list elements."}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def perfect_square(num: int) -> bool:     return math.sqrt(num) * math.sqrt(num) == num\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def interpolation_search(sorted_collection: list[int], item: int) -> int | None:     left = 0     right = len(sorted_collection) - 1      while left <= right:         # avoid divided by 0 during interpolation         if sorted_collection[left] == sorted_collection[right]:             if sorted_collection[left] == item:                 return left             return None          point = left + ((item - sorted_collection[left]) * (right - left)) // (             sorted_collection[right] - sorted_collection[left]         )          # out of range check         if point < 0 or point >= len(sorted_collection):             return None          current_item = sorted_collection[point]         if current_item == item:             return point         if point < left:             right = left             left = point         elif point > right:             left = right             right = point         elif item < current_item:             right = point - 1         else:             left = point + 1     return None", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef power(x: int, y: int, mod: int) -> int:\n    \"\"\"\n    Examples:\n    >>> power(2, 15, 3)\n    2\n    >>> power(5, 1, 30)\n    5\n    \"\"\"\n\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, mod) % mod\n    temp = (temp * temp) % mod\n    if y % 2 == 1:\n        temp = (temp * x) % mod\n    return temp", "output": "def power(x: int, y: int, mod: int) -> int:\n    \"\"\"\n    Examples:\n    >>> power(2, 15, 3)\n    2\n    >>> power(5, 1, 30)\n    5\n    \"\"\"\n\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, mod) % mod\n    temp = (temp * temp) % mod\n    if y % 2 == 1:\n        temp = (temp * x) % mod\n    return temp"}
{"task": "search", "input": "search code:\nThis function checks the grid to see if each row,\n\nChoices:\n0: def chunked_even(iterable, n):     iterator = iter(iterable)      # Initialize a buffer to process the chunks while keeping     # some back to fill any underfilled chunks     min_buffer = (n - 1) * (n - 2)     buffer = list(islice(iterator, min_buffer))      # Append items until we have a completed chunk     for _ in islice(map(buffer.append, iterator), n, None, n):         yield buffer[:n]         del buffer[:n]      # Check if any chunks need addition processing     if not buffer:         return     length = len(buffer)      # Chunks are either size `full_size <= n` or `partial_size = full_size - 1`     q, r = divmod(length, n)     num_lists = q + (1 if r > 0 else 0)     q, r = divmod(length, num_lists)     full_size = q + (1 if r > 0 else 0)     partial_size = full_size - 1     num_full = length - partial_size * num_lists      # Yield chunks of full size     partial_start_idx = num_full * full_size     if full_size > 0:         for i in range(0, partial_start_idx, full_size):             yield buffer[i : i + full_size]      # Yield chunks of partial size     if partial_size > 0:         for i in range(partial_start_idx, length, partial_size):             yield buffer[i : i + partial_size]\n1: def is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:     for i in range(9):         if n in {grid[row][i], grid[i][column]}:             return False      for i in range(3):         for j in range(3):             if grid[(row - row % 3) + i][(column - column % 3) + j] == n:                 return False      return True\n2: def build_tree() -> TreeNode:     root = TreeNode(1)     root.left = TreeNode(2)     root.right = TreeNode(5)     root.left.left = TreeNode(3)     root.left.right = TreeNode(4)     root.right.right = TreeNode(6)     return root", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef calculate_turn_around_time(\n    process_name: list, arrival_time: list, burst_time: list, no_of_process: int\n) -> list:\n\n    current_time = 0\n    # Number of processes finished\n    finished_process_count = 0\n    # Displays the finished process.\n    # If it is 0, the performance is completed if it is 1, before the performance.\n    finished_process = [0] * no_of_process\n    # List to include calculation results\n    turn_around_time = [0] * no_of_process\n\n    # Sort by arrival time.\n    burst_time = [burst_time[i] for i in np.argsort(arrival_time)]\n    process_name = [process_name[i] for i in np.argsort(arrival_time)]\n    arrival_time.sort()\n\n    while no_of_process > finished_process_count:\n        i = 0\n        while finished_process[i] == 1:\n            i += 1\n        current_time = max(current_time, arrival_time[i])\n\n        response_ratio = 0\n        # Index showing the location of the process being performed\n        loc = 0\n        # Saves the current response ratio.\n        temp = 0\n        for i in range(no_of_process):\n            if finished_process[i] == 0 and arrival_time[i] <= current_time:\n                temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[\n                    i\n                ]\n            if response_ratio < temp:\n                response_ratio = temp\n                loc = i\n\n        # Calculate the turn around time\n        turn_around_time[loc] = current_time + burst_time[loc] - arrival_time[loc]\n        current_time += burst_time[loc]\n        # Indicates that the process has been performed.\n        finished_process[loc] = 1\n        # Increase finished_process_count by 1\n        finished_process_count += 1\n\n    return turn_around_time", "output": "Calculate the turn around time of each processes"}
{"task": "summary", "input": "summarize code:\ndef get_nodes(frequency_table):\n    nodes = {}\n    for _, item in enumerate(frequency_table):\n        nodes.setdefault(item[2], []).append(item[0])\n    return nodes", "output": "Returns nodes"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 200) -> int:\n    return two_pound(n)", "output": "Returns the number of different ways can n pence be made using any number of"}
{"task": "search", "input": "search code:\nReturns the largest prime factor of a given number n.\n\nChoices:\n0: def solution(n: int = 600851475143) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     i = 2     ans = 0     if n == 2:         return 2     while n > 2:         while n % i != 0:             i += 1         ans = i         while n % i == 0:             n = n // i         i += 1     return int(ans)\n1: def djb2(s: str) -> int:     hash_value = 5381     for x in s:         hash_value = ((hash_value << 5) + hash_value) + ord(x)     return hash_value & 0xFFFFFFFF\n2: def write_file_binary(file_path: str, to_write: str) -> None:     byte_length = 8     try:         with open(file_path, \"wb\") as opened_file:             result_byte_array = [                 to_write[i : i + byte_length]                 for i in range(0, len(to_write), byte_length)             ]              if len(result_byte_array[-1]) % byte_length == 0:                 result_byte_array.append(\"10000000\")             else:                 result_byte_array[-1] += \"1\" + \"0\" * (                     byte_length - len(result_byte_array[-1]) - 1                 )              for elem in result_byte_array:                 opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))     except OSError:         print(\"File not accessible\")         sys.exit()", "output": "0"}
{"task": "search", "input": "search code:\nCalculate sum of |_ P_m _| for m from 2 to n.\n\nChoices:\n0: def interpolation_search(sorted_collection: list[int], item: int) -> int | None:     left = 0     right = len(sorted_collection) - 1      while left <= right:         # avoid divided by 0 during interpolation         if sorted_collection[left] == sorted_collection[right]:             if sorted_collection[left] == item:                 return left             return None          point = left + ((item - sorted_collection[left]) * (right - left)) // (             sorted_collection[right] - sorted_collection[left]         )          # out of range check         if point < 0 or point >= len(sorted_collection):             return None          current_item = sorted_collection[point]         if current_item == item:             return point         if point < left:             right = left             left = point         elif point > right:             left = right             right = point         elif item < current_item:             right = point - 1         else:             left = point + 1     return None\n1: def solution(n: int = 15) -> int:     total = 0     for m in range(2, n + 1):         x1 = 2 / (m + 1)         p = 1.0         for i in range(1, m + 1):             xi = i * x1             p *= xi**i         total += int(p)     return total\n2: def save_image(image_url: str, image_title: str) -> None:     image = httpx.get(image_url, headers=headers, timeout=10)     with open(image_title, \"wb\") as file:         file.write(image.content)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef search(target: int, prime_list: list) -> bool:\n\n    left, right = 0, len(prime_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if prime_list[middle] == target:\n            return True\n        elif prime_list[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return False", "output": "function to search a number in a list using Binary Search."}
{"task": "repair", "input": "fix bug:\ndef load_data() -> list[list[str]]:\n    \"\"\"\n    Returns a sample transaction dataset.\n\n    >>> load_data()\n    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]\n    \"\"\"\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]", "output": "def load_data() -> list[list[str]]:\n    \"\"\"\n    Returns a sample transaction dataset.\n\n    >>> load_data()\n    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]\n    \"\"\"\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]"}
{"task": "search", "input": "search code:\nConverts a query string into a list of (key, value) pairs.\n\nChoices:\n0: def parse_qsl(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):     pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]     ret = []     for pair in pairs:         if not pair:             continue         key, _, value = pair.partition('=')         if not value:             if keep_blank_values:                 value = None             else:                 continue         key = unquote(key.replace('+', ' '))         if value:             value = unquote(value.replace('+', ' '))         ret.append((key, value))     return ret\n1: def imply_gate(input_1: int, input_2: int) -> int:     return int(input_1 == 0 or input_2 == 1)\n2: def solution(n: int = 10000) -> int:     total = sum(         i         for i in range(1, n)         if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i     )     return total", "output": "0"}
{"task": "detection", "input": "classify code:\ndef bisect_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:\n    return point1[0] * point2[1] - point1[1] * point2[0]", "output": "Return the 2-d vector product of two vectors."}
{"task": "detection", "input": "classify code:\ndef calc_profit(profit: list, weight: list, max_weight: int) -> Union[str, int]:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef insert(node: BinaryTreeNode | None, new_value: int) -> BinaryTreeNode | None:\n    if node is None:\n        node = BinaryTreeNode(new_value)\n        return node\n\n    # binary search tree is not empty,\n    # so we will insert it into the tree\n    # if new_value is less than value of data in node,\n    #  add it to left subtree and proceed recursively\n    if new_value < node.data:\n        node.left_child = insert(node.left_child, new_value)\n    else:\n        # if new_value is greater than value of data in node,\n        #  add it to right subtree and proceed recursively\n        node.right_child = insert(node.right_child, new_value)\n    return node", "output": "If the binary search tree is empty, make a new node and declare it as root."}
{"task": "summary", "input": "summarize code:\ndef decimal_relative_time(d, other=None, ndigits=0, cardinalize=True):\n    if other is None:\n        other = datetime.now(timezone.utc).replace(tzinfo=None)\n    diff = other - d\n    diff_seconds = timedelta.total_seconds(diff)\n    abs_diff = abs(diff)\n    b_idx = bisect.bisect(_BOUND_DELTAS, abs_diff) - 1\n    bbound, bunit, bname = _BOUNDS[b_idx]\n    f_diff = diff_seconds / timedelta.total_seconds(bunit)\n    rounded_diff = round(f_diff, ndigits)\n    if cardinalize:\n        return rounded_diff, _cardinalize_time_unit(bname, abs(rounded_diff))\n    return rounded_diff, bname", "output": "Get a tuple representing the relative time difference between two"}
{"task": "summary", "input": "summarize code:\ndef is_geometric_series(series: list) -> bool:\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    if len(series) == 1:\n        return True\n    try:\n        common_ratio = series[1] / series[0]\n        for index in range(len(series) - 1):\n            if series[index + 1] / series[index] != common_ratio:\n                return False\n    except ZeroDivisionError:\n        return False\n    return True", "output": "checking whether the input series is geometric series or not"}
{"task": "detection", "input": "classify code:\ndef knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef to_title_case(word: str) -> str:\n\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word", "output": "Converts a string to capitalized case, preserving the input as is"}
{"task": "summary", "input": "summarize code:\ndef get_avg(number_1: int, number_2: int) -> int:\n    return int((number_1 + number_2) / 2)", "output": "Return the mid-number(whole) of two integers a and b"}
{"task": "detection", "input": "classify code:\ndef is_pangram_fastest(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_fastest()\n    True\n    \"\"\"\n    return len({char for char in input_str.lower() if char.isalpha()}) == 26", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef subslices(iterable):\n    seq = list(iterable)\n    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n    return map(getitem, repeat(seq), slices)", "output": "Return all contiguous non-empty subslices of *iterable*."}
{"task": "search", "input": "search code:\nReturns True if a number is palindrome.\n\nChoices:\n0: def count_vowels(s: str) -> int:     if not isinstance(s, str):         raise ValueError(\"Input must be a string\")      vowels = \"aeiouAEIOU\"     return sum(1 for char in s if char in vowels)\n1: def is_palindrome(n: int) -> bool:     return str(n) == str(n)[::-1]\n2: def centripetal(mass: float, velocity: float, radius: float) -> float:     if mass < 0:         raise ValueError(\"The mass of the body cannot be negative\")     if radius <= 0:         raise ValueError(\"The radius is always a positive non zero integer\")     return (mass * (velocity) ** 2) / radius", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef clear_bit(number: int, position: int) -> int:\n    return number & ~(1 << position)", "output": "Set the bit at position to 0."}
{"task": "search", "input": "search code:\nCalculate the area of a triangle given the base and height.\n\nChoices:\n0: def area_triangle(base: float, height: float) -> float:     if base < 0 or height < 0:         raise ValueError(\"area_triangle() only accepts non-negative values\")     return (base * height) / 2\n1: def decode(coded: str) -> str:     if set(coded) - {\"A\", \"B\", \" \"} != set():         raise Exception(\"decode() accepts only 'A', 'B' and spaces\")     decoded = \"\"     for word in coded.split():         while len(word) != 0:             decoded += decode_dict[word[:5]]             word = word[5:]         decoded += \" \"     return decoded.strip()\n2: def solution(limit=28123):     sum_divs = [1] * (limit + 1)      for i in range(2, int(limit**0.5) + 1):         sum_divs[i * i] += i         for k in range(i + 1, limit // i + 1):             sum_divs[k * i] += k + i      abundants = set()     res = 0      for n in range(1, limit + 1):         if sum_divs[n] > n:             abundants.add(n)          if not any((n - a in abundants) for a in abundants):             res += n      return res", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef prepare_input(dirty: str) -> str:\n\n    dirty = \"\".join([c.upper() for c in dirty if c in string.ascii_letters])\n    clean = \"\"\n\n    if len(dirty) < 2:\n        return dirty\n\n    for i in range(len(dirty) - 1):\n        clean += dirty[i]\n\n        if dirty[i] == dirty[i + 1]:\n            clean += \"X\"\n\n    clean += dirty[-1]\n\n    if len(clean) & 1:\n        clean += \"X\"\n\n    return clean", "output": "Prepare the plaintext by up-casing it"}
{"task": "summary", "input": "summarize code:\ndef emails_from_url(url: str = \"https://github.com\") -> list[str]:\n    # Get the base domain from the url\n    domain = get_domain_name(url)\n\n    # Initialize the parser\n    parser = Parser(domain)\n\n    try:\n        # Open URL\n        r = httpx.get(url, timeout=10, follow_redirects=True)\n\n        # pass the raw HTML to the parser to get links\n        parser.feed(r.text)\n\n        # Get links and loop through\n        valid_emails = set()\n        for link in parser.urls:\n            # open URL.\n            # Check if the link is already absolute\n            if not link.startswith(\"http://\") and not link.startswith(\"https://\"):\n                # Prepend protocol only if link starts with domain, normalize otherwise\n                if link.startswith(domain):\n                    link = f\"https://{link}\"\n                else:\n                    link = parse.urljoin(f\"https://{domain}\", link)\n            try:\n                read = httpx.get(link, timeout=10, follow_redirects=True)\n                # Get the valid email.\n                emails = re.findall(\"[a-zA-Z0-9]+@\" + domain, read.text)\n                # If not in list then append it.\n                for email in emails:\n                    valid_emails.add(email)\n            except ValueError:\n                pass\n    except ValueError:\n        raise SystemExit(1)\n\n    # Finally return a sorted list of email addresses with no duplicates.\n    return sorted(valid_emails)", "output": "This function takes url and return all valid urls"}
{"task": "detection", "input": "classify code:\ndef make_points(a, b, h):\n    \"\"\"\n    Generates points between 'a' and 'b' with step size 'h', excluding the end points.\n    Args:\n        a (float): Start value\n        b (float): End value\n        h (float): Step size\n    Examples:\n    >>> list(make_points(0, 10, 2.5))\n    [2.5, 5.0, 7.5]\n\n    >>> list(make_points(0, 10, 2))\n    [2, 4, 6, 8]\n\n    >>> list(make_points(1, 21, 5))\n    [6, 11, 16]\n\n    >>> list(make_points(1, 5, 2))\n    [3]\n\n    >>> list(make_points(1, 4, 3))\n    []\n    \"\"\"\n    x = a + h\n    while x <= (b - h):\n        yield x\n        x = x + h", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef rotate(\n    x: float, y: float, z: float, axis: str, angle: float\n) -> tuple[float, float, float]:\n    if not isinstance(axis, str):\n        raise TypeError(\"Axis must be a str\")\n    input_variables = locals()\n    del input_variables[\"axis\"]\n    if not all(isinstance(val, (float, int)) for val in input_variables.values()):\n        msg = (\n            \"Input values except axis must either be float or int: \"\n            f\"{list(input_variables.values())}\"\n        )\n        raise TypeError(msg)\n    angle = (angle % 360) / 450 * 180 / math.pi\n    if axis == \"z\":\n        new_x = x * math.cos(angle) - y * math.sin(angle)\n        new_y = y * math.cos(angle) + x * math.sin(angle)\n        new_z = z\n    elif axis == \"x\":\n        new_y = y * math.cos(angle) - z * math.sin(angle)\n        new_z = z * math.cos(angle) + y * math.sin(angle)\n        new_x = x\n    elif axis == \"y\":\n        new_x = x * math.cos(angle) - z * math.sin(angle)\n        new_z = z * math.cos(angle) + x * math.sin(angle)\n        new_y = y\n    else:\n        raise ValueError(\"not a valid axis, choose one of 'x', 'y', 'z'\")\n\n    return new_x, new_y, new_z", "output": "rotate a point around a certain axis with a certain angle"}
{"task": "summary", "input": "summarize code:\ndef _nth_prime_bounds(n):\n    # At and above 688,383, the lb/ub spread is under 0.003 * p_n.\n\n    if n < 1:\n        raise ValueError\n\n    if n < 6:\n        return (n, 2.25 * n)\n\n    # https://en.wikipedia.org/wiki/Prime-counting_function#Inequalities\n    upper_bound = n * log(n * log(n))\n    lower_bound = upper_bound - n\n    if n >= 688_383:\n        upper_bound -= n * (1.0 - (log(log(n)) - 2.0) / log(n))\n\n    return lower_bound, upper_bound", "output": "Bounds for the nth prime (counting from 1): lb < p_n < ub."}
{"task": "detection", "input": "classify code:\ndef upper(word: str) -> str:\n    \"\"\"\n    Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII\n    letters and subtracting 32 from their integer representation to get the uppercase\n    letter.\n\n    >>> upper(\"wow\")\n    'WOW'\n    >>> upper(\"Hello\")\n    'HELLO'\n    >>> upper(\"WHAT\")\n    'WHAT'\n    >>> upper(\"wh[]32\")\n    'WH[]32'\n    \"\"\"\n    return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nYield 3-tuples of the form ``(is_first, is_last, item)``.\n\nChoices:\n0: def mark_ends(iterable):     it = iter(iterable)     for a in it:         first = True         for b in it:             yield first, False, a             a = b             first = False         yield first, True, a\n1: def fib_recursive_cached(n: int) -> list[int]:      @functools.cache     def fib_recursive_term(i: int) -> int:         if i < 0:             raise ValueError(\"n is negative\")         if i < 2:             return i         return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)      if n < 0:         raise ValueError(\"n is negative\")     return [fib_recursive_term(i) for i in range(n + 1)]\n2: def preprocess(edge_array):     for i in range(len(edge_array)):         for j in range(len(edge_array[i])):             t = edge_array[i][j].split(\"-\")             edge_array[i][j] = t", "output": "0"}
{"task": "detection", "input": "classify code:\ndef filter_common_word(possibles: List[str], common_word: str) -> List[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef set_partitions(iterable, k=None, min_size=None, max_size=None):\n    L = list(iterable)\n    n = len(L)\n    if k is not None:\n        if k < 1:\n            raise ValueError(\n                \"Can't partition in a negative or zero number of groups\"\n            )\n        elif k > n:\n            return\n\n    min_size = min_size if min_size is not None else 0\n    max_size = max_size if max_size is not None else n\n    if min_size > max_size:\n        return\n\n    def set_partitions_helper(L, k):\n        n = len(L)\n        if k == 1:\n            yield [L]\n        elif n == k:\n            yield [[s] for s in L]\n        else:\n            e, *M = L\n            for p in set_partitions_helper(M, k - 1):\n                yield [[e], *p]\n            for p in set_partitions_helper(M, k):\n                for i in range(len(p)):\n                    yield p[:i] + [[e] + p[i]] + p[i + 1 :]\n\n    if k is None:\n        for k in range(1, n + 1):\n            yield from filter(\n                lambda z: all(min_size <= len(bk) <= max_size for bk in z),\n                set_partitions_helper(L, k),\n            )\n    else:\n        yield from filter(\n            lambda z: all(min_size <= len(bk) <= max_size for bk in z),\n            set_partitions_helper(L, k),\n        )", "output": "Yield the set partitions of *iterable* into *k* parts. Set partitions are"}
{"task": "summary", "input": "summarize code:\ndef stooge_sort(arr: list[int]) -> list[int]:\n    stooge(arr, 0, len(arr) - 1)\n    return arr", "output": "Examples:"}
{"task": "summary", "input": "summarize code:\ndef decimal_to_octal(num: int) -> str:\n    octal = 0\n    counter = 0\n    while num > 0:\n        remainder = num % 8\n        octal = octal + (remainder * math.floor(math.pow(10, counter)))\n        counter += 1\n        num = math.floor(num / 8)  # basically /= 8 without remainder if any\n        # This formatting removes trailing '.0' from `octal`.\n    return f\"0o{int(octal)}\"", "output": "Convert a Decimal Number to an Octal Number."}
{"task": "detection", "input": "classify code:\ndef luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef least_divisible_repunit(divisor: int) -> int:\n    \"\"\"\n    Return the least value k such that the Repunit of length k is divisible by divisor.\n    >>> least_divisible_repunit(7)\n    6\n    >>> least_divisible_repunit(41)\n    5\n    >>> least_divisible_repunit(1234567)\n    34020\n    \"\"\"\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index", "output": "def least_divisible_repunit(divisor: int) -> int:\n    \"\"\"\n    Return the least value k such that the Repunit of length k is divisible by divisor.\n    >>> least_divisible_repunit(7)\n    6\n    >>> least_divisible_repunit(41)\n    5\n    >>> least_divisible_repunit(1234567)\n    34020\n    \"\"\"\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index"}
{"task": "search", "input": "search code:\nSplits an iterable based on a separator, *sep*, a max of\n\nChoices:\n0: def split_iter(src, sep=None, maxsplit=None):     if not is_iterable(src):         raise TypeError('expected an iterable')      if maxsplit is not None:         maxsplit = int(maxsplit)         if maxsplit == 0:             yield [src]             return      if callable(sep):         sep_func = sep     elif not is_scalar(sep):         sep = frozenset(sep)         def sep_func(x): return x in sep     else:         def sep_func(x): return x == sep      cur_group = []     split_count = 0     for s in src:         if maxsplit is not None and split_count >= maxsplit:             def sep_func(x): return False         if sep_func(s):             if sep is None and not cur_group:                 # If sep is none, str.split() \"groups\" separators                 # check the str.split() docs for more info                 continue             split_count += 1             yield cur_group             cur_group = []         else:             cur_group.append(s)      if cur_group or sep is not None:         yield cur_group     return\n1: def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:      return len_board * len_board_column * row + column\n2: def in_reverse(linked_list: LinkedList) -> str:     return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))", "output": "0"}
{"task": "detection", "input": "classify code:\ndef find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n\n    for i in range(low, high):\n        missing_number ^= i ^ nums[i - low]\n\n    return missing_number", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCalculate the number of non-bouncy numbers less than a googol.\n\nChoices:\n0: def wheatstone_solver(     resistance_1: float, resistance_2: float, resistance_3: float ) -> float:      if resistance_1 <= 0 or resistance_2 <= 0 or resistance_3 <= 0:         raise ValueError(\"All resistance values must be positive\")     else:         return float((resistance_2 / resistance_1) * resistance_3)\n1: def solution(num_digits: int = 100) -> int:     return non_bouncy_upto(num_digits)\n2: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         # print(f\"{call:38} = {func(value)} -- {timing:.4f} seconds\")         print(f\"{call:38} -- {timing:.4f} seconds\")      for value in range(15):  # (1, 7, 14):         for func in (generate_pascal_triangle, generate_pascal_triangle_optimized):             benchmark_a_function(func, value)         print()", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef convert_small_number(num: int) -> str:\n    if num < 0:\n        raise ValueError(\"This function only accepts non-negative integers\")\n    if num >= 100:\n        raise ValueError(\"This function only converts numbers less than 100\")\n    tens, ones = divmod(num, 10)\n    if tens == 0:\n        return NumberWords.ONES.value[ones] or \"zero\"\n    if tens == 1:\n        return NumberWords.TEENS.value[ones]\n    return (\n        NumberWords.TENS.value[tens]\n        + (\"-\" if NumberWords.ONES.value[ones] else \"\")\n        + NumberWords.ONES.value[ones]\n    )", "output": "Converts small, non-negative integers with irregular constructions in English (i.e.,"}
{"task": "search", "input": "search code:\n:param number: nth hexagonal number to calculate\n\nChoices:\n0: def largest_square_area_in_matrix_bottom_up_space_optimization(     rows: int, cols: int, mat: list[list[int]] ) -> int:     current_row = [0] * (cols + 1)     next_row = [0] * (cols + 1)     largest_square_area = 0     for row in range(rows - 1, -1, -1):         for col in range(cols - 1, -1, -1):             right = current_row[col + 1]             diagonal = next_row[col + 1]             bottom = next_row[col]              if mat[row][col] == 1:                 current_row[col] = 1 + min(right, diagonal, bottom)                 largest_square_area = max(current_row[col], largest_square_area)             else:                 current_row[col] = 0         next_row = current_row      return largest_square_area\n1: def solution(n: int = 1000) -> int:      result = 0     for i in range(n):         if i % 3 == 0 or i % 5 == 0:             result += i     return result\n2: def hexagonal(number: int) -> int:     if not isinstance(number, int):         msg = f\"Input value of [number={number}] must be an integer\"         raise TypeError(msg)     if number < 1:         raise ValueError(\"Input must be a positive integer\")     return number * (2 * number - 1)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef text_justification(word: str, max_width: int) -> list:\n    \"\"\"\n    Will format the string such that each line has exactly\n    (max_width) characters and is fully (left and right) justified,\n    and return the list of justified text.\n\n    example 1:\n    string = \"This is an example of text justification.\"\n    max_width = 16\n\n    output = ['This    is    an',\n              'example  of text',\n              'justification.  ']\n\n    >>> text_justification(\"This is an example of text justification.\", 16)\n    ['This    is    an', 'example  of text', 'justification.  ']\n\n    example 2:\n    string = \"Two roads diverged in a yellow wood\"\n    max_width = 16\n    output = ['Two        roads',\n              'diverged   in  a',\n              'yellow wood     ']\n\n    >>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n    ['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\n    Time complexity: O(m*n)\n    Space complexity: O(m*n)\n    \"\"\"\n\n    # Converting string into list of strings split by a space\n    words = word.split()\n\n    def justify(line: list, width: int, max_width: int) -> str:\n        overall_spaces_count = max_width - width\n        words_count = len(line)\n        if len(line) == 1:\n            # if there is only word in line\n            # just insert overall_spaces_count for the remainder of line\n            return line[0] + \" \" * overall_spaces_count\n        else:\n            spaces_to_insert_between_words = words_count - 1\n            # num_spaces_between_words_list[i] : tells you to insert\n            # num_spaces_between_words_list[i] spaces\n            # after word on line[i]\n            num_spaces_between_words_list = spaces_to_insert_between_words * [\n                overall_spaces_count // spaces_to_insert_between_words\n            ]\n            spaces_count_in_locations = (\n                overall_spaces_count % spaces_to_insert_between_words\n            )\n            # distribute spaces via round robin to the left words\n            for i in range(spaces_count_in_locations):\n                num_spaces_between_words_list[i] += 1\n            aligned_words_list = []\n            for i in range(spaces_to_insert_between_words):\n                # add the word\n                aligned_words_list.append(line[i])\n                # add the spaces to insert\n                aligned_words_list.append(num_spaces_between_words_list[i] * \" \")\n            # just add the last word to the sentence\n            aligned_words_list.append(line[-1])\n            # join the aligned words list to form a justified line\n            return \"\".join(aligned_words_list)\n\n    answer = []\n    line: list[str] = []\n    width = 0\n    for inner_word in words:\n        if width + len(inner_word) + len(line) <= max_width:\n            # keep adding words until we can fill out max_width\n            # width = sum of length of all words (without overall_spaces_count)\n            # len(inner_word) = length of current inner_word\n            # len(line) = number of overall_spaces_count to insert between words\n            line.append(inner_word)\n            width += len(inner_word)\n        else:\n            # justify the line and add it to result\n            answer.append(justify(line, width, max_width))\n            # reset new line and new width\n            line, width = [inner_word], len(inner_word)\n    remaining_spaces = max_width - width - len(line)\n    answer.append(\" \".join(line) + (remaining_spaces + 1) * \" \")\n    return answer", "output": "def text_justification(word: str, max_width: int) -> list:\n    \"\"\"\n    Will format the string such that each line has exactly\n    (max_width) characters and is fully (left and right) justified,\n    and return the list of justified text.\n\n    example 1:\n    string = \"This is an example of text justification.\"\n    max_width = 16\n\n    output = ['This    is    an',\n              'example  of text',\n              'justification.  ']\n\n    >>> text_justification(\"This is an example of text justification.\", 16)\n    ['This    is    an', 'example  of text', 'justification.  ']\n\n    example 2:\n    string = \"Two roads diverged in a yellow wood\"\n    max_width = 16\n    output = ['Two        roads',\n              'diverged   in  a',\n              'yellow wood     ']\n\n    >>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n    ['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\n    Time complexity: O(m*n)\n    Space complexity: O(m*n)\n    \"\"\"\n\n    # Converting string into list of strings split by a space\n    words = word.split()\n\n    def justify(line: list, width: int, max_width: int) -> str:\n        overall_spaces_count = max_width - width\n        words_count = len(line)\n        if len(line) == 1:\n            # if there is only word in line\n            # just insert overall_spaces_count for the remainder of line\n            return line[0] + \" \" * overall_spaces_count\n        else:\n            spaces_to_insert_between_words = words_count - 1\n            # num_spaces_between_words_list[i] : tells you to insert\n            # num_spaces_between_words_list[i] spaces\n            # after word on line[i]\n            num_spaces_between_words_list = spaces_to_insert_between_words * [\n                overall_spaces_count // spaces_to_insert_between_words\n            ]\n            spaces_count_in_locations = (\n                overall_spaces_count % spaces_to_insert_between_words\n            )\n            # distribute spaces via round robin to the left words\n            for i in range(spaces_count_in_locations):\n                num_spaces_between_words_list[i] += 1\n            aligned_words_list = []\n            for i in range(spaces_to_insert_between_words):\n                # add the word\n                aligned_words_list.append(line[i])\n                # add the spaces to insert\n                aligned_words_list.append(num_spaces_between_words_list[i] * \" \")\n            # just add the last word to the sentence\n            aligned_words_list.append(line[-1])\n            # join the aligned words list to form a justified line\n            return \"\".join(aligned_words_list)\n\n    answer = []\n    line: list[str] = []\n    width = 0\n    for inner_word in words:\n        if width + len(inner_word) + len(line) <= max_width:\n            # keep adding words until we can fill out max_width\n            # width = sum of length of all words (without overall_spaces_count)\n            # len(inner_word) = length of current inner_word\n            # len(line) = number of overall_spaces_count to insert between words\n            line.append(inner_word)\n            width += len(inner_word)\n        else:\n            # justify the line and add it to result\n            answer.append(justify(line, width, max_width))\n            # reset new line and new width\n            line, width = [inner_word], len(inner_word)\n    remaining_spaces = max_width - width - len(line)\n    answer.append(\" \".join(line) + (remaining_spaces + 1) * \" \")\n    return answer"}
{"task": "search", "input": "search code:\nEdge tracking. Usually a weak edge pixel caused from true edges will be connected\n\nChoices:\n0: def run(canvas: list[list[bool]]) -> list[list[bool]]:     current_canvas = np.array(canvas)     next_gen_canvas = np.array(create_canvas(current_canvas.shape[0]))     for r, row in enumerate(current_canvas):         for c, pt in enumerate(row):             next_gen_canvas[r][c] = __judge_point(                 pt, current_canvas[r - 1 : r + 2, c - 1 : c + 2]             )      return next_gen_canvas.tolist()\n1: def track_edge(image_shape, destination, weak, strong):     for row in range(1, image_shape[0]):         for col in range(1, image_shape[1]):             if destination[row, col] == weak:                 if 255 in (                     destination[row, col + 1],                     destination[row, col - 1],                     destination[row - 1, col],                     destination[row + 1, col],                     destination[row - 1, col - 1],                     destination[row + 1, col - 1],                     destination[row - 1, col + 1],                     destination[row + 1, col + 1],                 ):                     destination[row, col] = strong                 else:                     destination[row, col] = 0\n2: def benchmark() -> None:     from timeit import timeit      print(\"Running performance benchmarks...\")     setup = \"from string import printable ; from __main__ import atbash, atbash_slow\"     print(f\"> atbash_slow(): {timeit('atbash_slow(printable)', setup=setup)} seconds\")     print(f\">      atbash(): {timeit('atbash(printable)', setup=setup)} seconds\")", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef next_point(\n    point_x: float, point_y: float, incoming_gradient: float\n) -> tuple[float, float, float]:\n    # normal_gradient = gradient of line through which the beam is reflected\n    # outgoing_gradient = gradient of reflected line\n    normal_gradient = point_y / 4 / point_x\n    s2 = 2 * normal_gradient / (1 + normal_gradient * normal_gradient)\n    c2 = (1 - normal_gradient * normal_gradient) / (\n        1 + normal_gradient * normal_gradient\n    )\n    outgoing_gradient = (s2 - c2 * incoming_gradient) / (c2 + s2 * incoming_gradient)\n\n    # to find the next point, solve the simultaeneous equations:\n    # y^2 + 4x^2 = 100\n    # y - b = m * (x - a)\n    # ==> A x^2 + B x + C = 0\n    quadratic_term = outgoing_gradient**2 + 4\n    linear_term = 2 * outgoing_gradient * (point_y - outgoing_gradient * point_x)\n    constant_term = (point_y - outgoing_gradient * point_x) ** 2 - 100\n\n    x_minus = (\n        -linear_term - sqrt(linear_term**2 - 4 * quadratic_term * constant_term)\n    ) / (2 * quadratic_term)\n    x_plus = (\n        -linear_term + sqrt(linear_term**2 - 4 * quadratic_term * constant_term)\n    ) / (2 * quadratic_term)\n\n    # two solutions, one of which is our input point\n    next_x = x_minus if isclose(x_plus, point_x) else x_plus\n    next_y = point_y + outgoing_gradient * (next_x - point_x)\n\n    return next_x, next_y, outgoing_gradient", "output": "Given that a laser beam hits the interior of the white cell at point"}
{"task": "search", "input": "search code:\nReturn the kth smallest number in lst.\n\nChoices:\n0: def recursive_match(text: str, pattern: str) -> bool:     if not pattern:         return not text      if not text:         return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])      if text[-1] == pattern[-1] or pattern[-1] == \".\":         return recursive_match(text[:-1], pattern[:-1])      if pattern[-1] == \"*\":         return recursive_match(text[:-1], pattern) or recursive_match(             text, pattern[:-2]         )      return False\n1: def solution(nth: int = 10001) -> int:      try:         nth = int(nth)     except (TypeError, ValueError):         raise TypeError(\"Parameter nth must be int or castable to int.\") from None     if nth <= 0:         raise ValueError(\"Parameter nth must be greater than or equal to one.\")     primes: list[int] = []     num = 2     while len(primes) < nth:         if is_prime(num):             primes.append(num)             num += 1         else:             num += 1     return primes[len(primes) - 1]\n2: def kth_number(lst: list[int], k: int) -> int:     # pick a pivot and separate into list based on pivot.     pivot = random_pivot(lst)      # partition based on pivot     # linear time     small = [e for e in lst if e < pivot]     big = [e for e in lst if e > pivot]      # if we get lucky, pivot might be the element we want.     # we can easily see this:     # small (elements smaller than k)     # + pivot (kth element)     # + big (elements larger than k)     if len(small) == k - 1:         return pivot     # pivot is in elements bigger than k     elif len(small) < k - 1:         return kth_number(big, k - len(small) - 1)     # pivot is in elements smaller than k     else:         return kth_number(small, k)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef largest_divisible_subset(items: list[int]) -> list[int]:\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result", "output": "Algorithm to find the biggest subset in the given array such that for any 2 elements"}
{"task": "summary", "input": "summarize code:\ndef straight_line_depreciation(\n    useful_years: int,\n    purchase_value: float,\n    residual_value: float = 0.0,\n) -> list[float]:\n\n    if not isinstance(useful_years, int):\n        raise TypeError(\"Useful years must be an integer\")\n\n    if useful_years < 1:\n        raise ValueError(\"Useful years cannot be less than 1\")\n\n    if not isinstance(purchase_value, (float, int)):\n        raise TypeError(\"Purchase value must be numeric\")\n\n    if not isinstance(residual_value, (float, int)):\n        raise TypeError(\"Residual value must be numeric\")\n\n    if purchase_value < 0.0:\n        raise ValueError(\"Purchase value cannot be less than zero\")\n\n    if purchase_value < residual_value:\n        raise ValueError(\"Purchase value cannot be less than residual value\")\n\n    # Calculate annual depreciation expense\n    depreciable_cost = purchase_value - residual_value\n    annual_depreciation_expense = depreciable_cost / useful_years\n\n    # List of annual depreciation expenses\n    list_of_depreciation_expenses = []\n    accumulated_depreciation_expense = 0.0\n    for period in range(useful_years):\n        if period != useful_years - 1:\n            accumulated_depreciation_expense += annual_depreciation_expense\n            list_of_depreciation_expenses.append(annual_depreciation_expense)\n        else:\n            depreciation_expense_in_end_year = (\n                depreciable_cost - accumulated_depreciation_expense\n            )\n            list_of_depreciation_expenses.append(depreciation_expense_in_end_year)\n\n    return list_of_depreciation_expenses", "output": "Calculate the depreciation expenses over the given period"}
{"task": "detection", "input": "classify code:\ndef circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef flatten(iterable):\n    return list(flatten_iter(iterable))", "output": "``flatten()`` returns a collapsed list of all the elements from"}
{"task": "summary", "input": "summarize code:\ndef validate_initial_digits(credit_card_number: str) -> bool:\n    return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))", "output": "Function to validate initial digits of a given credit card number."}
{"task": "search", "input": "search code:\nArea under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi\n\nChoices:\n0: def edit_distance(source: str, target: str) -> int:     if len(source) == 0:         return len(target)     elif len(target) == 0:         return len(source)      delta = int(source[-1] != target[-1])  # Substitution     return min(         edit_distance(source[:-1], target[:-1]) + delta,         edit_distance(source, target[:-1]) + 1,         edit_distance(source[:-1], target) + 1,     )\n1: def pi_estimator_using_area_under_curve(iterations: int) -> None:      def function_to_integrate(x: float) -> float:         return sqrt(4.0 - x * x)      estimated_value = area_under_curve_estimator(         iterations, function_to_integrate, 0.0, 2.0     )      print(\"******************\")     print(\"Estimating pi using area_under_curve_estimator\")     print(f\"Estimated value is {estimated_value}\")     print(f\"Expected value is {pi}\")     print(f\"Total error is {abs(estimated_value - pi)}\")     print(\"******************\")\n2: def ignore_overflow_warnings() -> None:     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in multiply\"     )     warnings.filterwarnings(         \"ignore\",         category=RuntimeWarning,         message=\"invalid value encountered in multiply\",     )     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in absolute\"     )     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in exp\"     )", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:\n    \"\"\"\n    Find the sum of n terms in an arithmetic progression.\n\n    >>> sum_of_series(1, 1, 10)\n    55.0\n    >>> sum_of_series(1, 10, 100)\n    49600.0\n    \"\"\"\n    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\n    # formula for sum of series\n    return total", "output": "def sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:\n    \"\"\"\n    Find the sum of n terms in an arithmetic progression.\n\n    >>> sum_of_series(1, 1, 10)\n    55.0\n    >>> sum_of_series(1, 10, 100)\n    49600.0\n    \"\"\"\n    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\n    # formula for sum of series\n    return total"}
{"task": "summary", "input": "summarize code:\ndef evaluate(item: str, main_target: str) -> tuple[str, float]:\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))", "output": "Evaluate how similar the item is with the target by just"}
{"task": "search", "input": "search code:\nReturns the last 8 digits of the hyperexponentiation of base by\n\nChoices:\n0: def hubble_parameter(     hubble_constant: float,     radiation_density: float,     matter_density: float,     dark_energy: float,     redshift: float, ) -> float:     parameters = [redshift, radiation_density, matter_density, dark_energy]     if any(p < 0 for p in parameters):         raise ValueError(\"All input parameters must be positive\")      if any(p > 1 for p in parameters[1:4]):         raise ValueError(\"Relative densities cannot be greater than one\")     else:         curvature = 1 - (matter_density + radiation_density + dark_energy)          e_2 = (             radiation_density * (redshift + 1) ** 4             + matter_density * (redshift + 1) ** 3             + curvature * (redshift + 1) ** 2             + dark_energy         )          hubble = hubble_constant * e_2 ** (1 / 2)         return hubble\n1: def solution(base: int = 1777, height: int = 1855, digits: int = 8) -> int:      # calculate baseheight by right-assiciative repeated modular     # exponentiation     result = base     for _ in range(1, height):         result = _modexpt(base, result, 10**digits)      return result\n2: def factorial(number: int) -> int:     if number != int(number):         raise ValueError(\"factorial() only accepts integral values\")     if number < 0:         raise ValueError(\"factorial() not defined for negative values\")     value = 1     for i in range(1, number + 1):         value *= i     return value", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef binary_count_trailing_zeros(a: int) -> int:\n    if a < 0:\n        raise ValueError(\"Input value must be a positive integer\")\n    elif isinstance(a, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    return 0 if (a == 0) else int(log2(a & -a))", "output": "Take in 1 integer, return a number that is"}
{"task": "summary", "input": "summarize code:\ndef intersperse(e, iterable, n=1):\n    if n == 0:\n        raise ValueError('n must be > 0')\n    elif n == 1:\n        # interleave(repeat(e), iterable) -> e, x_0, e, x_1, e, x_2...\n        # islice(..., 1, None) -> x_0, e, x_1, e, x_2...\n        return islice(interleave(repeat(e), iterable), 1, None)\n    else:\n        # interleave(filler, chunks) -> [e], [x_0, x_1], [e], [x_2, x_3]...\n        # islice(..., 1, None) -> [x_0, x_1], [e], [x_2, x_3]...\n        # flatten(...) -> x_0, x_1, e, x_2, x_3...\n        filler = repeat([e])\n        chunks = chunked(iterable, n)\n        return flatten(islice(interleave(filler, chunks), 1, None))", "output": "Intersperse filler element *e* among the items in *iterable*, leaving"}
{"task": "search", "input": "search code:\nCollect dataset of CSGO\n\nChoices:\n0: def solution(numerator: int = 3, denominator: int = 7, limit: int = 1000000) -> int:     max_numerator = 0     max_denominator = 1      for current_denominator in range(1, limit + 1):         current_numerator = current_denominator * numerator // denominator         if current_denominator % denominator == 0:             current_numerator -= 1         if current_numerator * max_denominator > current_denominator * max_numerator:             max_numerator = current_numerator             max_denominator = current_denominator     return max_numerator\n1: def calculate_waiting_time(     process_name: list,  # noqa: ARG001     turn_around_time: list,     burst_time: list,     no_of_process: int, ) -> list:      waiting_time = [0] * no_of_process     for i in range(no_of_process):         waiting_time[i] = turn_around_time[i] - burst_time[i]     return waiting_time\n2: def collect_dataset():     response = httpx.get(         \"https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/\"         \"master/Week1/ADRvsRating.csv\",         timeout=10,     )     lines = response.text.splitlines()     data = []     for item in lines:         item = item.split(\",\")         data.append(item)     data.pop(0)  # This is for removing the labels from the list     dataset = np.matrix(data)     return dataset", "output": "2"}
{"task": "search", "input": "search code:\nReturn the least value k such that the Repunit of length k is divisible by divisor.\n\nChoices:\n0: def breadth_first_search(     level: list[int],     parent: list[list[int]],     max_node: int,     graph: dict[int, list[int]],     root: int = 1, ) -> tuple[list[int], list[list[int]]]:     level[root] = 0     q: Queue[int] = Queue(maxsize=max_node)     q.put(root)     while q.qsize() != 0:         u = q.get()         for v in graph[u]:             if level[v] == -1:                 level[v] = level[u] + 1                 q.put(v)                 parent[0][v] = u     return level, parent\n1: def breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:     visited = [False] * len(graph)  # Mark all nodes as not visited     queue = []  # breadth-first search queue      # Source node     queue.append(source)     visited[source] = True      while queue:         u = queue.pop(0)  # Pop the front node         # Traverse all adjacent nodes of u         for ind, node in enumerate(graph[u]):             if visited[ind] is False and node > 0:                 queue.append(ind)                 visited[ind] = True                 parents[ind] = u     return visited[sink]\n2: def least_divisible_repunit(divisor: int) -> int:     if divisor % 5 == 0 or divisor % 2 == 0:         return 0     repunit = 1     repunit_index = 1     while repunit:         repunit = (10 * repunit + 1) % divisor         repunit_index += 1     return repunit_index", "output": "2"}
{"task": "detection", "input": "classify code:\ndef cycle_sort(array: list) -> list:\n    \"\"\"\n    >>> cycle_sort([4, 3, 2, 1])\n    [1, 2, 3, 4]\n\n    >>> cycle_sort([-4, 20, 0, -50, 100, -1])\n    [-50, -4, -1, 0, 20, 100]\n\n    >>> cycle_sort([-.1, -.2, 1.3, -.8])\n    [-0.8, -0.2, -0.1, 1.3]\n\n    >>> cycle_sort([])\n    []\n    \"\"\"\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return array", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef split_when(iterable, pred, maxsplit=-1):\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    it = iter(iterable)\n    try:\n        cur_item = next(it)\n    except StopIteration:\n        return\n\n    buf = [cur_item]\n    for next_item in it:\n        if pred(cur_item, next_item):\n            yield buf\n            if maxsplit == 1:\n                yield [next_item, *it]\n                return\n            buf = []\n            maxsplit -= 1\n\n        buf.append(next_item)\n        cur_item = next_item\n\n    yield buf", "output": "Split *iterable* into pieces based on the output of *pred*."}
{"task": "search", "input": "search code:\nGet the frequency order of the letters in the given string\n\nChoices:\n0: def num_digits_faster(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      return len(str(abs(n)))\n1: def get_frequency_order(message: str) -> str:     letter_to_freq = get_letter_count(message)     freq_to_letter: dict[int, list[str]] = {         freq: [] for letter, freq in letter_to_freq.items()     }     for letter in LETTERS:         freq_to_letter[letter_to_freq[letter]].append(letter)      freq_to_letter_str: dict[int, str] = {}      for freq in freq_to_letter:  # noqa: PLC0206         freq_to_letter[freq].sort(key=ETAOIN.find, reverse=True)         freq_to_letter_str[freq] = \"\".join(freq_to_letter[freq])      freq_pairs = list(freq_to_letter_str.items())     freq_pairs.sort(key=get_item_at_index_zero, reverse=True)      freq_order: list[str] = [freq_pair[1] for freq_pair in freq_pairs]      return \"\".join(freq_order)\n2: def format_invocation(name='', args=(), kwargs=None, **kw):     _repr = kw.pop('repr', repr)     if kw:         raise TypeError('unexpected keyword args: %r' % ', '.join(kw.keys()))     kwargs = kwargs or {}     a_text = ', '.join([_repr(a) for a in args])     if isinstance(kwargs, dict):         kwarg_items = [(k, kwargs[k]) for k in sorted(kwargs)]     else:         kwarg_items = kwargs     kw_text = ', '.join([f'{k}={_repr(v)}' for k, v in kwarg_items])      all_args_text = a_text     if all_args_text and kw_text:         all_args_text += ', '     all_args_text += kw_text      return f'{name}({all_args_text})'", "output": "1"}
{"task": "detection", "input": "classify code:\ndef f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef scaling(scaling_factor: float) -> list[list[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef swap_case(sentence):\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        if char.islower():\n            new_string += char.upper()\n        if regexp.search(char):\n            new_string += char\n\n    return new_string", "output": "def swap_case(sentence: str) -> str:\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n\n    return new_string"}
{"task": "detection", "input": "classify code:\ndef list_truncated_nums(n: int) -> List[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCross product of elements in A and elements in B.\n\nChoices:\n0: def binary_tree_top_side_view(root: TreeNode) -> list[int]:      def breadth_first_search(root: TreeNode, top_view: list[int]) -> None:         queue = [(root, 0)]         lookup = defaultdict(list)          while queue:             first = queue.pop(0)             node, hd = first              lookup[hd].append(node.val)              if node.left:                 queue.append((node.left, hd - 1))             if node.right:                 queue.append((node.right, hd + 1))          for pair in sorted(lookup.items(), key=lambda each: each[0]):             top_view.append(pair[1][0])      top_view: list = []     if not root:         return top_view      breadth_first_search(root, top_view)     return top_view\n1: def is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:     for i in range(9):         if n in {grid[row][i], grid[i][column]}:             return False      for i in range(3):         for j in range(3):             if grid[(row - row % 3) + i][(column - column % 3) + j] == n:                 return False      return True\n2: def cross(items_a, items_b):     return [a + b for a in items_a for b in items_b]", "output": "2"}
{"task": "search", "input": "search code:\nPure implementation of a binary search algorithm in Python using stdlib\n\nChoices:\n0: def binary_search_std_lib(sorted_collection: list[int], item: int) -> int:     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     index = bisect.bisect_left(sorted_collection, item)     if index != len(sorted_collection) and sorted_collection[index] == item:         return index     return -1\n1: def comp_and_swap(array: list[int], index1: int, index2: int, direction: int) -> None:     if (direction == 1 and array[index1] > array[index2]) or (         direction == 0 and array[index1] < array[index2]     ):         array[index1], array[index2] = array[index2], array[index1]\n2: def square_zero_matrix(n: int) -> Matrix:     ans: list[list[float]] = [[0] * n for _ in range(n)]     return Matrix(ans, n, n)", "output": "0"}
{"task": "search", "input": "search code:\nfunction is f(x) = x^3 - 2x - 5\n\nChoices:\n0: def f(x: float) -> float:     return math.pow(x, 3) - (2 * x) - 5\n1: def huffman(file_path: str) -> None:     letters_list = parse_file(file_path)     root = build_tree(letters_list)     letters = {         k: v for letter in traverse_tree(root, \"\") for k, v in letter.bitstring.items()     }     print(f\"Huffman Coding  of {file_path}: \")     with open(file_path) as f:         while True:             c = f.read(1)             if not c:                 break             print(letters[c], end=\" \")     print()\n2: def generate_parentheses_iterative(length: int) -> list:     result = []     stack = []      # Each element in stack is a tuple (current_combination, open_count, close_count)     stack.append((\"\", 0, 0))      while stack:         current_combination, open_count, close_count = stack.pop()          if len(current_combination) == 2 * length:             result.append(current_combination)          if open_count < length:             stack.append((current_combination + \"(\", open_count + 1, close_count))          if close_count < open_count:             stack.append((current_combination + \")\", open_count, close_count + 1))      return result", "output": "0"}
{"task": "detection", "input": "classify code:\ndef vernam_encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_encrypt(\"HELLO\",\"KEY\")\n    'RIJVS'\n    \"\"\"\n    ciphertext = \"\"\n    for i in range(len(plaintext)):\n        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65\n        while ct > 25:\n            ct = ct - 26\n        ciphertext += chr(65 + ct)\n    return ciphertext", "output": "BUGGY"}
{"task": "search", "input": "search code:\nBasic checks on the arguments to the rod-cutting algorithms\n\nChoices:\n0: def eliminate(values, s, d):     if d not in values[s]:         return values  ## Already eliminated     values[s] = values[s].replace(d, \"\")     ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.     if len(values[s]) == 0:         return False  ## Contradiction: removed last value     elif len(values[s]) == 1:         d2 = values[s]         if not all(eliminate(values, s2, d2) for s2 in peers[s]):             return False     ## (2) If a unit u is reduced to only one place for a value d, then put it there.     for u in units[s]:         dplaces = [s for s in u if d in values[s]]         if len(dplaces) == 0:             return False  ## Contradiction: no place for this value         # d can only be in one place in unit; assign it there         elif len(dplaces) == 1 and not assign(values, dplaces[0], d):             return False     return values\n1: def increment_score(count: int) -> int:     return int(count * (count + 1) / 2)\n2: def _enforce_args(n: int, prices: list):     if n < 0:         msg = f\"n must be greater than or equal to 0. Got n = {n}\"         raise ValueError(msg)      if n > len(prices):         msg = (             \"Each integral piece of rod must have a corresponding price. \"             f\"Got n = {n} but length of prices = {len(prices)}\"         )         raise ValueError(msg)", "output": "2"}
{"task": "search", "input": "search code:\nReturn a sorted copy of the input list\n\nChoices:\n0: def perfect(number: int) -> bool:     if not isinstance(number, int):         raise ValueError(\"number must be an integer\")     if number <= 0:         return False     return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number\n1: def iter_merge_sort(input_list: list) -> list:     if len(input_list) <= 1:         return input_list     input_list = list(input_list)      # iteration for two-way merging     p = 2     while p <= len(input_list):         # getting low, high and middle value for merge-sort of single list         for i in range(0, len(input_list), p):             low = i             high = i + p - 1             mid = (low + high + 1) // 2             input_list = merge(input_list, low, mid, high)         # final merge of last two parts         if p * 2 >= len(input_list):             mid = i             input_list = merge(input_list, 0, mid, len(input_list) - 1)             break         p *= 2      return input_list\n2: def solution(limit=28123):     sum_divs = [1] * (limit + 1)      for i in range(2, int(limit**0.5) + 1):         sum_divs[i * i] += i         for k in range(i + 1, limit // i + 1):             sum_divs[k * i] += k + i      abundants = set()     res = 0      for n in range(1, limit + 1):         if sum_divs[n] > n:             abundants.add(n)          if not any((n - a in abundants) for a in abundants):             res += n      return res", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef accuracy(actual_y: list, predicted_y: list) -> float:\n    # iterate over one element of each list at a time (zip mode)\n    # prediction is correct if actual Y value equals to predicted Y value\n    correct = sum(1 for i, j in zip(actual_y, predicted_y) if i == j)\n    # percentage of accuracy equals to number of correct predictions divided by number\n    # of all data and multiplied by 100\n    return (correct / len(actual_y)) * 100", "output": "Calculate the value of accuracy based-on predictions"}
{"task": "search", "input": "search code:\nReduces large number to a more manageable number\n\nChoices:\n0: def num_digits_fast(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      return 1 if n == 0 else math.floor(math.log(abs(n), 10) + 1)\n1: def res(x, y):     if 0 not in (x, y):         # We use the relation x^y = y*log10(x), where 10 is the base.         return y * math.log10(x)     elif x == 0:  # 0 raised to any number is 0         return 0     elif y == 0:         return 1  # any number raised to 0 is 1     raise AssertionError(\"This should never happen\")\n2: def zero_vector(dimension: int) -> Vector:     # precondition     assert isinstance(dimension, int)     return Vector([0] * dimension)", "output": "1"}
{"task": "search", "input": "search code:\nScalars are bytes, strings, and non-iterables.\n\nChoices:\n0: def fast_primes(max_n: int) -> Generator[int]:     numbers: Generator = (i for i in range(1, (max_n + 1), 2))     # It's useless to test even numbers as they will not be prime     if max_n > 2:         yield 2  # Because 2 will not be tested, it's necessary to yield it now     for i in (n for n in numbers if n > 1):         bound = int(math.sqrt(i)) + 1         for j in range(3, bound, 2):             # As we removed the even numbers, we don't need them now             if (i % j) == 0:                 break         else:             yield i\n1: def _is_scalar(value, stringlike=(str, bytes)):     \"Scalars are bytes, strings, and non-iterables.\"     try:         iter(value)     except TypeError:         return True     return isinstance(value, stringlike)\n2: def map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):      ret = defaultdict(list)      if valuefunc is None:         for item in iterable:             key = keyfunc(item)             ret[key].append(item)      else:         for item in iterable:             key = keyfunc(item)             value = valuefunc(item)             ret[key].append(value)      if reducefunc is not None:         for key, value_list in ret.items():             ret[key] = reducefunc(value_list)      ret.default_factory = None     return ret", "output": "1"}
{"task": "search", "input": "search code:\nThis function returns the mode(Mode as in the measures of\n\nChoices:\n0: def ichunked(iterable, n):     iterator = iter(iterable)     while True:         # Create new chunk         chunk, materialize_next = _ichunk(iterator, n)          # Check to see whether we're at the end of the source iterable         if not materialize_next():             return          yield chunk          # Fill previous chunk's cache         materialize_next(None)\n1: def find_circular_primes(limit: int = 1000000) -> list[int]:     result = [2]  # result already includes the number 2.     for num in range(3, limit + 1, 2):         if is_prime(num) and not contains_an_even_digit(num):             str_num = str(num)             list_nums = [int(str_num[j:] + str_num[:j]) for j in range(len(str_num))]             if all(is_prime(i) for i in list_nums):                 result.append(num)     return result\n2: def mode(input_list: list) -> list[Any]:     if not input_list:         return []     result = [input_list.count(value) for value in input_list]     y = max(result)  # Gets the maximum count in the input list.     # Gets values of modes     return sorted({input_list[i] for i, value in enumerate(result) if value == y})", "output": "2"}
{"task": "search", "input": "search code:\nReturn a dict of current worldwide COVID-19 statistics\n\nChoices:\n0: def is_happy_number(number: int) -> bool:     if not isinstance(number, int) or number <= 0:         msg = f\"{number=} must be a positive integer\"         raise ValueError(msg)      seen = set()     while number != 1 and number not in seen:         seen.add(number)         number = sum(int(digit) ** 2 for digit in str(number))     return number == 1\n1: def world_covid19_stats(     url: str = \"https://www.worldometers.info/coronavirus/\", ) -> dict:     soup = BeautifulSoup(         httpx.get(url, timeout=10, follow_redirects=True).text, \"html.parser\"     )     keys = soup.find_all(\"h1\")     values = soup.find_all(\"div\", {\"class\": \"maincounter-number\"})     keys += soup.find_all(\"span\", {\"class\": \"panel-title\"})     values += soup.find_all(\"div\", {\"class\": \"number-table-main\"})     return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}\n2: def breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:     visited = {start}     result = [start]     queue = deque([start])     while queue:         v = queue.popleft()         for child in graph[v]:             if child not in visited:                 visited.add(child)                 result.append(child)                 queue.append(child)     return result", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef gamma(velocity: float) -> float:\n    return 1 / sqrt(1 - beta(velocity) ** 2)", "output": "Calculate the Lorentz factor y = 1 / (1 - v/c) for a given velocity"}
{"task": "search", "input": "search code:\nRotate a linked list to the right by places times.\n\nChoices:\n0: def generate_first_solution(path, dict_of_neighbours):      with open(path) as f:         start_node = f.read(1)     end_node = start_node      first_solution = []      visiting = start_node      distance_of_first_solution = 0     while visiting not in first_solution:         minim = 10000         for k in dict_of_neighbours[visiting]:             if int(k[1]) < int(minim) and k[0] not in first_solution:                 minim = k[1]                 best_node = k[0]          first_solution.append(visiting)         distance_of_first_solution = distance_of_first_solution + int(minim)         visiting = best_node      first_solution.append(end_node)      position = 0     for k in dict_of_neighbours[first_solution[-2]]:         if k[0] == start_node:             break         position += 1      distance_of_first_solution = (         distance_of_first_solution         + int(dict_of_neighbours[first_solution[-2]][position][1])         - 10000     )     return first_solution, distance_of_first_solution\n1: def rotate_to_the_right(head: Node, places: int) -> Node:     # Check if the list is empty or has only one element     if not head:         raise ValueError(\"The linked list is empty.\")      if head.next_node is None:         return head      # Calculate the length of the linked list     length = 1     temp_node = head     while temp_node.next_node is not None:         length += 1         temp_node = temp_node.next_node      # Adjust the value of places to avoid places longer than the list.     places %= length      if places == 0:         return head  # As no rotation is needed.      # Find the new head position after rotation.     new_head_index = length - places      # Traverse to the new head position     temp_node = head     for _ in range(new_head_index - 1):         assert temp_node.next_node         temp_node = temp_node.next_node      # Update pointers to perform rotation     assert temp_node.next_node     new_head = temp_node.next_node     temp_node.next_node = None     temp_node = new_head     while temp_node.next_node:         temp_node = temp_node.next_node     temp_node.next_node = head      assert new_head     return new_head\n2: def knapsack(     capacity: int,     weights: list[int],     values: list[int],     counter: int,     allow_repetition=False, ) -> int:      @lru_cache     def knapsack_recur(capacity: int, counter: int) -> int:         # Base Case         if counter == 0 or capacity == 0:             return 0          # If weight of the nth item is more than Knapsack of capacity,         #   then this item cannot be included in the optimal solution,         # else return the maximum of two cases:         #   (1) nth item included only once (0-1), if allow_repetition is False         #       nth item included one or more times (0-N), if allow_repetition is True         #   (2) not included         if weights[counter - 1] > capacity:             return knapsack_recur(capacity, counter - 1)         else:             left_capacity = capacity - weights[counter - 1]             new_value_included = values[counter - 1] + knapsack_recur(                 left_capacity, counter - 1 if not allow_repetition else counter             )             without_new_value = knapsack_recur(capacity, counter - 1)             return max(new_value_included, without_new_value)      return knapsack_recur(capacity, counter)", "output": "1"}
{"task": "search", "input": "search code:\nRecursive function to calculate the product of two matrices, using the Strassen\n\nChoices:\n0: def solution(n: int = 1000) -> int:     answer = 1     gen = fibonacci_generator()     while len(str(next(gen))) < n:         answer += 1     return answer + 1\n1: def actual_strassen(matrix_a: list, matrix_b: list) -> list:     if matrix_dimensions(matrix_a) == (2, 2):         return default_matrix_multiplication(matrix_a, matrix_b)      a, b, c, d = split_matrix(matrix_a)     e, f, g, h = split_matrix(matrix_b)      t1 = actual_strassen(a, matrix_subtraction(f, h))     t2 = actual_strassen(matrix_addition(a, b), h)     t3 = actual_strassen(matrix_addition(c, d), e)     t4 = actual_strassen(d, matrix_subtraction(g, e))     t5 = actual_strassen(matrix_addition(a, d), matrix_addition(e, h))     t6 = actual_strassen(matrix_subtraction(b, d), matrix_addition(g, h))     t7 = actual_strassen(matrix_subtraction(a, c), matrix_addition(e, f))      top_left = matrix_addition(matrix_subtraction(matrix_addition(t5, t4), t2), t6)     top_right = matrix_addition(t1, t2)     bot_left = matrix_addition(t3, t4)     bot_right = matrix_subtraction(matrix_subtraction(matrix_addition(t1, t5), t3), t7)      # construct the new matrix from our 4 quadrants     new_matrix = []     for i in range(len(top_right)):         new_matrix.append(top_left[i] + top_right[i])     for i in range(len(bot_right)):         new_matrix.append(bot_left[i] + bot_right[i])     return new_matrix\n2: def can_complete_journey(gas_stations: tuple[GasStation, ...]) -> int:     total_gas = sum(gas_station.gas_quantity for gas_station in gas_stations)     total_cost = sum(gas_station.cost for gas_station in gas_stations)     if total_gas < total_cost:         return -1      start = 0     net = 0     for i, gas_station in enumerate(gas_stations):         net += gas_station.gas_quantity - gas_station.cost         if net < 0:             start = i + 1             net = 0     return start", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef num_digits_fast(n: int) -> int:\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return 1 if n == 0 else math.floor(math.log(abs(n), 10) + 1)", "output": "Find the number of digits in a number."}
{"task": "summary", "input": "summarize code:\ndef unique_iter(src, key=None):\n    if not is_iterable(src):\n        raise TypeError('expected an iterable, not %r' % type(src))\n    if key is None:\n        def key_func(x): return x\n    elif callable(key):\n        key_func = key\n    elif isinstance(key, str):\n        def key_func(x): return getattr(x, key, x)\n    else:\n        raise TypeError('\"key\" expected a string or callable, not %r' % key)\n    seen = set()\n    for i in src:\n        k = key_func(i)\n        if k not in seen:\n            seen.add(k)\n            yield i\n    return", "output": "Yield unique elements from the iterable, *src*, based on *key*,"}
{"task": "search", "input": "search code:\nComputes the sign perpendicular distance of a 2d point c from a line segment\n\nChoices:\n0: def count_inversions_recursive(arr):     if len(arr) <= 1:         return arr, 0     mid = len(arr) // 2     p = arr[0:mid]     q = arr[mid:]      a, inversion_p = count_inversions_recursive(p)     b, inversions_q = count_inversions_recursive(q)     c, cross_inversions = _count_cross_inversions(a, b)      num_inversions = inversion_p + inversions_q + cross_inversions     return c, num_inversions\n1: def triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:     for triplet in permutations(arr, 3):         if sum(triplet) == target:             return tuple(sorted(triplet))     return (0, 0, 0)\n2: def _det(a: Point, b: Point, c: Point) -> float:      det = (a.x * b.y + b.x * c.y + c.x * a.y) - (a.y * b.x + b.y * c.x + c.y * a.x)     return det", "output": "2"}
{"task": "search", "input": "search code:\nChecks if input number and (number - 1)/2 are prime.\n\nChoices:\n0: def can_string_be_rearranged_as_palindrome(input_str: str = \"\") -> bool:     if len(input_str) == 0:         return True     lower_case_input_str = input_str.replace(\" \", \"\").lower()     # character_freq_dict: Stores the frequency of every character in the input string     character_freq_dict: dict[str, int] = {}      for character in lower_case_input_str:         character_freq_dict[character] = character_freq_dict.get(character, 0) + 1     odd_char = 0      for character_count in character_freq_dict.values():         if character_count % 2:             odd_char += 1     return not odd_char > 1\n1: def fibonacci_with_matrix_exponentiation(n, f1, f2):     # Trivial Cases     if n == 1:         return f1     elif n == 2:         return f2     matrix = Matrix([[1, 1], [1, 0]])     matrix = modular_exponentiation(matrix, n - 2)     return f2 * matrix.t[0][0] + f1 * matrix.t[0][1]\n2: def is_safe_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return (number - 1) % 2 == 0 and is_prime(number) and is_prime((number - 1) // 2)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    \"\"\"\n    The method arranges two lists as one list in alternative forms of the list elements.\n    :param first_input_list:\n    :param second_input_list:\n    :return: List\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\n    >>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\n    >>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPartitions list based on the pivot element.\n\nChoices:\n0: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]\n1: def partition(arr: list[int], low: int, high: int) -> int:     pivot = arr[high]     i = low - 1     for j in range(low, high):         if arr[j] >= pivot:             i += 1             arr[i], arr[j] = arr[j], arr[i]     arr[i + 1], arr[high] = arr[high], arr[i + 1]     return i + 1\n2: def solution(limit: int = 1000000) -> int:     answer = 0      for outer_width in range(3, (limit // 4) + 2):         if outer_width**2 > limit:             hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)         else:             hole_width_lower_bound = 1         if (outer_width - hole_width_lower_bound) % 2:             hole_width_lower_bound += 1          answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1      return answer", "output": "1"}
{"task": "search", "input": "search code:\nReturns the nth item or a default value.\n\nChoices:\n0: def nth(iterable, n, default=None):     return next(islice(iterable, n, None), default)\n1: def validate_credit_card_number(credit_card_number: str) -> bool:     error_message = f\"{credit_card_number} is an invalid credit card number because\"     if not credit_card_number.isdigit():         print(f\"{error_message} it has nonnumerical characters.\")         return False      if not 13 <= len(credit_card_number) <= 16:         print(f\"{error_message} of its length.\")         return False      if not validate_initial_digits(credit_card_number):         print(f\"{error_message} of its first two digits.\")         return False      if not luhn_validation(credit_card_number):         print(f\"{error_message} it fails the Luhn check.\")         return False      print(f\"{credit_card_number} is a valid credit card number.\")     return True\n2: def util_color(     graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int ) -> bool:      # Base Case     if index == len(graph):         return True      # Recursive Step     for i in range(max_colors):         if valid_coloring(graph[index], colored_vertices, i):             # Color current vertex             colored_vertices[index] = i             # Validate coloring             if util_color(graph, max_colors, colored_vertices, index + 1):                 return True             # Backtrack             colored_vertices[index] = -1     return False", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef matrix_multiply_recursive(matrix_a: Matrix, matrix_b: Matrix) -> Matrix:\n    if not matrix_a or not matrix_b:\n        return []\n    if not all(\n        (len(matrix_a) == len(matrix_b), is_square(matrix_a), is_square(matrix_b))\n    ):\n        raise ValueError(\"Invalid matrix dimensions\")\n\n    # Initialize the result matrix with zeros\n    result = [[0] * len(matrix_b[0]) for _ in range(len(matrix_a))]\n\n    # Recursive multiplication of matrices\n    def multiply(\n        i_loop: int,\n        j_loop: int,\n        k_loop: int,\n        matrix_a: Matrix,\n        matrix_b: Matrix,\n        result: Matrix,\n    ) -> None:\n        if i_loop >= len(matrix_a):\n            return\n        if j_loop >= len(matrix_b[0]):\n            return multiply(i_loop + 1, 0, 0, matrix_a, matrix_b, result)\n        if k_loop >= len(matrix_b):\n            return multiply(i_loop, j_loop + 1, 0, matrix_a, matrix_b, result)\n        result[i_loop][j_loop] += matrix_a[i_loop][k_loop] * matrix_b[k_loop][j_loop]\n        return multiply(i_loop, j_loop, k_loop + 1, matrix_a, matrix_b, result)\n\n    # Perform the recursive matrix multiplication\n    multiply(0, 0, 0, matrix_a, matrix_b, result)\n    return result", "output": ":param matrix_a: A square Matrix."}
{"task": "repair", "input": "fix bug:\ndef largest_divisible_subset(items: list[int]) -> list[int]:\n    \"\"\"\n    Algorithm to find the biggest subset in the given array such that for any 2 elements\n    x and y in the subset, either x divides y or y divides x.\n    >>> largest_divisible_subset([1, 16, 7, 8, 4])\n    [16, 8, 4, 1]\n    >>> largest_divisible_subset([1, 2, 3])\n    [2, 1]\n    >>> largest_divisible_subset([-1, -2, -3])\n    [-3]\n    >>> largest_divisible_subset([1, 2, 4, 8])\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset((1, 2, 4, 8))\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset([1, 1, 1])\n    [1, 1, 1]\n    >>> largest_divisible_subset([0, 0, 0])\n    [0, 0, 0]\n    >>> largest_divisible_subset([-1, -1, -1])\n    [-1, -1, -1]\n    >>> largest_divisible_subset([])\n    []\n    \"\"\"\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result", "output": "def largest_divisible_subset(items: list[int]) -> list[int]:\n    \"\"\"\n    Algorithm to find the biggest subset in the given array such that for any 2 elements\n    x and y in the subset, either x divides y or y divides x.\n    >>> largest_divisible_subset([1, 16, 7, 8, 4])\n    [16, 8, 4, 1]\n    >>> largest_divisible_subset([1, 2, 3])\n    [2, 1]\n    >>> largest_divisible_subset([-1, -2, -3])\n    [-3]\n    >>> largest_divisible_subset([1, 2, 4, 8])\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset((1, 2, 4, 8))\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset([1, 1, 1])\n    [1, 1, 1]\n    >>> largest_divisible_subset([0, 0, 0])\n    [0, 0, 0]\n    >>> largest_divisible_subset([-1, -1, -1])\n    [-1, -1, -1]\n    >>> largest_divisible_subset([])\n    []\n    \"\"\"\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result"}
{"task": "summary", "input": "summarize code:\ndef calculate_waiting_times(burst_times: list[int]) -> list[int]:\n    quantum = 2\n    rem_burst_times = list(burst_times)\n    waiting_times = [0] * len(burst_times)\n    t = 0\n    while True:\n        done = True\n        for i, burst_time in enumerate(burst_times):\n            if rem_burst_times[i] > 0:\n                done = False\n                if rem_burst_times[i] > quantum:\n                    t += quantum\n                    rem_burst_times[i] -= quantum\n                else:\n                    t += rem_burst_times[i]\n                    waiting_times[i] = t - burst_time\n                    rem_burst_times[i] = 0\n        if done is True:\n            return waiting_times", "output": "Calculate the waiting times of a list of processes that have a specified duration."}
{"task": "summary", "input": "summarize code:\ndef maclaurin_sin(theta: float, accuracy: int = 30) -> float:\n\n    if not isinstance(theta, (int, float)):\n        raise ValueError(\"maclaurin_sin() requires either an int or float for theta\")\n\n    if not isinstance(accuracy, int) or accuracy <= 0:\n        raise ValueError(\"maclaurin_sin() requires a positive int for accuracy\")\n\n    theta = float(theta)\n    div = theta // (2 * pi)\n    theta -= 2 * div * pi\n    return sum(\n        (-1) ** r * theta ** (2 * r + 1) / factorial(2 * r + 1) for r in range(accuracy)\n    )", "output": "Finds the maclaurin approximation of sin"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    a = 3\n    result = 0\n    while a < n:\n        if a % 3 == 0 or a % 5 == 0:\n            result += a\n        elif a % 15 == 0:\n            result -= a\n        a += 1\n    return result", "output": "Returns the sum of all the multiples of 3 or 5 below n."}
{"task": "search", "input": "search code:\nCreate a list of Task objects that are sorted so the highest rewards come first.\n\nChoices:\n0: def solution():     days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]      day = 6     month = 1     year = 1901      sundays = 0      while year < 2001:         day += 7          if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):             if day > days_per_month[month - 1] and month != 2:                 month += 1                 day = day - days_per_month[month - 2]             elif day > 29 and month == 2:                 month += 1                 day = day - 29         elif day > days_per_month[month - 1]:             month += 1             day = day - days_per_month[month - 2]          if month > 12:             year += 1             month = 1          if year < 2001 and day == 1:             sundays += 1     return sundays\n1: def max_tasks(tasks_info: list[tuple[int, int]]) -> list[int]:     tasks = sorted(         (             Task(task_id, deadline, reward)             for task_id, (deadline, reward) in enumerate(tasks_info)         ),         key=attrgetter(\"reward\"),         reverse=True,     )     return [task.task_id for i, task in enumerate(tasks, start=1) if task.deadline >= i]\n2: def solution() -> int:      a = 1     b = 1     c = 2     # temporary Fibonacci numbers      a1 = 1     b1 = 1     c1 = 2     # temporary Fibonacci numbers mod 1e9      # mod m=1e9, done for fast optimisation     tocheck = [0] * 1000000     m = 1000000000      for x in range(1000000):         c1 = (a1 + b1) % m         a1 = b1 % m         b1 = c1 % m         if check1(b1):             tocheck[x + 3] = 1      for x in range(1000000):         c = a + b         a = b         b = c         # perform check only if in tocheck         if tocheck[x + 3] and check(b):             return x + 3  # first 2 already done     return -1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef edit_distance(source: str, target: str) -> int:\n    if len(source) == 0:\n        return len(target)\n    elif len(target) == 0:\n        return len(source)\n\n    delta = int(source[-1] != target[-1])  # Substitution\n    return min(\n        edit_distance(source[:-1], target[:-1]) + delta,\n        edit_distance(source, target[:-1]) + 1,\n        edit_distance(source[:-1], target) + 1,\n    )", "output": "Edit distance algorithm is a string metric, i.e., it is a way of quantifying how"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    result = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            result += i\n    return result", "output": "Returns the sum of all the multiples of 3 or 5 below n."}
{"task": "search", "input": "search code:\nSorts a list using the Stalin sort algorithm.\n\nChoices:\n0: def stalin_sort(sequence: list[int]) -> list[int]:     result = [sequence[0]]     for element in sequence[1:]:         if element >= result[-1]:             result.append(element)      return result\n1: def create_all_state(     increment: int,     total_number: int,     level: int,     current_list: list[int],     total_list: list[list[int]], ) -> None:     if level == 0:         total_list.append(current_list[:])         return      for i in range(increment, total_number - level + 2):         current_list.append(i)         create_all_state(i + 1, total_number, level - 1, current_list, total_list)         current_list.pop()\n2: def main() -> None:     trees = {\"zero\": Node(0), \"seven\": make_tree_seven(), \"nine\": make_tree_nine()}     for name, tree in trees.items():         print(f\"      The {name} tree: {tuple(tree)}\")         # (0,)         # (4, 2, 5, 1, 6, 3, 7)         # (7, 4, 8, 2, 5, 9, 1, 3, 6)         print(f\"Mirror of {name} tree: {tuple(tree.mirror())}\")", "output": "0"}
{"task": "search", "input": "search code:\nCheck if a number is a perfect number.\n\nChoices:\n0: def read_file_binary(file_path: str) -> str:     result = \"\"     try:         with open(file_path, \"rb\") as binary_file:             data = binary_file.read()         for dat in data:             curr_byte = f\"{dat:08b}\"             result += curr_byte         return result     except OSError:         print(\"File not accessible\")         sys.exit()\n1: def solution(limit: int = 100) -> int:     singles: list[int] = [*list(range(1, 21)), 25]     doubles: list[int] = [2 * x for x in range(1, 21)] + [50]     triples: list[int] = [3 * x for x in range(1, 21)]     all_values: list[int] = singles + doubles + triples + [0]      num_checkouts: int = 0     double: int     throw1: int     throw2: int     checkout_total: int      for double in doubles:         for throw1, throw2 in combinations_with_replacement(all_values, 2):             checkout_total = double + throw1 + throw2             if checkout_total < limit:                 num_checkouts += 1      return num_checkouts\n2: def perfect(number: int) -> bool:     if not isinstance(number, int):         raise ValueError(\"number must be an integer\")     if number <= 0:         return False     return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(max_n: int = 100) -> int:\n    pre_numerator = 1\n    cur_numerator = 2\n\n    for i in range(2, max_n + 1):\n        temp = pre_numerator\n        e_cont = 2 * i // 3 if i % 3 == 0 else 1\n        pre_numerator = cur_numerator\n        cur_numerator = e_cont * pre_numerator + temp\n\n    return sum_digits(cur_numerator)", "output": "Returns the sum of the digits in the numerator of the max-th convergent of"}
{"task": "repair", "input": "fix bug:\ndef normalization(data: list, ndigits: int = 3) -> list:\n    \"\"\"\n    Return a normalized list of values.\n\n    @params: data, a list of values to normalize\n    @returns: a list of normalized values (rounded to ndigits decimal places)\n    @examples:\n    >>> normalization([2, 7, 10, 20, 30, 50])\n    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\n    >>> normalization([5, 10, 15, 20, 25])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # variables for calculation\n    x_min = min(data)\n    x_max = max(data)\n    # normalize data\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]", "output": "def normalization(data: list, ndigits: int = 3) -> list:\n    \"\"\"\n    Return a normalized list of values.\n\n    @params: data, a list of values to normalize\n    @returns: a list of normalized values (rounded to ndigits decimal places)\n    @examples:\n    >>> normalization([2, 7, 10, 20, 30, 50])\n    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\n    >>> normalization([5, 10, 15, 20, 25])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # variables for calculation\n    x_min = min(data)\n    x_max = max(data)\n    # normalize data\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]"}
{"task": "summary", "input": "summarize code:\ndef rotate_array(arr: list[int], steps: int) -> list[int]:\n\n    n = len(arr)\n    if n == 0:\n        return arr\n\n    steps = steps % n\n\n    if steps < 0:\n        steps += n\n\n    def reverse(start: int, end: int) -> None:\n\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    reverse(0, n - 1)\n    reverse(0, steps - 1)\n    reverse(steps, n - 1)\n\n    return arr", "output": "Rotates a list to the right by steps positions."}
{"task": "search", "input": "search code:\nCall Modular Exponential Function.\n\nChoices:\n0: def check_partition_perfect(positive_integer: int) -> bool:      exponent = math.log2(math.sqrt(4 * positive_integer + 1) / 2 + 1 / 2)      return exponent == int(exponent)\n1: def main():     print(modular_exponential(3, 200, 13))\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]", "output": "def min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]"}
{"task": "repair", "input": "fix bug:\ndef generate_key(message: str, key: str) -> str:\n    \"\"\"\n    >>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n    'SECRETSECRETSECRE'\n    \"\"\"\n    x = len(message)\n    i = 0\n    while True:\n        if x == i:\n            i = 0\n        if len(key) == len(message):\n            break\n        key += key[i]\n        i += 1\n    return key", "output": "def generate_key(message: str, key: str) -> str:\n    \"\"\"\n    >>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n    'SECRETSECRETSECRE'\n    \"\"\"\n    x = len(message)\n    i = 0\n    while True:\n        if x == i:\n            i = 0\n        if len(key) == len(message):\n            break\n        key += key[i]\n        i += 1\n    return key"}
{"task": "summary", "input": "summarize code:\ndef wave(txt: str) -> list:\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]", "output": "Returns a so called 'wave' of a given string"}
{"task": "search", "input": "search code:\nGet the data of a particular query from NASA archives\n\nChoices:\n0: def get_archive_data(query: str) -> dict:     url = \"https://images-api.nasa.gov/search\"     return httpx.get(url, params={\"q\": query}, timeout=10).json()\n1: def octal_to_binary(octal_number: str) -> str:     if not octal_number:         raise ValueError(\"Empty string was passed to the function\")      binary_number = \"\"     octal_digits = \"01234567\"     for digit in octal_number:         if digit not in octal_digits:             raise ValueError(\"Non-octal value was passed to the function\")          binary_digit = \"\"         value = int(digit)         for _ in range(3):             binary_digit = str(value % 2) + binary_digit             value //= 2         binary_number += binary_digit      return binary_number\n2: def bucketize(src, key=bool, value_transform=None, key_filter=None):     if not is_iterable(src):         raise TypeError('expected an iterable')     elif isinstance(key, list):         if len(key) != len(src):             raise ValueError(\"key and src have to be the same length\")         src = zip(key, src)      if isinstance(key, str):         def key_func(x): return getattr(x, key, x)     elif callable(key):         key_func = key     elif isinstance(key, list):         def key_func(x): return x[0]     else:         raise TypeError('expected key to be callable or a string or a list')      if value_transform is None:         def value_transform(x): return x     if not callable(value_transform):         raise TypeError('expected callable value transform function')     if isinstance(key, list):         f = value_transform         def value_transform(x): return f(x[1])      ret = {}     for val in src:         key_of_val = key_func(val)         if key_filter is None or key_filter(key_of_val):             ret.setdefault(key_of_val, []).append(value_transform(val))     return ret", "output": "0"}
{"task": "detection", "input": "classify code:\ndef p_series(nth_term: int, power: int) -> list:\n    \"\"\"Pure Python implementation of P-Series algorithm\n\n    :return: The P-Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> p_series(5, 2)\n    [1, '1/4', '1/9', '1/16', '1/25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    [1, '1/0.25', '1/0.1111111111111111', '1/0.0625', '1/0.04']\n    >>> p_series(\"\", 1000)\n    ''\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    [1]\n    \"\"\"\n    if nth_term == \"\":\n        return nth_term\n    nth_term = int(nth_term)\n    power = int(power)\n    series = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1/{pow(temp + 1, int(power))}\" if series else 1)\n    return series", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(-123)\n    6\n    >>> sum_of_digits(0)\n    0\n    \"\"\"\n    n = -n if n < 0 else n\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res", "output": "CORRECT"}
{"task": "search", "input": "search code:\nThis code involves the concept of memory functions. Here we solve the subproblems\n\nChoices:\n0: def mf_knapsack(i, wt, val, j):     global f  # a global dp table for knapsack     if f[i][j] < 0:         if j < wt[i - 1]:             val = mf_knapsack(i - 1, wt, val, j)         else:             val = max(                 mf_knapsack(i - 1, wt, val, j),                 mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],             )         f[i][j] = val     return f[i][j]\n1: def solution(n: int = 2) -> int:     result = 1.0     for fraction in fraction_list(n):         frac = Fraction(fraction)         result *= frac.denominator / frac.numerator     return int(result)\n2: def to_complex_case(text: str, upper: bool, separator: str) -> str:     try:         string_split = split_input(text)         if upper:             res_str = \"\".join(                 [                     separator.join([char.upper() for char in sub_str])                     for sub_str in string_split                 ]             )         else:             res_str = \"\".join(                 [                     separator.join([char.lower() for char in sub_str])                     for sub_str in string_split                 ]             )         return res_str     except IndexError:         return \"not valid string\"", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef softplus(vector: np.ndarray) -> np.ndarray:\n    return np.log(1 + np.exp(vector))", "output": "Implements the Softplus activation function."}
{"task": "detection", "input": "classify code:\ndef palindromic_string(input_string: str) -> str:\n    \"\"\"\n    >>> palindromic_string('abbbaba')\n    'abbba'\n    >>> palindromic_string('ababa')\n    'ababa'\n\n    Manacher's algorithm which finds Longest palindromic Substring in linear time.\n\n    1. first this convert input_string(\"xyx\") into new_string(\"x|y|x\") where odd\n        positions are actual input characters.\n    2. for each character in new_string it find corresponding length and\n        store the length and left,right to store previously calculated info.\n        (please look the explanation for details)\n\n    3. return corresponding output_string by removing all \"|\"\n    \"\"\"\n    max_length = 0\n\n    # if input_string is \"aba\" than new_input_string become \"a|b|a\"\n    new_input_string = \"\"\n    output_string = \"\"\n\n    # append each character + \"|\" in new_string for range(0, length-1)\n    for i in input_string[: len(input_string) - 1]:\n        new_input_string += i + \"|\"\n    # append last character\n    new_input_string += input_string[-1]\n\n    # we will store the starting and ending of previous furthest ending palindromic\n    # substring\n    left, right = 0, 0\n\n    # length[i] shows the length of palindromic substring with center i\n    length = [1 for i in range(len(new_input_string))]\n\n    # for each character in new_string find corresponding palindromic string\n    start = 0\n    for j in range(len(new_input_string)):\n        k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)\n        while (\n            j - k >= 0\n            and j + k < len(new_input_string)\n            and new_input_string[k + j] == new_input_string[j - k]\n        ):\n            k += 1\n\n        length[j] = 2 * k - 1\n\n        # does this string is ending after the previously explored end (that is right) ?\n        # if yes the update the new right to the last index of this\n        if j + k - 1 > right:\n            left = j - k + 1\n            right = j + k - 1\n\n        # update max_length and start position\n        if max_length < length[j]:\n            max_length = length[j]\n            start = j\n\n    # create that string\n    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]\n    for i in s:\n        if i != \"|\":\n            output_string += i\n\n    return output_string", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef word_break(string: str, words: list[str]) -> bool:\n\n    # Validation\n    if not isinstance(string, str) or len(string) == 0:\n        raise ValueError(\"the string should be not empty string\")\n\n    if not isinstance(words, list) or not all(\n        isinstance(item, str) and len(item) > 0 for item in words\n    ):\n        raise ValueError(\"the words should be a list of non-empty strings\")\n\n    # Build trie\n    trie: dict[str, Any] = {}\n    word_keeper_key = \"WORD_KEEPER\"\n\n    for word in words:\n        trie_node = trie\n        for c in word:\n            if c not in trie_node:\n                trie_node[c] = {}\n\n            trie_node = trie_node[c]\n\n        trie_node[word_keeper_key] = True\n\n    len_string = len(string)\n\n    # Dynamic programming method\n    @functools.cache\n    def is_breakable(index: int) -> bool:\n        if index == len_string:\n            return True\n\n        trie_node: Any = trie\n        for i in range(index, len_string):\n            trie_node = trie_node.get(string[i], None)\n\n            if trie_node is None:\n                return False\n\n            if trie_node.get(word_keeper_key, False) and is_breakable(i + 1):\n                return True\n\n        return False\n\n    return is_breakable(0)", "output": "Return True if numbers have opposite signs False otherwise."}
{"task": "repair", "input": "fix bug:\ndef approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value", "output": "def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value"}
{"task": "search", "input": "search code:\nInverse Discrete Fourier Transform. *Xarr* is a sequence of\n\nChoices:\n0: def is_valid(barcode: int) -> bool:     return len(str(barcode)) == 13 and get_check_digit(barcode) == barcode % 10\n1: def main():     if len(sys.argv) < 3:         print(\"2 integer arguments required\")         return 1     a = int(sys.argv[1])     b = int(sys.argv[2])     print(extended_euclidean_algorithm(a, b))     return 0\n2: def idft(Xarr):     N = len(Xarr)     roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]     for k in range(N):         coeffs = [roots_of_unity[k * n % N] for n in range(N)]         yield _complex_sumprod(Xarr, coeffs) / N", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef simpson_integration(function, a: float, b: float, precision: int = 4) -> float:\n    assert callable(function), (\n        f\"the function(object) passed should be callable your input : {function}\"\n    )\n    assert isinstance(a, (float, int)), f\"a should be float or integer your input : {a}\"\n    assert isinstance(function(a), (float, int)), (\n        \"the function should return integer or float return type of your function, \"\n        f\"{type(a)}\"\n    )\n    assert isinstance(b, (float, int)), f\"b should be float or integer your input : {b}\"\n    assert isinstance(precision, int) and precision > 0, (\n        f\"precision should be positive integer your input : {precision}\"\n    )\n\n    # just applying the formula of simpson for approximate integration written in\n    # mentioned article in first comment of this file and above this function\n\n    h = (b - a) / N_STEPS\n    result = function(a) + function(b)\n\n    for i in range(1, N_STEPS):\n        a1 = a + h * i\n        result += function(a1) * (4 if i % 2 else 2)\n\n    result *= h / 3\n    return round(result, precision)", "output": "Args:"}
{"task": "summary", "input": "summarize code:\ndef bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:\n    if length > 1:\n        middle = int(length / 2)\n        for i in range(low, low + middle):\n            comp_and_swap(array, i, i + middle, direction)\n        bitonic_merge(array, low, middle, direction)\n        bitonic_merge(array, low + middle, middle, direction)", "output": "It recursively sorts a bitonic sequence in ascending order, if direction = 1, and in"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 600851475143) -> int:\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    prime = 1\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        prime = n\n    return int(prime)", "output": "Returns the largest prime factor of a given number n."}
{"task": "summary", "input": "summarize code:\ndef normalize_image(\n    image: np.ndarray, cap: float = 255.0, data_type: np.dtype = np.uint8\n) -> np.ndarray:\n    normalized = (image - np.min(image)) / (np.max(image) - np.min(image)) * cap\n    return normalized.astype(data_type)", "output": "Normalizes image in Numpy 2D array format, between ranges 0-cap,"}
{"task": "summary", "input": "summarize code:\ndef solution(max_prime: int = 10**6) -> int:\n\n    primes_count = 0\n    cube_index = 1\n    prime_candidate = 7\n    while prime_candidate < max_prime:\n        primes_count += is_prime(prime_candidate)\n\n        cube_index += 1\n        prime_candidate += 6 * cube_index\n\n    return primes_count", "output": "Returns number of primes below max_prime with the property"}
{"task": "detection", "input": "classify code:\ndef get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2", "output": "CORRECT"}
{"task": "search", "input": "search code:\nThis solution is based on the pattern that the successive numbers in the\n\nChoices:\n0: def go_next(i: int, z_result: list[int], s: str) -> bool:     return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]\n1: def elf_hash(data: str) -> int:     hash_ = x = 0     for letter in data:         hash_ = (hash_ << 4) + ord(letter)         x = hash_ & 0xF0000000         if x != 0:             hash_ ^= x >> 24         hash_ &= ~x     return hash_\n2: def solution(n: int = 1000) -> int:      total = 0     num = 0     while 1:         num += 3         if num >= n:             break         total += num         num += 2         if num >= n:             break         total += num         num += 1         if num >= n:             break         total += num         num += 3         if num >= n:             break         total += num         num += 1         if num >= n:             break         total += num         num += 2         if num >= n:             break         total += num         num += 3         if num >= n:             break         total += num     return total", "output": "2"}
{"task": "detection", "input": "classify code:\ndef exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef bubble_sort_recursive(collection: list[Any]) -> list[Any]:\n    length = len(collection)\n    swapped = False\n    for i in range(length - 1):\n        if collection[i] > collection[i + 1]:\n            collection[i], collection[i + 1] = collection[i + 1], collection[i]\n            swapped = True\n\n    return collection if not swapped else bubble_sort_recursive(collection)", "output": "It is similar iterative bubble sort but recursive."}
{"task": "detection", "input": "classify code:\ndef calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    lower = int(input(\"Enter lower value : \").strip())\n    higher = int(input(\"Enter high value : \").strip())\n    guess = int(input(\"Enter value to guess : \").strip())\n    guess_the_number(lower, higher, guess)", "output": "starting point or function of script"}
{"task": "summary", "input": "summarize code:\ndef thousands_separator() -> str:\n    try:\n        sep = _THOUSANDS_SEPARATOR[_CURRENT.locale]\n    except (AttributeError, KeyError):\n        sep = \",\"\n    return sep", "output": "Return the thousands separator for a locale, default to comma."}
{"task": "search", "input": "search code:\nGiven the numerical coefficients a, b and c,\n\nChoices:\n0: def get_bitcode(edge_array, distinct_edge):     bitcode = [\"0\"] * len(edge_array)     for i, row in enumerate(edge_array):         for item in row:             if distinct_edge in item[0]:                 bitcode[i] = \"1\"                 break     return \"\".join(bitcode)\n1: def iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:     vectors = initial_vectors     for _ in range(steps):         vectors = iteration_step(vectors)     return vectors\n2: def quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:      if a == 0:         raise ValueError(\"Coefficient 'a' must not be zero.\")     delta = b * b - 4 * a * c      root_1 = (-b + sqrt(delta)) / (2 * a)     root_2 = (-b - sqrt(delta)) / (2 * a)      return (         root_1.real if not root_1.imag else root_1,         root_2.real if not root_2.imag else root_2,     )", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef get_support(cluster):\n    return [i * 100 / len(cluster) for i in cluster]", "output": "Returns support"}
{"task": "search", "input": "search code:\nOptional method: interquatile range\n\nChoices:\n0: def split_format_str(fstr):     ret = []      for lit, fname, fspec, conv in Formatter().parse(fstr):         if fname is None:             ret.append((lit, None))             continue         field_str = construct_format_field_str(fname, fspec, conv)         ret.append((lit, field_str))     return ret\n1: def create_ngram(sentence: str, ngram_size: int) -> list[str]:     return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]\n2: def interquartile_range_checker(train_user: list) -> float:     train_user.sort()     q1 = np.percentile(train_user, 25)     q3 = np.percentile(train_user, 75)     iqr = q3 - q1     low_lim = q1 - (iqr * 0.1)     return float(low_lim)", "output": "2"}
{"task": "search", "input": "search code:\nCalculate the volume of the intersection of two spheres.\n\nChoices:\n0: def insert_next(collection: list, index: int):     # Checks order between adjacent elements     if index >= len(collection) or collection[index - 1] <= collection[index]:         return      # Swaps adjacent elements since they are not in ascending order     collection[index - 1], collection[index] = (         collection[index],         collection[index - 1],     )      insert_next(collection, index + 1)\n1: def vol_spheres_intersect(     radius_1: float, radius_2: float, centers_distance: float ) -> float:     if radius_1 < 0 or radius_2 < 0 or centers_distance < 0:         raise ValueError(\"vol_spheres_intersect() only accepts non-negative values\")     if centers_distance == 0:         return vol_sphere(min(radius_1, radius_2))      h1 = (         (radius_1 - radius_2 + centers_distance)         * (radius_1 + radius_2 - centers_distance)         / (2 * centers_distance)     )     h2 = (         (radius_2 - radius_1 + centers_distance)         * (radius_2 + radius_1 - centers_distance)         / (2 * centers_distance)     )      return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)\n2: def resistor_series(resistors: list[float]) -> float:     sum_r = 0.00     for index, resistor in enumerate(resistors):         sum_r += resistor         if resistor < 0:             msg = f\"Resistor at index {index} has a negative value!\"             raise ValueError(msg)     return sum_r", "output": "1"}
{"task": "search", "input": "search code:\nFunction checks if the input provided is valid or not.\n\nChoices:\n0: def generate_first_solution(path, dict_of_neighbours):      with open(path) as f:         start_node = f.read(1)     end_node = start_node      first_solution = []      visiting = start_node      distance_of_first_solution = 0     while visiting not in first_solution:         minim = 10000         for k in dict_of_neighbours[visiting]:             if int(k[1]) < int(minim) and k[0] not in first_solution:                 minim = k[1]                 best_node = k[0]          first_solution.append(visiting)         distance_of_first_solution = distance_of_first_solution + int(minim)         visiting = best_node      first_solution.append(end_node)      position = 0     for k in dict_of_neighbours[first_solution[-2]]:         if k[0] == start_node:             break         position += 1      distance_of_first_solution = (         distance_of_first_solution         + int(dict_of_neighbours[first_solution[-2]][position][1])         - 10000     )     return first_solution, distance_of_first_solution\n1: def intersperse(e, iterable, n=1):     if n == 0:         raise ValueError('n must be > 0')     elif n == 1:         # interleave(repeat(e), iterable) -> e, x_0, e, x_1, e, x_2...         # islice(..., 1, None) -> x_0, e, x_1, e, x_2...         return islice(interleave(repeat(e), iterable), 1, None)     else:         # interleave(filler, chunks) -> [e], [x_0, x_1], [e], [x_2, x_3]...         # islice(..., 1, None) -> [x_0, x_1], [e], [x_2, x_3]...         # flatten(...) -> x_0, x_1, e, x_2, x_3...         filler = repeat([e])         chunks = chunked(iterable, n)         return flatten(islice(interleave(filler, chunks), 1, None))\n2: def check_validity(number_of_bands: int, colors: list) -> bool:     if number_of_bands >= 3 and number_of_bands <= 6:         if number_of_bands == len(colors):             for color in colors:                 if color not in valid_colors:                     msg = f\"{color} is not a valid color\"                     raise ValueError(msg)             return True         else:             msg = f\"Expecting {number_of_bands} colors, provided {len(colors)} colors\"             raise ValueError(msg)     else:         msg = \"Invalid number of bands. Resistor bands must be 3 to 6\"         raise ValueError(msg)", "output": "2"}
{"task": "search", "input": "search code:\nGet image rotation\n\nChoices:\n0: def astable_duty_cycle(resistance_1: float, resistance_2: float) -> float:      if resistance_1 <= 0 or resistance_2 <= 0:         raise ValueError(\"All values must be positive\")     return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100\n1: def main():     print(\"Volumes:\")     print(f\"Cube: {vol_cube(2) = }\")  # = 8     print(f\"Cuboid: {vol_cuboid(2, 2, 2) = }\")  # = 8     print(f\"Cone: {vol_cone(2, 2) = }\")  # ~= 1.33     print(f\"Right Circular Cone: {vol_right_circ_cone(2, 2) = }\")  # ~= 8.38     print(f\"Prism: {vol_prism(2, 2) = }\")  # = 4     print(f\"Pyramid: {vol_pyramid(2, 2) = }\")  # ~= 1.33     print(f\"Sphere: {vol_sphere(2) = }\")  # ~= 33.5     print(f\"Hemisphere: {vol_hemisphere(2) = }\")  # ~= 16.75     print(f\"Circular Cylinder: {vol_circular_cylinder(2, 2) = }\")  # ~= 25.1     print(f\"Torus: {vol_torus(2, 2) = }\")  # ~= 157.9     print(f\"Conical Frustum: {vol_conical_frustum(2, 2, 4) = }\")  # ~= 58.6     print(f\"Spherical cap: {vol_spherical_cap(1, 2) = }\")  # ~= 5.24     print(f\"Spheres intersection: {vol_spheres_intersect(2, 2, 1) = }\")  # ~= 21.21     print(f\"Spheres union: {vol_spheres_union(2, 2, 1) = }\")  # ~= 45.81     print(         f\"Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }\"     )  # ~= 28.3     print(f\"Icosahedron: {vol_icosahedron(2.5) = }\")  # ~=34.09\n2: def get_rotation(     img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int ) -> np.ndarray:     matrix = cv2.getAffineTransform(pt1, pt2)     return cv2.warpAffine(img, matrix, (rows, cols))", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef split_after(iterable, pred, maxsplit=-1):\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        buf.append(item)\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                buf = list(it)\n                if buf:\n                    yield buf\n                return\n            buf = []\n            maxsplit -= 1\n    if buf:\n        yield buf", "output": "Yield lists of items from *iterable*, where each list ends with an"}
{"task": "summary", "input": "summarize code:\ndef inverse_document_frequency(df: int, n: int, smoothing=False) -> float:\n    if smoothing:\n        if n == 0:\n            raise ValueError(\"log10(0) is undefined.\")\n        return round(1 + log10(n / (1 + df)), 3)\n\n    if df == 0:\n        raise ZeroDivisionError(\"df must be > 0\")\n    elif n == 0:\n        raise ValueError(\"log10(0) is undefined.\")\n    return round(log10(n / df), 3)", "output": "Return an integer denoting the importance"}
{"task": "search", "input": "search code:\nReturn a shell-escaped string version of *args*, separated by\n\nChoices:\n0: def args2sh(args, sep=' '):     ret_list = []      for arg in args:         if not arg:             ret_list.append(\"''\")             continue         if _find_sh_unsafe(arg) is None:             ret_list.append(arg)             continue         # use single quotes, and put single quotes into double quotes         # the string $'b is then quoted as '$'\"'\"'b'         ret_list.append(\"'\" + arg.replace(\"'\", \"'\\\"'\\\"'\") + \"'\")      return ' '.join(ret_list)\n1: def _construct_hull(     points: list[Point], left: Point, right: Point, convex_set: set[Point] ) -> None:     if points:         extreme_point = None         extreme_point_distance = float(\"-inf\")         candidate_points = []          for p in points:             det = _det(left, right, p)              if det > 0:                 candidate_points.append(p)                  if det > extreme_point_distance:                     extreme_point_distance = det                     extreme_point = p          if extreme_point:             _construct_hull(candidate_points, left, extreme_point, convex_set)             convex_set.add(extreme_point)             _construct_hull(candidate_points, extreme_point, right, convex_set)\n2: def area_trapezium(base1: float, base2: float, height: float) -> float:     if base1 < 0 or base2 < 0 or height < 0:         raise ValueError(\"area_trapezium() only accepts non-negative values\")     return 1 / 2 * (base1 + base2) * height", "output": "0"}
{"task": "search", "input": "search code:\nCalculate the value of accuracy based-on predictions\n\nChoices:\n0: def accuracy(actual_y: list, predicted_y: list) -> float:     # iterate over one element of each list at a time (zip mode)     # prediction is correct if actual Y value equals to predicted Y value     correct = sum(1 for i, j in zip(actual_y, predicted_y) if i == j)     # percentage of accuracy equals to number of correct predictions divided by number     # of all data and multiplied by 100     return (correct / len(actual_y)) * 100\n1: def euler_phi(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = n     for x in set(prime_factors(n)):         s *= (x - 1) / x     return int(s)\n2: def lanczos_iteration(     graph: list[list[int | None]], num_eigenvectors: int ) -> tuple[np.ndarray, np.ndarray]:     num_nodes: int = len(graph)     if not (1 <= num_eigenvectors <= num_nodes):         raise ValueError(             \"Number of eigenvectors must be between 1 and the number of \"             \"nodes in the graph.\"         )      orthonormal_basis: np.ndarray = np.zeros((num_nodes, num_eigenvectors))     tridiagonal_matrix: np.ndarray = np.zeros((num_eigenvectors, num_eigenvectors))      rng = np.random.default_rng()     initial_vector: np.ndarray = rng.random(num_nodes)     initial_vector /= np.sqrt(np.dot(initial_vector, initial_vector))     orthonormal_basis[:, 0] = initial_vector      prev_beta: float = 0.0     for iter_index in range(num_eigenvectors):         result_vector: np.ndarray = multiply_matrix_vector(             graph, orthonormal_basis[:, iter_index]         )         if iter_index > 0:             result_vector -= prev_beta * orthonormal_basis[:, iter_index - 1]         alpha_value: float = np.dot(orthonormal_basis[:, iter_index], result_vector)         result_vector -= alpha_value * orthonormal_basis[:, iter_index]          prev_beta = np.sqrt(np.dot(result_vector, result_vector))         if iter_index < num_eigenvectors - 1 and prev_beta > 1e-10:             orthonormal_basis[:, iter_index + 1] = result_vector / prev_beta         tridiagonal_matrix[iter_index, iter_index] = alpha_value         if iter_index < num_eigenvectors - 1:             tridiagonal_matrix[iter_index, iter_index + 1] = prev_beta             tridiagonal_matrix[iter_index + 1, iter_index] = prev_beta     return tridiagonal_matrix, orthonormal_basis", "output": "0"}
{"task": "detection", "input": "classify code:\ndef p_series(nth_term: int | float | str, power: int | float | str) -> list[str]:\n    \"\"\"\n    Pure Python implementation of P-Series algorithm\n    :return: The P-Series starting from 1 to last (nth) term\n    Examples:\n    >>> p_series(5, 2)\n    ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']\n    >>> p_series(\"\", 1000)\n    ['']\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    ['1']\n    \"\"\"\n    if nth_term == \"\":\n        return [\"\"]\n    nth_term = int(nth_term)\n    power = int(power)\n    series: list[str] = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")\n    return series", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef coulombs_law(q1: float, q2: float, radius: float) -> float:\n    \"\"\"\n    Calculate the electrostatic force of attraction or repulsion\n    between two point charges\n\n    >>> coulombs_law(15.5, 20, 15)\n    12382849136.06\n    >>> coulombs_law(1, 15, 5)\n    5392531075.38\n    >>> coulombs_law(20, -50, 15)\n    -39944674632.44\n    >>> coulombs_law(-5, -8, 10)\n    3595020716.92\n    >>> coulombs_law(50, 100, 50)\n    17975103584.6\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef _norm_args_notimplemented(other):\n    if type(other) in (set, frozenset):\n        inc, exc = other, None\n    elif type(other) is _ComplementSet:\n        inc, exc = other._included, other._excluded\n    else:\n        return NotImplemented, None\n    return inc, exc", "output": "normalize args and return NotImplemented (for overloaded operators)"}
{"task": "search", "input": "search code:\nFetches a particular translation.\n\nChoices:\n0: def dis_between_closest_in_strip(points, points_counts, min_dis=float(\"inf\")):      for i in range(min(6, points_counts - 1), points_counts):         for j in range(max(0, i - 6), i):             current_dis = euclidean_distance_sqr(points[i], points[j])             min_dis = min(min_dis, current_dis)     return min_dis\n1: def get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:     coefficients = {1}     previous_coefficients = [1]     for _ in range(2, depth + 1):         coefficients_begins_one = [*previous_coefficients, 0]         coefficients_ends_one = [0, *previous_coefficients]         previous_coefficients = []         for x, y in zip(coefficients_begins_one, coefficients_ends_one):             coefficients.add(x + y)             previous_coefficients.append(x + y)     return coefficients\n2: def _pgettext(msgctxt, message):     # This GNU gettext function was added in Python 3.8, so for older versions we     # reimplement it. It works by joining `msgctx` and `message` by '4' byte.     try:         # Python 3.8+         return get_translation().pgettext(msgctxt, message)     except AttributeError:         # Python 3.7 and older         key = msgctxt + \"\\x04\" + message         translation = get_translation().gettext(key)         return message if translation == key else translation", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    return next(i for i in triangle_number_generator() if count_divisors(i) > 500)", "output": "Returns the value of the first triangle number to have over five hundred"}
{"task": "detection", "input": "classify code:\ndef surface_area_cube(side_length: float) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * side_length ** 2\r", "output": "CORRECT"}
{"task": "search", "input": "search code:\nEquivalent to\n\nChoices:\n0: def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:     result = [0] * (gon_side * 3)     result[0:3] = perm[0:3]     perm.append(perm[1])      magic_number = 1 if gon_side < 5 else 2      for i in range(1, len(perm) // 3 + magic_number):         result[3 * i] = perm[2 * i + 1]         result[3 * i + 1] = result[3 * i - 1]         result[3 * i + 2] = perm[2 * i + 2]      return result\n1: def nth_combination_with_replacement(iterable, r, index):     pool = tuple(iterable)     n = len(pool)     if (r < 0) or (r > n):         raise ValueError      c = comb(n + r - 1, r)      if index < 0:         index += c      if (index < 0) or (index >= c):         raise IndexError      result = []     i = 0     while r:         r -= 1         while n >= 0:             num_combs = comb(n + r - 1, r)             if index < num_combs:                 break             n -= 1             i += 1             index -= num_combs         result.append(pool[i])      return tuple(result)\n2: def alternative_string_arrange(first_str: str, second_str: str) -> str:     first_str_length: int = len(first_str)     second_str_length: int = len(second_str)     abs_length: int = (         first_str_length if first_str_length > second_str_length else second_str_length     )     output_list: list = []     for char_count in range(abs_length):         if char_count < first_str_length:             output_list.append(first_str[char_count])         if char_count < second_str_length:             output_list.append(second_str[char_count])     return \"\".join(output_list)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True", "output": "CORRECT"}
{"task": "search", "input": "search code:\nTakes in an integer n and returns a n-bit\n\nChoices:\n0: def multiply(     chain: list[int],     primes: list[int],     min_prime_idx: int,     prev_num: int,     max_num: int,     prev_sum: int,     primes_degrees: dict[int, int], ) -> None:      min_prime = primes[min_prime_idx]     num = prev_num * min_prime      min_prime_degree = primes_degrees.get(min_prime, 0)     min_prime_degree += 1     primes_degrees[min_prime] = min_prime_degree      new_sum = prev_sum * min_prime + (prev_sum + prev_num) * (min_prime - 1) // (         min_prime**min_prime_degree - 1     )     chain[num] = new_sum      for prime_idx in range(min_prime_idx, len(primes)):         if primes[prime_idx] * num > max_num:             break          multiply(             chain=chain,             primes=primes,             min_prime_idx=prime_idx,             prev_num=num,             max_num=max_num,             prev_sum=new_sum,             primes_degrees=primes_degrees.copy(),         )\n1: def random_vector(n: int, a: int, b: int) -> Vector:     random.seed(None)     ans = [random.randint(a, b) for _ in range(n)]     return Vector(ans)\n2: def gray_code(bit_count: int) -> list:      # bit count represents no. of bits in the gray code     if bit_count < 0:         raise ValueError(\"The given input must be positive\")      # get the generated string sequence     sequence = gray_code_sequence_string(bit_count)     #     # convert them to integers     for i in range(len(sequence)):         sequence[i] = int(sequence[i], 2)      return sequence", "output": "2"}
{"task": "search", "input": "search code:\nReturn ``start``, ``func(start)``, ``func(func(start))``, ...\n\nChoices:\n0: def iterate(func, start):     with suppress(StopIteration):         while True:             yield start             start = func(start)\n1: def matrix_pow_np(m: ndarray, power: int) -> ndarray:     result = np.array([[1, 0], [0, 1]], dtype=int)  # Identity Matrix     base = m     if power < 0:  # Negative power is not allowed         raise ValueError(\"power is negative\")     while power:         if power % 2 == 1:             result = np.dot(result, base)         base = np.dot(base, base)         power //= 2     return result\n2: def sentinel_linear_search(sequence, target):     sequence.append(target)      index = 0     while sequence[index] != target:         index += 1      sequence.pop()      if index == len(sequence):         return None      return index", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef dutch_national_flag_sort(sequence: list) -> list:\n    if not sequence:\n        return []\n    if len(sequence) == 1:\n        return list(sequence)\n    low = 0\n    high = len(sequence) - 1\n    mid = 0\n    while mid <= high:\n        if sequence[mid] == colors[0]:\n            sequence[low], sequence[mid] = sequence[mid], sequence[low]\n            low += 1\n            mid += 1\n        elif sequence[mid] == colors[1]:\n            mid += 1\n        elif sequence[mid] == colors[2]:\n            sequence[mid], sequence[high] = sequence[high], sequence[mid]\n            high -= 1\n        else:\n            msg = f\"The elements inside the sequence must contains only {colors} values\"\n            raise ValueError(msg)\n    return sequence", "output": "A pure Python implementation of Dutch National Flag sort algorithm."}
{"task": "search", "input": "search code:\nA pure Python implementation of quicksort algorithm.\n\nChoices:\n0: def solution() -> int:     return compute_nums(1)[0]\n1: def quick_sort(collection: list) -> list:     # Base case: if the collection has 0 or 1 elements, it is already sorted     if len(collection) < 2:         return collection      # Randomly select a pivot index and remove the pivot element from the collection     pivot_index = randrange(len(collection))     pivot = collection.pop(pivot_index)      # Partition the remaining elements into two groups: lesser or equal, and greater     lesser = [item for item in collection if item <= pivot]     greater = [item for item in collection if item > pivot]      # Recursively sort the lesser and greater groups, and combine with the pivot     return [*quick_sort(lesser), pivot, *quick_sort(greater)]\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_significant_digits(colors: list) -> str:\n    digit = \"\"\n    for color in colors:\n        if color not in significant_figures_color_values:\n            msg = f\"{color} is not a valid color for significant figure bands\"\n            raise ValueError(msg)\n        digit = digit + str(significant_figures_color_values[color])\n    return str(digit)", "output": "Function returns the digit associated with the color. Function takes a"}
{"task": "detection", "input": "classify code:\ndef molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\n    \"\"\"\n    Convert molarity to normality.\n      Volume is taken in litres.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n      >>> molarity_to_normality(2, 3.1, 0.31)\n      20\n      >>> molarity_to_normality(4, 11.4, 5.7)\n      8\n    \"\"\"\n    return round(float(moles / volume) * nfactor)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(min_total: int = 10**12) -> int:\n\n    prev_numerator = 1\n    prev_denominator = 0\n\n    numerator = 1\n    denominator = 1\n\n    while numerator <= 2 * min_total - 1:\n        prev_numerator += 2 * numerator\n        numerator += 2 * prev_numerator\n\n        prev_denominator += 2 * denominator\n        denominator += 2 * prev_denominator\n\n    return (denominator + 1) // 2", "output": "Returns the number of blue discs for the first arrangement to contain"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 50) -> int:\n    return sum(\n        1\n        for pt1, pt2 in combinations(product(range(limit + 1), repeat=2), 2)\n        if is_right(*pt1, *pt2)\n    )", "output": "Return the number of right triangles OPQ that can be formed by two points P, Q"}
{"task": "summary", "input": "summarize code:\ndef get_subreddit_data(\n    subreddit: str, limit: int = 1, age: str = \"new\", wanted_data: list | None = None\n) -> dict:\n    wanted_data = wanted_data or []\n    if invalid_search_terms := \", \".join(sorted(set(wanted_data) - valid_terms)):\n        msg = f\"Invalid search term: {invalid_search_terms}\"\n        raise ValueError(msg)\n    response = httpx.get(\n        f\"https://www.reddit.com/r/{subreddit}/{age}.json?limit={limit}\",\n        headers={\"User-agent\": \"A random string\"},\n        timeout=10,\n    )\n    response.raise_for_status()\n    if response.status_code == 429:\n        raise httpx.HTTPError(response=response)\n\n    data = response.json()\n    if not wanted_data:\n        return {id_: data[\"data\"][\"children\"][id_] for id_ in range(limit)}\n\n    data_dict = {}\n    for id_ in range(limit):\n        data_dict[id_] = {\n            item: data[\"data\"][\"children\"][id_][\"data\"][item] for item in wanted_data\n        }\n    return data_dict", "output": "subreddit : Subreddit to query"}
{"task": "search", "input": "search code:\nTo optimize the approach, we will rule out the numbers above 1000,\n\nChoices:\n0: def iter_index(iterable, value, start=0, stop=None):     seq_index = getattr(iterable, 'index', None)     if seq_index is None:         # Slow path for general iterables         iterator = islice(iterable, start, stop)         for i, element in enumerate(iterator, start):             if element is value or element == value:                 yield i     else:         # Fast path for sequences         stop = len(iterable) if stop is None else stop         i = start - 1         with suppress(ValueError):             while True:                 yield (i := seq_index(value, i + 1, stop))\n1: def validate(n: int) -> bool:     return not (         len(str(n)) > 3         and (not is_prime(int(str(n)[-3:])) or not is_prime(int(str(n)[:3])))     )\n2: def doublestarmap(func, iterable):     for item in iterable:         yield func(**item)", "output": "1"}
{"task": "search", "input": "search code:\nvalidates an input instance before a convex-hull algorithms uses it\n\nChoices:\n0: def find_python_set(node: Node) -> set:     sets = ({0, 1, 2}, {3, 4, 5})     for s in sets:         if node.data in s:             return s     msg = f\"{node.data} is not in {sets}\"     raise ValueError(msg)\n1: def _validate_input(points: list[Point] | list[list[float]]) -> list[Point]:      if not hasattr(points, \"__iter__\"):         msg = f\"Expecting an iterable object but got an non-iterable type {points}\"         raise ValueError(msg)      if not points:         msg = f\"Expecting a list of points but got {points}\"         raise ValueError(msg)      return _construct_points(points)\n2: def main(     cities: dict[int, list[int]],     ants_num: int,     iterations_num: int,     pheromone_evaporation: float,     alpha: float,     beta: float,     q: float,  # Pheromone system parameters Q, which is a constant ) -> tuple[list[int], float]:     # Initialize the pheromone matrix     cities_num = len(cities)     pheromone = [[1.0] * cities_num] * cities_num      best_path: list[int] = []     best_distance = float(\"inf\")     for _ in range(iterations_num):         ants_route = []         for _ in range(ants_num):             unvisited_cities = copy.deepcopy(cities)             current_city = {next(iter(cities.keys())): next(iter(cities.values()))}             del unvisited_cities[next(iter(current_city.keys()))]             ant_route = [next(iter(current_city.keys()))]             while unvisited_cities:                 current_city, unvisited_cities = city_select(                     pheromone, current_city, unvisited_cities, alpha, beta                 )                 ant_route.append(next(iter(current_city.keys())))             ant_route.append(0)             ants_route.append(ant_route)          pheromone, best_path, best_distance = pheromone_update(             pheromone,             cities,             pheromone_evaporation,             ants_route,             q,             best_path,             best_distance,         )     return best_path, best_distance", "output": "1"}
{"task": "search", "input": "search code:\nReturns the sum of the perimeters of all almost equilateral triangles with integral\n\nChoices:\n0: def inorder(curr_node: Node | None) -> list[Node]:     node_list = []     if curr_node is not None:         node_list = [*inorder(curr_node.left), curr_node, *inorder(curr_node.right)]     return node_list\n1: def solution(n: int = 20) -> int:      g = 1     for i in range(1, n + 1):         g = lcm(g, i)     return g\n2: def solution(max_perimeter: int = 10**9) -> int:      prev_value = 1     value = 2      perimeters_sum = 0     i = 0     perimeter = 0     while perimeter <= max_perimeter:         perimeters_sum += perimeter          prev_value += 2 * value         value += prev_value          perimeter = 2 * value + 2 if i % 2 == 0 else 2 * value - 2         i += 1      return perimeters_sum", "output": "2"}
{"task": "detection", "input": "classify code:\ndef is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n    Note: this doesn't check if P and Q are equal, but that's handled by the use of\n    itertools.combinations in the solution function.\n\n    >>> is_right(0, 1, 2, 0)\n    True\n    >>> is_right(1, 0, 2, 2)\n    False\n    \"\"\"\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef quick_select(arr: list, target: int) -> int:\n\n    # Invalid Input\n    if target > len(arr):\n        return -1\n\n    # x is the estimated pivot by median of medians algorithm\n    x = median_of_medians(arr)\n    left = []\n    right = []\n    check = False\n    for i in range(len(arr)):\n        if arr[i] < x:\n            left.append(arr[i])\n        elif arr[i] > x:\n            right.append(arr[i])\n        elif arr[i] == x and not check:\n            check = True\n        else:\n            right.append(arr[i])\n    rank_x = len(left) + 1\n    if rank_x == target:\n        answer = x\n    elif rank_x > target:\n        answer = quick_select(left, target)\n    elif rank_x < target:\n        answer = quick_select(right, target - rank_x)\n    return answer", "output": "Two way partition the data into smaller and greater lists,"}
{"task": "search", "input": "search code:\nMain function to create and simplify a K-Map.\n\nChoices:\n0: def main() -> None:     kmap = [[0, 1], [1, 1]]      # Manually generate the product of [0, 1] and [0, 1]      for row in kmap:         print(row)      print(\"Simplified Expression:\")     print(simplify_kmap(kmap))\n1: def bisection(function: Callable[[float], float], a: float, b: float) -> float:     start: float = a     end: float = b     if function(a) == 0:  # one of the a or b is a root for the function         return a     elif function(b) == 0:         return b     elif (         function(a) * function(b) > 0     ):  # if none of these are root and they are both positive or negative,         # then this algorithm can't find the root         raise ValueError(\"could not find root in given interval.\")     else:         mid: float = start + (end - start) / 2.0         while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7             if function(mid) == 0:                 return mid             elif function(mid) * function(start) < 0:                 end = mid             else:                 start = mid             mid = start + (end - start) / 2.0         return mid\n2: def area_rectangle(length: float, width: float) -> float:     if length < 0 or width < 0:         raise ValueError(\"area_rectangle() only accepts non-negative values\")     return length * width", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef get_distinct_edge(edge_array):\n    distinct_edge = set()\n    for row in edge_array:\n        for item in row:\n            distinct_edge.add(item[0])\n    return list(distinct_edge)", "output": "Return Distinct edges from edge array of multiple graphs"}
{"task": "search", "input": "search code:\nChecks for length of barcode and last-digit\n\nChoices:\n0: def dis_between_closest_in_strip(points, points_counts, min_dis=float(\"inf\")):      for i in range(min(6, points_counts - 1), points_counts):         for j in range(max(0, i - 6), i):             current_dis = euclidean_distance_sqr(points[i], points[j])             min_dis = min(min_dis, current_dis)     return min_dis\n1: def solution(length: int = 50) -> int:      ways_number = [1] * (length + 1)      for row_length in range(3, length + 1):         for block_length in range(3, row_length + 1):             for block_start in range(row_length - block_length):                 ways_number[row_length] += ways_number[                     row_length - block_start - block_length - 1                 ]              ways_number[row_length] += 1      return ways_number[length]\n2: def is_valid(barcode: int) -> bool:     return len(str(barcode)) == 13 and get_check_digit(barcode) == barcode % 10", "output": "2"}
{"task": "detection", "input": "classify code:\ndef rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef harmonic_series(n_term: str) -> list:\n    \"\"\"Pure Python implementation of Harmonic Series algorithm\n\n    :param n_term: The last (nth) term of Harmonic Series\n    :return: The Harmonic Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> harmonic_series(5)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.0)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.1)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(-5)\n    []\n    >>> harmonic_series(0)\n    []\n    >>> harmonic_series(1)\n    ['1']\n    \"\"\"\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)"}
{"task": "summary", "input": "summarize code:\ndef avg_speed_of_molecule(temperature: float, molar_mass: float) -> float:\n\n    if temperature < 0:\n        raise Exception(\"Absolute temperature cannot be less than 0 K\")\n    if molar_mass <= 0:\n        raise Exception(\"Molar mass should be greater than 0 kg/mol\")\n    return (8 * R * temperature / (pi * molar_mass)) ** 0.5", "output": "Takes the temperature (in K) and molar mass (in kg/mol) of a gas"}
{"task": "detection", "input": "classify code:\ndef to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef column_based_sort(array, column=0):\n    \"\"\"\n    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\n    [(3, 0), (5, 1), (4, 2)]\n    \"\"\"\n    return sorted(array, key=lambda x: x[column])", "output": "def column_based_sort(array, column=0):\n    \"\"\"\n    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\n    [(3, 0), (5, 1), (4, 2)]\n    \"\"\"\n    return sorted(array, key=lambda x: x[column])"}
{"task": "summary", "input": "summarize code:\ndef print_binary_search_tree(root, key, i, j, parent, is_left):\n    if i > j or i < 0 or j > len(root) - 1:\n        return\n\n    node = root[i][j]\n    if parent == -1:  # root does not have a parent\n        print(f\"{key[node]} is the root of the binary search tree.\")\n    elif is_left:\n        print(f\"{key[node]} is the left child of key {parent}.\")\n    else:\n        print(f\"{key[node]} is the right child of key {parent}.\")\n\n    print_binary_search_tree(root, key, i, node - 1, key[node], True)\n    print_binary_search_tree(root, key, node + 1, j, key[node], False)", "output": "Recursive function to print a BST from a root table."}
{"task": "repair", "input": "fix bug:\ndef text_to_bits(text, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_to_bits(\"msg\")\n    '011011010111001101100111'\n    \"\"\"\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \"big\"))[2:]\n    return bits.zfill(8 * ((len(bits) + 7) // 8))", "output": "def text_to_bits(text, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_to_bits(\"msg\")\n    '011011010111001101100111'\n    \"\"\"\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \"big\"))[2:]\n    return bits.zfill(8 * ((len(bits) + 7) // 8))"}
{"task": "search", "input": "search code:\nFunction to merge all the files with optimum cost\n\nChoices:\n0: def optimal_merge_pattern(files: list) -> float:     optimal_merge_cost = 0     while len(files) > 1:         temp = 0         # Consider two files with minimum cost to be merged         for _ in range(2):             min_index = files.index(min(files))             temp += files[min_index]             files.pop(min_index)         files.append(temp)         optimal_merge_cost += temp     return optimal_merge_cost\n1: def chunked(src, size, count=None, **kw):     chunk_iter = chunked_iter(src, size, **kw)     if count is None:         return list(chunk_iter)     else:         return list(itertools.islice(chunk_iter, count))\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "0"}
{"task": "detection", "input": "classify code:\ndef reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef carrier_concentration(\n    electron_conc: float,\n    hole_conc: float,\n    intrinsic_conc: float,\n) -> tuple:\n    if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif electron_conc < 0:\n        raise ValueError(\"Electron concentration cannot be negative in a semiconductor\")\n    elif hole_conc < 0:\n        raise ValueError(\"Hole concentration cannot be negative in a semiconductor\")\n    elif intrinsic_conc < 0:\n        raise ValueError(\n            \"Intrinsic concentration cannot be negative in a semiconductor\"\n        )\n    elif electron_conc == 0:\n        return (\n            \"electron_conc\",\n            intrinsic_conc**2 / hole_conc,\n        )\n    elif hole_conc == 0:\n        return (\n            \"hole_conc\",\n            intrinsic_conc**2 / electron_conc,\n        )\n    elif intrinsic_conc == 0:\n        return (\n            \"intrinsic_conc\",\n            (electron_conc * hole_conc) ** 0.5,\n        )\n    else:\n        return (-1, -1)", "output": "This function can calculate any one of the three -"}
{"task": "search", "input": "search code:\nReturns the number of ways a row of the given length can be filled\n\nChoices:\n0: def encipher(message: str, cipher_map: dict[str, str]) -> str:     return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())\n1: def solution(length: int = 50) -> int:      ways_number = [1] * (length + 1)      for row_length in range(3, length + 1):         for block_length in range(3, row_length + 1):             for block_start in range(row_length - block_length):                 ways_number[row_length] += ways_number[                     row_length - block_start - block_length - 1                 ]              ways_number[row_length] += 1      return ways_number[length]\n2: def concave_triangle_area(circles_number: int) -> float:      intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (         2 * (circles_number**2 + 1)     )     intersection_x = circles_number * intersection_y      triangle_area = intersection_x * intersection_y / 2     concave_region_area = circle_bottom_arc_integral(         1 / 2     ) - circle_bottom_arc_integral(intersection_x)      return triangle_area + concave_region_area", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef decimal_to_negative_base_2(num: int) -> int:\n    \"\"\"\n    This function returns the number negative base 2\n        of the decimal number of the input data.\n\n    Args:\n        int: The decimal number to convert.\n\n    Returns:\n        int: The negative base 2 number.\n\n    Examples:\n        >>> decimal_to_negative_base_2(0)\n        0\n        >>> decimal_to_negative_base_2(-19)\n        111101\n        >>> decimal_to_negative_base_2(4)\n        100\n        >>> decimal_to_negative_base_2(7)\n        11011\n    \"\"\"\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)", "output": "def decimal_to_negative_base_2(num: int) -> int:\n    \"\"\"\n    This function returns the number negative base 2\n        of the decimal number of the input data.\n\n    Args:\n        int: The decimal number to convert.\n\n    Returns:\n        int: The negative base 2 number.\n\n    Examples:\n        >>> decimal_to_negative_base_2(0)\n        0\n        >>> decimal_to_negative_base_2(-19)\n        111101\n        >>> decimal_to_negative_base_2(4)\n        100\n        >>> decimal_to_negative_base_2(7)\n        11011\n    \"\"\"\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)"}
{"task": "summary", "input": "summarize code:\ndef find_lanczos_eigenvectors(\n    graph: list[list[int | None]], num_eigenvectors: int\n) -> tuple[np.ndarray, np.ndarray]:\n    validate_adjacency_list(graph)\n    tridiagonal_matrix, orthonormal_basis = lanczos_iteration(graph, num_eigenvectors)\n    eigenvalues, eigenvectors = np.linalg.eigh(tridiagonal_matrix)\n    return eigenvalues[::-1], np.dot(orthonormal_basis, eigenvectors[:, ::-1])", "output": "Computes the largest eigenvalues and their corresponding eigenvectors using the"}
{"task": "search", "input": "search code:\nMarkdown prefix based on indent for bullet points\n\nChoices:\n0: def md_prefix(indent: int) -> str:     return f\"{indent * '  '}*\" if indent else \"\\n##\"\n1: def decompress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         lexicon[curr_string] = last_match_id + \"0\"          if math.log2(index).is_integer():             new_lex = {}             for curr_key in list(lexicon):                 new_lex[\"0\" + curr_key] = lexicon.pop(curr_key)             lexicon = new_lex          lexicon[bin(index)[2:]] = last_match_id + \"1\"         index += 1         curr_string = \"\"     return result\n2: def get_files_url() -> str:     with open(os.environ[\"GITHUB_EVENT_PATH\"]) as file:         event = json.load(file)     return event[\"pull_request\"][\"url\"] + \"/files\"", "output": "0"}
{"task": "detection", "input": "classify code:\ndef pancake_sort(arr):\n    \"\"\"Sort Array with Pancake Sort.\n    :param arr: Collection containing comparable items\n    :return: Collection ordered in ascending order of items\n    Examples:\n    >>> pancake_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pancake_sort([])\n    []\n    >>> pancake_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    cur = len(arr)\n    while cur > 1:\n        # Find the maximum number in arr\n        mi = arr.index(max(arr[0:cur]))\n        # Reverse from 0 to mi\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\n        # Reverse whole list\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\n        cur -= 1\n    return arr", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef patience_sort(collection: list) -> list:\n    stacks: list[Stack] = []\n    # sort into stacks\n    for element in collection:\n        new_stacks = Stack([element])\n        i = bisect_left(stacks, new_stacks)\n        if i != len(stacks):\n            stacks[i].append(element)\n        else:\n            stacks.append(new_stacks)\n\n    # use a heap-based merge to merge stack efficiently\n    collection[:] = merge(*(reversed(stack) for stack in stacks))\n    return collection", "output": "A pure implementation of patience sort algorithm in Python"}
{"task": "summary", "input": "summarize code:\ndef inorder(root: Node | None) -> None:\n    if not root:  # None\n        return\n    else:\n        inorder(root.left)\n        print(root.value, end=\",\")\n        inorder(root.right)", "output": "Just recursive print of a tree"}
{"task": "summary", "input": "summarize code:\ndef color(graph: list[list[int]], max_colors: int) -> list[int]:\n    colored_vertices = [-1] * len(graph)\n\n    if util_color(graph, max_colors, colored_vertices, 0):\n        return colored_vertices\n\n    return []", "output": "Wrapper function to call subroutine called util_color"}
{"task": "detection", "input": "classify code:\ndef count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    Calculates force from `mass` and `acceleration`\n\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force", "output": "def newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    Calculates force from `mass` and `acceleration`\n\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force"}
{"task": "search", "input": "search code:\nCalculate the waiting times of a list of processes that have a specified duration.\n\nChoices:\n0: def get_filter_points(     sample_rate: int,     freq_min: int,     freq_high: int,     mel_filter_num: int = 10,     ftt_size: int = 1024, ) -> tuple[np.ndarray, np.ndarray]:     # Convert minimum and maximum frequencies to mel scale     fmin_mel = freq_to_mel(freq_min)     fmax_mel = freq_to_mel(freq_high)      logging.info(f\"MEL min: {fmin_mel}\")     logging.info(f\"MEL max: {fmax_mel}\")      # Generate equally spaced mel frequencies     mels = np.linspace(fmin_mel, fmax_mel, num=mel_filter_num + 2)      # Convert mel frequencies back to Hertz     freqs = mel_to_freq(mels)      # Calculate filter points as integer values     filter_points = np.floor((ftt_size + 1) / sample_rate * freqs).astype(int)      return filter_points, freqs\n1: def calculate_waiting_times(burst_times: list[int]) -> list[int]:     quantum = 2     rem_burst_times = list(burst_times)     waiting_times = [0] * len(burst_times)     t = 0     while True:         done = True         for i, burst_time in enumerate(burst_times):             if rem_burst_times[i] > 0:                 done = False                 if rem_burst_times[i] > quantum:                     t += quantum                     rem_burst_times[i] -= quantum                 else:                     t += rem_burst_times[i]                     waiting_times[i] = t - burst_time                     rem_burst_times[i] = 0         if done is True:             return waiting_times\n2: def circular_shifts(iterable, steps=1):     buffer = deque(iterable)     if steps == 0:         raise ValueError('Steps should be a non-zero integer')      buffer.rotate(steps)     steps = -steps     n = len(buffer)     n //= math.gcd(n, steps)      for _ in repeat(None, n):         buffer.rotate(steps)         yield tuple(buffer)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef polar_force(\n    magnitude: float, angle: float, radian_mode: bool = False\n) -> list[float]:\n    if radian_mode:\n        return [magnitude * cos(angle), magnitude * sin(angle)]\n    return [magnitude * cos(radians(angle)), magnitude * sin(radians(angle))]", "output": "Resolves force along rectangular components."}
{"task": "search", "input": "search code:\nGenerate numbers in lexical order from 1 to max_number.\n\nChoices:\n0: def kmeans(     data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False ):     centroids = initial_centroids[:]     prev_cluster_assignment = None      for itr in range(maxiter):         if verbose:             print(itr, end=\"\")          # 1. Make cluster assignments using nearest centroids         cluster_assignment = assign_clusters(data, centroids)          # 2. Compute a new centroid for each of the k clusters, averaging all data         #    points assigned to that cluster.         centroids = revise_centroids(data, k, cluster_assignment)          # Check for convergence: if none of the assignments changed, stop         if (             prev_cluster_assignment is not None             and (prev_cluster_assignment == cluster_assignment).all()         ):             break          # Print number of new assignments         if prev_cluster_assignment is not None:             num_changed = np.sum(prev_cluster_assignment != cluster_assignment)             if verbose:                 print(                     f\"    {num_changed:5d} elements changed their cluster assignment.\"                 )          # Record heterogeneity convergence metric         if record_heterogeneity is not None:             # YOUR CODE HERE             score = compute_heterogeneity(data, k, centroids, cluster_assignment)             record_heterogeneity.append(score)          prev_cluster_assignment = cluster_assignment[:]      return centroids, cluster_assignment\n1: def capture_radii(     target_body_radius: float, target_body_mass: float, projectile_velocity: float ) -> float:      if target_body_mass < 0:         raise ValueError(\"Mass cannot be less than 0\")     if target_body_radius < 0:         raise ValueError(\"Radius cannot be less than 0\")     if projectile_velocity > c:         raise ValueError(\"Cannot go beyond speed of light\")      escape_velocity_squared = (2 * G * target_body_mass) / target_body_radius     capture_radius = target_body_radius * sqrt(         1 + escape_velocity_squared / pow(projectile_velocity, 2)     )     return round(capture_radius, 0)\n2: def lexical_order(max_number: int) -> Iterator[int]:      stack = [1]      while stack:         num = stack.pop()         if num > max_number:             continue          yield num         if (num % 10) != 9:             stack.append(num + 1)          stack.append(num * 10)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solve(nums: list[int], goal: int, depth: int) -> bool:\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False", "output": "Checks if nums can have a sum equal to goal, given that length of nums does"}
{"task": "search", "input": "search code:\nIt is similar iterative bubble sort but recursive.\n\nChoices:\n0: def postorder(root: Node | None) -> Generator[int]:     if not root:         return     yield from postorder(root.left)     yield from postorder(root.right)     yield root.data\n1: def solution() -> int:     return compute_nums(1)[0]\n2: def bubble_sort_recursive(collection: list[Any]) -> list[Any]:     length = len(collection)     swapped = False     for i in range(length - 1):         if collection[i] > collection[i + 1]:             collection[i], collection[i + 1] = collection[i + 1], collection[i]             swapped = True      return collection if not swapped else bubble_sort_recursive(collection)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef choose(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n    >>> choose(4,2)\n    6\n    >>> choose(5,3)\n    10\n    >>> choose(20,6)\n    38760\n    \"\"\"\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)", "output": "def choose(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n    >>> choose(4,2)\n    6\n    >>> choose(5,3)\n    10\n    >>> choose(20,6)\n    38760\n    \"\"\"\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)"}
{"task": "detection", "input": "classify code:\ndef digit_sum(n: int) -> int:\n    \"\"\"\n    Returns the sum of the digits of the number.\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(456)\n    15\n    >>> digit_sum(78910)\n    25\n    \"\"\"\n    return sum(int(digit) for digit in str(n))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nAutomatic generate random 32 characters.\n\nChoices:\n0: def find_median(nums: list[int | float]) -> float:     div, mod = divmod(len(nums), 2)     if mod:         return nums[div]     return (nums[div] + nums[(div) - 1]) / 2\n1: def all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:      word_bank = word_bank or []     # create a table     table_size: int = len(target) + 1      table: list[list[list[str]]] = []     for _ in range(table_size):         table.append([])     # seed value     table[0] = [[]]  # because empty string has empty combination      # iterate through the indices     for i in range(table_size):         # condition         if table[i] != []:             for word in word_bank:                 # slice condition                 if target[i : i + len(word)] == word:                     new_combinations: list[list[str]] = [                         [word, *way] for way in table[i]                     ]                     # adds the word to every combination the current position holds                     # now,push that combination to the table[i+len(word)]                     table[i + len(word)] += new_combinations      # combinations are in reverse order so reverse for better output     for combination in table[len(target)]:         combination.reverse()      return table[len(target)]\n2: def random_chars(number_char: int) -> str:     assert number_char > 1, \"The number of character should greater than 1\"     letter_code = ascii_lowercase + digits     return \"\".join(random.choice(letter_code) for _ in range(number_char))", "output": "2"}
{"task": "detection", "input": "classify code:\ndef extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef abbr(a: str, b: str) -> bool:\n    \"\"\"\n    >>> abbr(\"daBcd\", \"ABC\")\n    True\n    >>> abbr(\"dBcd\", \"ABC\")\n    False\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m + 1):\n            if dp[i][j]:\n                if j < m and a[i].upper() == b[j]:\n                    dp[i + 1][j + 1] = True\n                if a[i].islower():\n                    dp[i + 1][j] = True\n    return dp[n][m]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFind the sum of the FITs of the BOPS. For each interpolating polynomial of order\n\nChoices:\n0: def solution(power: int = 1000) -> int:     n = 2**power     r = 0     while n:         r, n = r + n % 10, n // 10     return r\n1: def solution(func: Callable[[int], int] = question_function, order: int = 10) -> int:     data_points: list[int] = [func(x_val) for x_val in range(1, order + 1)]      polynomials: list[Callable[[int], int]] = [         interpolate(data_points[:max_coeff]) for max_coeff in range(1, order + 1)     ]      ret: int = 0     poly: Callable[[int], int]     x_val: int      for poly in polynomials:         x_val = 1         while func(x_val) == poly(x_val):             x_val += 1          ret += poly(x_val)      return ret\n2: def geometric_series(     nth_term: float,     start_term_a: float,     common_ratio_r: float, ) -> list[float]:     if not all((nth_term, start_term_a, common_ratio_r)):         return []     series: list[float] = []     power = 1     multiple = common_ratio_r     for _ in range(int(nth_term)):         if not series:             series.append(start_term_a)         else:             power += 1             series.append(float(start_term_a * multiple))             multiple = pow(float(common_ratio_r), power)     return series", "output": "1"}
{"task": "detection", "input": "classify code:\ndef get_black_and_white_rgb(distance: float) -> tuple:\n    \"\"\"\n    Black&white color-coding that ignores the relative distance. The Mandelbrot\n    set is black, everything else is white.\n\n    >>> get_black_and_white_rgb(0)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(0.5)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return (255, 255, 255)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 4) -> int | None:\n    results = run(n)\n    return results[0] if len(results) else None", "output": "Return the first value of the first four consecutive integers to have four"}
{"task": "summary", "input": "summarize code:\ndef nth_prime(n, *, approximate=False):\n    lb, ub = _nth_prime_bounds(n + 1)\n\n    if not approximate or n <= 1_000_000:\n        return nth(sieve(ceil(ub)), n)\n\n    # Search from the midpoint and return the first odd prime\n    odd = floor((lb + ub) / 2) | 1\n    return first_true(count(odd, step=2), pred=is_prime)", "output": "Return the nth prime (counting from 0)."}
{"task": "summary", "input": "summarize code:\ndef indian_phone_validator(phone: str) -> bool:\n    pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")\n    if match := re.search(pat, phone):\n        return match.string == phone\n    return False", "output": "Determine whether the string is a valid phone number or not"}
{"task": "summary", "input": "summarize code:\ndef world_covid19_stats(\n    url: str = \"https://www.worldometers.info/coronavirus/\",\n) -> dict:\n    soup = BeautifulSoup(\n        httpx.get(url, timeout=10, follow_redirects=True).text, \"html.parser\"\n    )\n    keys = soup.find_all(\"h1\")\n    values = soup.find_all(\"div\", {\"class\": \"maincounter-number\"})\n    keys += soup.find_all(\"span\", {\"class\": \"panel-title\"})\n    values += soup.find_all(\"div\", {\"class\": \"number-table-main\"})\n    return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}", "output": "Return a dict of current worldwide COVID-19 statistics"}
{"task": "search", "input": "search code:\nConverts an integer to a string containing commas every three digits.\n\nChoices:\n0: def natural_sort(input_list: list[str]) -> list[str]:      def alphanum_key(key):         return [int(s) if s.isdigit() else s.lower() for s in re.split(\"([0-9]+)\", key)]      return sorted(input_list, key=alphanum_key)\n1: def intcomma(value, ndigits=None):     sep = thousands_separator()     try:         if isinstance(value, str):             float(value.replace(sep, \"\"))         else:             float(value)     except (TypeError, ValueError):         return value      if ndigits:         orig = \"{0:.{1}f}\".format(value, ndigits)     else:         orig = str(value)      new = re.sub(r\"^(-?\\d+)(\\d{3})\", rf\"\\g<1>{sep}\\g<2>\", orig)     if orig == new:         return new     else:         return intcomma(new)\n2: def lexical_order(max_number: int) -> Iterator[int]:      stack = [1]      while stack:         num = stack.pop()         if num > max_number:             continue          yield num         if (num % 10) != 9:             stack.append(num + 1)          stack.append(num * 10)", "output": "1"}
{"task": "search", "input": "search code:\nFind the number of digits in a number.\n\nChoices:\n0: def polynomial_derivative(coefficients):     n = len(coefficients)     powers = reversed(range(1, n))     return list(map(mul, coefficients, powers))\n1: def num_digits_faster(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      return len(str(abs(n)))\n2: def is_collection(obj):     return is_iterable(obj) and not isinstance(obj, (str, bytes))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef bin_to_hexadecimal(binary_str: str) -> str:\n    # Sanitising parameter\n    binary_str = str(binary_str).strip()\n\n    # Exceptions\n    if not binary_str:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = binary_str[0] == \"-\"\n    binary_str = binary_str[1:] if is_negative else binary_str\n    if not all(char in \"01\" for char in binary_str):\n        raise ValueError(\"Non-binary value was passed to the function\")\n\n    binary_str = (\n        \"0\" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str\n    )\n\n    hexadecimal = []\n    for x in range(0, len(binary_str), 4):\n        hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])\n    hexadecimal_str = \"0x\" + \"\".join(hexadecimal)\n\n    return \"-\" + hexadecimal_str if is_negative else hexadecimal_str", "output": "Converting a binary string into hexadecimal using Grouping Method"}
{"task": "repair", "input": "fix bug:\ndef format_ruleset(ruleset: int) -> List[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]", "output": "def format_ruleset(ruleset: int) -> list[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]"}
{"task": "summary", "input": "summarize code:\ndef not_32(i: int) -> int:\n    if i < 0:\n        raise ValueError(\"Input must be non-negative\")\n\n    i_str = format(i, \"032b\")\n    new_str = \"\"\n    for c in i_str:\n        new_str += \"1\" if c == \"0\" else \"0\"\n    return int(new_str, 2)", "output": "Perform bitwise NOT on given int."}
{"task": "repair", "input": "fix bug:\ndef xor(a, b):\n    \"\"\"\n    >>> xor(\"01010101\", \"00001111\")\n    '01011010'\n    \"\"\"\n    res = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            res += \"0\"\n        else:\n            res += \"1\"\n    return res", "output": "def xor(a, b):\n    \"\"\"\n    >>> xor(\"01010101\", \"00001111\")\n    '01011010'\n    \"\"\"\n    res = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            res += \"0\"\n        else:\n            res += \"1\"\n    return res"}
{"task": "search", "input": "search code:\nSimplify the Karnaugh map.\n\nChoices:\n0: def _is_scalar(value, stringlike=(str, bytes)):     \"Scalars are bytes, strings, and non-iterables.\"     try:         iter(value)     except TypeError:         return True     return isinstance(value, stringlike)\n1: def doublestarmap(func, iterable):     for item in iterable:         yield func(**item)\n2: def simplify_kmap(kmap: list[list[int]]) -> str:     simplified_f = []     for a, row in enumerate(kmap):         for b, item in enumerate(row):             if item:                 term = (\"A\" if a else \"A'\") + (\"B\" if b else \"B'\")                 simplified_f.append(term)     return \" + \".join(simplified_f)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway", "output": "BUGGY"}
{"task": "search", "input": "search code:\nA pure Python implementation of a linear search algorithm\n\nChoices:\n0: def linear_search(sequence: list, target: int) -> int:     for index, item in enumerate(sequence):         if item == target:             return index     return -1\n1: def can_complete_journey(gas_stations: tuple[GasStation, ...]) -> int:     total_gas = sum(gas_station.gas_quantity for gas_station in gas_stations)     total_cost = sum(gas_station.cost for gas_station in gas_stations)     if total_gas < total_cost:         return -1      start = 0     net = 0     for i, gas_station in enumerate(gas_stations):         net += gas_station.gas_quantity - gas_station.cost         if net < 0:             start = i + 1             net = 0     return start\n2: def method_2(boundary: list[int], steps: int) -> float:     # \"Simpson Rule\"     # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)     if steps <= 0:         raise ZeroDivisionError(\"Number of steps must be greater than zero\")      h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 3.0) * f(a)     cnt = 2     for i in x_i:         y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)         cnt += 1     y += (h / 3.0) * f(b)     return y", "output": "0"}
{"task": "search", "input": "search code:\nFinds the maximum total in a triangle as described by the problem statement\n\nChoices:\n0: def solution() -> int:     script_dir = os.path.dirname(os.path.realpath(__file__))     triangle_path = os.path.join(script_dir, \"triangle.txt\")      with open(triangle_path) as in_file:         triangle = [[int(i) for i in line.split()] for line in in_file]      while len(triangle) != 1:         last_row = triangle.pop()         curr_row = triangle[-1]         for j in range(len(last_row) - 1):             curr_row[j] += max(last_row[j], last_row[j + 1])     return triangle[0][0]\n1: def is_ip_v4_address_valid(ip: str) -> bool:     octets = ip.split(\".\")     if len(octets) != 4:         return False      for octet in octets:         if not octet.isdigit():             return False          number = int(octet)         if len(str(number)) != len(octet):             return False          if not 0 <= number <= 255:             return False      return True\n2: def solution(n: int = 2000000) -> int:      return sum(num for num in range(3, n, 2) if is_prime(num)) + 2 if n > 2 else 0", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in xrange(1, 1001):\n        total += i ** i\n    return str(total)[-10:]", "output": "def solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in range(1, 1001):\n        total += i ** i\n    return str(total)[-10:]"}
{"task": "search", "input": "search code:\nConverting a binary string into hexadecimal using Grouping Method\n\nChoices:\n0: def equilibrium_index(arr: list[int]) -> int:     total_sum = sum(arr)     left_sum = 0      for i, value in enumerate(arr):         total_sum -= value         if left_sum == total_sum:             return i         left_sum += value      return -1\n1: def bin_to_hexadecimal(binary_str: str) -> str:     # Sanitising parameter     binary_str = str(binary_str).strip()      # Exceptions     if not binary_str:         raise ValueError(\"Empty string was passed to the function\")     is_negative = binary_str[0] == \"-\"     binary_str = binary_str[1:] if is_negative else binary_str     if not all(char in \"01\" for char in binary_str):         raise ValueError(\"Non-binary value was passed to the function\")      binary_str = (         \"0\" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str     )      hexadecimal = []     for x in range(0, len(binary_str), 4):         hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])     hexadecimal_str = \"0x\" + \"\".join(hexadecimal)      return \"-\" + hexadecimal_str if is_negative else hexadecimal_str\n2: def mro_items(type_obj):     # TODO: handle slots?     return itertools.chain.from_iterable(ct.__dict__.items()                                          for ct in type_obj.__mro__)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef main():\n    if len(sys.argv) < 3:\n        print(\"2 integer arguments required\")\n        return 1\n    a = int(sys.argv[1])\n    b = int(sys.argv[2])\n    print(extended_euclidean_algorithm(a, b))\n    return 0", "output": "Call Extended Euclidean Algorithm."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 10**15) -> int:\n\n    digits = [1]\n    i = 1\n    dn = 0\n    while True:\n        _diff, terms_jumped = next_term(digits, 20, i + dn, n)\n        dn += terms_jumped\n        if dn == n - i:\n            break\n\n    a_n = 0\n    for j in range(len(digits)):\n        a_n += digits[j] * 10**j\n    return a_n", "output": "returns n-th term of sequence"}
{"task": "search", "input": "search code:\nFinds the maclaurin approximation of sin\n\nChoices:\n0: def area_ellipse(radius_x: float, radius_y: float) -> float:     if radius_x < 0 or radius_y < 0:         raise ValueError(\"area_ellipse() only accepts non-negative values\")     return pi * radius_x * radius_y\n1: def maclaurin_sin(theta: float, accuracy: int = 30) -> float:      if not isinstance(theta, (int, float)):         raise ValueError(\"maclaurin_sin() requires either an int or float for theta\")      if not isinstance(accuracy, int) or accuracy <= 0:         raise ValueError(\"maclaurin_sin() requires a positive int for accuracy\")      theta = float(theta)     div = theta // (2 * pi)     theta -= 2 * div * pi     return sum(         (-1) ** r * theta ** (2 * r + 1) / factorial(2 * r + 1) for r in range(accuracy)     )\n2: def couloumbs_law(     force: float, charge1: float, charge2: float, distance: float ) -> dict[str, float]:      charge_product = abs(charge1 * charge2)      if (force, charge1, charge2, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if distance < 0:         raise ValueError(\"Distance cannot be negative\")     if force == 0:         force = COULOMBS_CONSTANT * charge_product / (distance**2)         return {\"force\": force}     elif charge1 == 0:         charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)         return {\"charge1\": charge1}     elif charge2 == 0:         charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)         return {\"charge2\": charge2}     elif distance == 0:         distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5         return {\"distance\": distance}     raise ValueError(\"Exactly one argument must be 0\")", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num", "output": "def is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num"}
{"task": "repair", "input": "fix bug:\ndef p_series(nth_term: int, power: int) -> list:\n    \"\"\"Pure Python implementation of P-Series algorithm\n\n    :return: The P-Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> p_series(5, 2)\n    [1, '1/4', '1/9', '1/16', '1/25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    [1, '1/0.25', '1/0.1111111111111111', '1/0.0625', '1/0.04']\n    >>> p_series(\"\", 1000)\n    ''\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    [1]\n    \"\"\"\n    if nth_term == \"\":\n        return nth_term\n    nth_term = int(nth_term)\n    power = int(power)\n    series = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1/{pow(temp + 1, int(power))}\" if series else 1)\n    return series", "output": "def p_series(nth_term: int | float | str, power: int | float | str) -> list[str]:\n    \"\"\"\n    Pure Python implementation of P-Series algorithm\n    :return: The P-Series starting from 1 to last (nth) term\n    Examples:\n    >>> p_series(5, 2)\n    ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']\n    >>> p_series(\"\", 1000)\n    ['']\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    ['1']\n    \"\"\"\n    if nth_term == \"\":\n        return [\"\"]\n    nth_term = int(nth_term)\n    power = int(power)\n    series: list[str] = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")\n    return series"}
{"task": "summary", "input": "summarize code:\ndef hubble_parameter(\n    hubble_constant: float,\n    radiation_density: float,\n    matter_density: float,\n    dark_energy: float,\n    redshift: float,\n) -> float:\n    parameters = [redshift, radiation_density, matter_density, dark_energy]\n    if any(p < 0 for p in parameters):\n        raise ValueError(\"All input parameters must be positive\")\n\n    if any(p > 1 for p in parameters[1:4]):\n        raise ValueError(\"Relative densities cannot be greater than one\")\n    else:\n        curvature = 1 - (matter_density + radiation_density + dark_energy)\n\n        e_2 = (\n            radiation_density * (redshift + 1) ** 4\n            + matter_density * (redshift + 1) ** 3\n            + curvature * (redshift + 1) ** 2\n            + dark_energy\n        )\n\n        hubble = hubble_constant * e_2 ** (1 / 2)\n        return hubble", "output": "Input Parameters"}
{"task": "detection", "input": "classify code:\ndef find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef shell_sort(collection: list) -> list:\n    \"\"\"Implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([3, 2, 1])\n    [1, 2, 3]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([1])\n    [1]\n    \"\"\"\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection", "output": "def shell_sort(collection: list) -> list:\n    \"\"\"Implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([3, 2, 1])\n    [1, 2, 3]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([1])\n    [1]\n    \"\"\"\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection"}
{"task": "repair", "input": "fix bug:\ndef pancake_sort(arr):\n    \"\"\"Sort Array with Pancake Sort.\n    :param arr: Collection containing comparable items\n    :return: Collection ordered in ascending order of items\n    Examples:\n    >>> pancake_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pancake_sort([])\n    []\n    >>> pancake_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    cur = len(arr)\n    while cur > 1:\n        # Find the maximum number in arr\n        mi = arr.index(max(arr[0:cur]))\n        # Reverse from 0 to mi\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\n        # Reverse whole list\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\n        cur -= 1\n    return arr", "output": "def pancake_sort(arr):\n    \"\"\"Sort Array with Pancake Sort.\n    :param arr: Collection containing comparable items\n    :return: Collection ordered in ascending order of items\n    Examples:\n    >>> pancake_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pancake_sort([])\n    []\n    >>> pancake_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    cur = len(arr)\n    while cur > 1:\n        # Find the maximum number in arr\n        mi = arr.index(max(arr[0:cur]))\n        # Reverse from 0 to mi\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\n        # Reverse whole list\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\n        cur -= 1\n    return arr"}
{"task": "detection", "input": "classify code:\ndef sum_reverse(n: int) -> int:\n    \"\"\"\n    Returns the sum of n and reverse of n.\n    >>> sum_reverse(123)\n    444\n    >>> sum_reverse(3478)\n    12221\n    >>> sum_reverse(12)\n    33\n    \"\"\"\n    return int(n) + int(str(n)[::-1])", "output": "CORRECT"}
{"task": "search", "input": "search code:\nThis function returns a matrix representing the corresponding pascal's triangle\n\nChoices:\n0: def multiply(     chain: list[int],     primes: list[int],     min_prime_idx: int,     prev_num: int,     max_num: int,     prev_sum: int,     primes_degrees: dict[int, int], ) -> None:      min_prime = primes[min_prime_idx]     num = prev_num * min_prime      min_prime_degree = primes_degrees.get(min_prime, 0)     min_prime_degree += 1     primes_degrees[min_prime] = min_prime_degree      new_sum = prev_sum * min_prime + (prev_sum + prev_num) * (min_prime - 1) // (         min_prime**min_prime_degree - 1     )     chain[num] = new_sum      for prime_idx in range(min_prime_idx, len(primes)):         if primes[prime_idx] * num > max_num:             break          multiply(             chain=chain,             primes=primes,             min_prime_idx=prime_idx,             prev_num=num,             max_num=max_num,             prev_sum=new_sum,             primes_degrees=primes_degrees.copy(),         )\n1: def is_zero_vector(vector: Vector3d, accuracy: int) -> bool:     return tuple(round(x, accuracy) for x in vector) == (0, 0, 0)\n2: def generate_pascal_triangle_optimized(num_rows: int) -> list[list[int]]:      if not isinstance(num_rows, int):         raise TypeError(\"The input value of 'num_rows' should be 'int'\")      if num_rows == 0:         return []     elif num_rows < 0:         raise ValueError(             \"The input value of 'num_rows' should be greater than or equal to 0\"         )      result: list[list[int]] = [[1]]      for row_index in range(1, num_rows):         temp_row = [0] + result[-1] + [0]         row_length = row_index + 1         # Calculate the number of distinct elements in a row         distinct_elements = sum(divmod(row_length, 2))         row_first_half = [             temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)         ]         row_second_half = row_first_half[: (row_index + 1) // 2]         row_second_half.reverse()         row = row_first_half + row_second_half         result.append(row)      return result", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solve_crossword(puzzle: list[list[str]], words: list[str]) -> bool:\n    for row in range(len(puzzle)):\n        for col in range(len(puzzle[0])):\n            if puzzle[row][col] == \"\":\n                for word in words:\n                    for vertical in [True, False]:\n                        if is_valid(puzzle, word, row, col, vertical):\n                            place_word(puzzle, word, row, col, vertical)\n                            words.remove(word)\n                            if solve_crossword(puzzle, words):\n                                return True\n                            words.append(word)\n                            remove_word(puzzle, word, row, col, vertical)\n                return False\n    return True", "output": "Solve the crossword puzzle using backtracking."}
{"task": "search", "input": "search code:\nReturn a decimal number in its simplest fraction form\n\nChoices:\n0: def decimal_to_fraction(decimal: float | str) -> tuple[int, int]:     try:         decimal = float(decimal)     except ValueError:         raise ValueError(\"Please enter a valid number\")     fractional_part = decimal - int(decimal)     if fractional_part == 0:         return int(decimal), 1     else:         number_of_frac_digits = len(str(decimal).split(\".\")[1])         numerator = int(decimal * (10**number_of_frac_digits))         denominator = 10**number_of_frac_digits         divisor, dividend = denominator, numerator         while True:             remainder = dividend % divisor             if remainder == 0:                 break             dividend, divisor = divisor, remainder         numerator, denominator = numerator // divisor, denominator // divisor         return numerator, denominator\n1: def gnome_sort(lst: list) -> list:     if len(lst) <= 1:         return lst      i = 1      while i < len(lst):         if lst[i - 1] <= lst[i]:             i += 1         else:             lst[i - 1], lst[i] = lst[i], lst[i - 1]             i -= 1             if i == 0:                 i = 1      return lst\n2: def in_reverse(linked_list: LinkedList) -> str:     return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))", "output": "0"}
{"task": "detection", "input": "classify code:\ndef prime_sieve(limit: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef vol_spheres_union(\n    radius_1: float, radius_2: float, centers_distance: float\n) -> float:\n\n    if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:\n        raise ValueError(\n            \"vol_spheres_union() only accepts non-negative values, non-zero radius\"\n        )\n\n    if centers_distance == 0:\n        return vol_sphere(max(radius_1, radius_2))\n\n    return (\n        vol_sphere(radius_1)\n        + vol_sphere(radius_2)\n        - vol_spheres_intersect(radius_1, radius_2, centers_distance)\n    )", "output": "Calculate the volume of the union of two spheres that possibly intersect."}
{"task": "search", "input": "search code:\nInput Params:\n\nChoices:\n0: def hubble_parameter(     hubble_constant: float,     radiation_density: float,     matter_density: float,     dark_energy: float,     redshift: float, ) -> float:     parameters = [redshift, radiation_density, matter_density, dark_energy]     if any(p < 0 for p in parameters):         raise ValueError(\"All input parameters must be positive\")      if any(p > 1 for p in parameters[1:4]):         raise ValueError(\"Relative densities cannot be greater than one\")     else:         curvature = 1 - (matter_density + radiation_density + dark_energy)          e_2 = (             radiation_density * (redshift + 1) ** 4             + matter_density * (redshift + 1) ** 3             + curvature * (redshift + 1) ** 2             + dark_energy         )          hubble = hubble_constant * e_2 ** (1 / 2)         return hubble\n1: def mse(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     square_diff = np.square(difference)      score = square_diff.mean()     return score\n2: def capture_radii(     target_body_radius: float, target_body_mass: float, projectile_velocity: float ) -> float:      if target_body_mass < 0:         raise ValueError(\"Mass cannot be less than 0\")     if target_body_radius < 0:         raise ValueError(\"Radius cannot be less than 0\")     if projectile_velocity > c:         raise ValueError(\"Cannot go beyond speed of light\")      escape_velocity_squared = (2 * G * target_body_mass) / target_body_radius     capture_radius = target_body_radius * sqrt(         1 + escape_velocity_squared / pow(projectile_velocity, 2)     )     return round(capture_radius, 0)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef is_proth_number(number: int) -> bool:\n    if not isinstance(number, int):\n        message = f\"Input value of [{number=}] must be an integer\"\n        raise TypeError(message)\n\n    if number <= 0:\n        message = f\"Input value of [{number=}] must be > 0\"\n        raise ValueError(message)\n\n    if number == 1:\n        return False\n\n    number -= 1\n    n = 0\n    while number % 2 == 0:\n        n += 1\n        number //= 2\n    return number < 2**n", "output": ":param number: positive integer number"}
{"task": "search", "input": "search code:\nReturn the sum of the squares of the input values.\n\nChoices:\n0: def exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:     return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))\n1: def solution(base: int = 1777, height: int = 1855, digits: int = 8) -> int:      # calculate baseheight by right-assiciative repeated modular     # exponentiation     result = base     for _ in range(1, height):         result = _modexpt(base, result, 10**digits)      return result\n2: def sum_of_squares(it):     return _sumprod(*tee(it))", "output": "2"}
{"task": "search", "input": "search code:\nCompare the value at given index1 and index2 of the array and swap them as per\n\nChoices:\n0: def _shift_to_odd(n):     'Return s, d such that 2**s * d == n'     s = ((n - 1) ^ n).bit_length() - 1     d = n >> s     assert (1 << s) * d == n and d & 1 and s >= 0     return s, d\n1: def roundrobin(*iterables):     # Algorithm credited to George Sakkis     iterators = map(iter, iterables)     for num_active in range(len(iterables), 0, -1):         iterators = cycle(islice(iterators, num_active))         yield from map(next, iterators)\n2: def comp_and_swap(array: list[int], index1: int, index2: int, direction: int) -> None:     if (direction == 1 and array[index1] > array[index2]) or (         direction == 0 and array[index1] < array[index2]     ):         array[index1], array[index2] = array[index2], array[index1]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef random_anime_character() -> tuple[str, str, str]:\n    soup = BeautifulSoup(\n        httpx.get(URL, headers=headers, timeout=10).text, \"html.parser\"\n    )\n    title = soup.find(\"meta\", attrs={\"property\": \"og:title\"}).attrs[\"content\"]\n    image_url = soup.find(\"meta\", attrs={\"property\": \"og:image\"}).attrs[\"content\"]\n    description = soup.find(\"p\", id=\"description\").get_text()\n    _, image_extension = os.path.splitext(os.path.basename(image_url))\n    image_title = title.strip().replace(\" \", \"_\")\n    image_title = f\"{image_title}{image_extension}\"\n    save_image(image_url, image_title)\n    return (title, description, image_title)", "output": "Returns the Title, Description, and Image Title of a random anime character ."}
{"task": "summary", "input": "summarize code:\ndef _suppress_lower_units(min_unit, suppress):\n    suppress = set(suppress)\n    for u in Unit:\n        if u == min_unit:\n            break\n        suppress.add(u)\n\n    return suppress", "output": "Extend suppressed units (if any) with all units lower than the minimum unit."}
{"task": "search", "input": "search code:\nWrap an iterator-returning callable to make its iterators thread-safe.\n\nChoices:\n0: def synchronized(func):      @wraps(func)     def inner(*args, **kwargs):         iterator = func(*args, **kwargs)         return serialize(iterator)      return inner\n1: def decimal_to_ipv4(decimal_ipv4: int) -> str:      if not (0 <= decimal_ipv4 <= 4294967295):         raise ValueError(\"Invalid decimal IPv4 address\")      ip_parts = []     for _ in range(4):         ip_parts.append(str(decimal_ipv4 & 255))         decimal_ipv4 >>= 8      return \".\".join(reversed(ip_parts))\n2: def from_file(filename, sep=\"\\n\"):     \"Parse a file into a list of strings, separated by sep.\"     with open(filename) as file:         return file.read().strip().split(sep)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef median(nums: list) -> Union[int, float]:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns number of fractions lie between 1/3 and 1/2 in the sorted set\n\nChoices:\n0: def solution(max_d: int = 12_000) -> int:      fractions_number = 0     for d in range(max_d + 1):         n_start = d // 3 + 1         n_step = 1         if d % 2 == 0:             n_start += 1 - n_start % 2             n_step = 2         for n in range(n_start, (d + 1) // 2, n_step):             if gcd(n, d) == 1:                 fractions_number += 1     return fractions_number\n1: def hubble_parameter(     hubble_constant: float,     radiation_density: float,     matter_density: float,     dark_energy: float,     redshift: float, ) -> float:     parameters = [redshift, radiation_density, matter_density, dark_energy]     if any(p < 0 for p in parameters):         raise ValueError(\"All input parameters must be positive\")      if any(p > 1 for p in parameters[1:4]):         raise ValueError(\"Relative densities cannot be greater than one\")     else:         curvature = 1 - (matter_density + radiation_density + dark_energy)          e_2 = (             radiation_density * (redshift + 1) ** 4             + matter_density * (redshift + 1) ** 3             + curvature * (redshift + 1) ** 2             + dark_energy         )          hubble = hubble_constant * e_2 ** (1 / 2)         return hubble\n2: def get_path(root, path, default=_UNSET):     if isinstance(path, str):         path = path.split('.')     cur = root     try:         for seg in path:             try:                 cur = cur[seg]             except (KeyError, IndexError) as exc:                 raise PathAccessError(exc, seg, path)             except TypeError as exc:                 # either string index in a list, or a parent that                 # doesn't support indexing                 try:                     seg = int(seg)                     cur = cur[seg]                 except (ValueError, KeyError, IndexError, TypeError):                     if not is_iterable(cur):                         exc = TypeError('%r object is not indexable'                                         % type(cur).__name__)                     raise PathAccessError(exc, seg, path)     except PathAccessError:         if default is _UNSET:             raise         return default     return cur", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(power: int = 1000) -> int:\n    num = 2**power\n    string_num = str(num)\n    list_num = list(string_num)\n    sum_of_num = 0\n\n    for i in list_num:\n        sum_of_num += int(i)\n\n    return sum_of_num", "output": "Returns the sum of the digits of the number 2^power."}
{"task": "summary", "input": "summarize code:\ndef median(items: list):\n    mid, rem = divmod(len(items), 2)\n    if rem != 0:\n        return quick_select(items=items, index=mid)\n    else:\n        low_mid = quick_select(items=items, index=mid - 1)\n        high_mid = quick_select(items=items, index=mid)\n        return (low_mid + high_mid) / 2", "output": "One common application of Quickselect is finding the median, which is"}
{"task": "summary", "input": "summarize code:\ndef max_tasks(tasks_info: list[tuple[int, int]]) -> list[int]:\n    tasks = sorted(\n        (\n            Task(task_id, deadline, reward)\n            for task_id, (deadline, reward) in enumerate(tasks_info)\n        ),\n        key=attrgetter(\"reward\"),\n        reverse=True,\n    )\n    return [task.task_id for i, task in enumerate(tasks, start=1) if task.deadline >= i]", "output": "Create a list of Task objects that are sorted so the highest rewards come first."}
{"task": "search", "input": "search code:\nFind the floor and ceiling values for a given key in a Binary Search Tree (BST).\n\nChoices:\n0: def is_harshad_number_in_base(num: int, base: int) -> bool:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      if num < 0:         return False      n = int_to_base(num, base)     d = sum_of_digits(num, base)     return int(n, base) % int(d, base) == 0\n1: def area_trapezium(base1: float, base2: float, height: float) -> float:     if base1 < 0 or base2 < 0 or height < 0:         raise ValueError(\"area_trapezium() only accepts non-negative values\")     return 1 / 2 * (base1 + base2) * height\n2: def floor_ceiling(root: Node | None, key: int) -> tuple[int | None, int | None]:     floor_val = None     ceiling_val = None      while root:         if root.key == key:             floor_val = root.key             ceiling_val = root.key             break          if key < root.key:             ceiling_val = root.key             root = root.left         else:             floor_val = root.key             root = root.right      return floor_val, ceiling_val", "output": "2"}
{"task": "search", "input": "search code:\nIndex of the first occurrence of a maximum value in an iterable.\n\nChoices:\n0: def simple_moving_average(     data: Sequence[float], window_size: int ) -> list[float | None]:     if window_size < 1:         raise ValueError(\"Window size must be a positive integer\")      sma: list[float | None] = []      for i in range(len(data)):         if i < window_size - 1:             sma.append(None)  # SMA not available for early data points         else:             window = data[i - window_size + 1 : i + 1]             sma_value = sum(window) / window_size             sma.append(sma_value)     return sma\n1: def argmax(iterable, *, key=None):     if key is not None:         iterable = map(key, iterable)     return max(enumerate(iterable), key=itemgetter(1))[0]\n2: def peak(lst: list[int]) -> int:     # middle index     m = len(lst) // 2      # choose the middle 3 elements     three = lst[m - 1 : m + 2]      # if middle element is peak     if three[1] > three[0] and three[1] > three[2]:         return three[1]      # if increasing, recurse on right     elif three[0] < three[2]:         if len(lst[:m]) == 2:             m -= 1         return peak(lst[m:])      # decreasing     else:         if len(lst[:m]) == 2:             m += 1         return peak(lst[:m])", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef nth(iterable, n, default=None):\n    return next(islice(iterable, n, None), default)", "output": "Returns the nth item or a default value."}
{"task": "summary", "input": "summarize code:\ndef get_barcode(barcode: str) -> int:\n    if str(barcode).isalpha():\n        msg = f\"Barcode '{barcode}' has alphabetic characters.\"\n        raise ValueError(msg)\n    elif int(barcode) < 0:\n        raise ValueError(\"The entered barcode has a negative value. Try again.\")\n    else:\n        return int(barcode)", "output": "Returns the barcode as an integer"}
{"task": "search", "input": "search code:\nFinds the maximum total in a triangle as described by the problem statement\n\nChoices:\n0: def horn_schunck(     image0: np.ndarray,     image1: np.ndarray,     num_iter: SupportsIndex,     alpha: float | None = None, ) -> tuple[np.ndarray, np.ndarray]:     if alpha is None:         alpha = 0.1      # Initialize flow     horizontal_flow = np.zeros_like(image0)     vertical_flow = np.zeros_like(image0)      # Prepare kernels for the calculation of the derivatives and the average velocity     kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25     kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25     kernel_t = np.array([[1, 1], [1, 1]]) * 0.25     kernel_laplacian = np.array(         [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]     )      # Iteratively refine the flow     for _ in range(num_iter):         warped_image = warp(image0, horizontal_flow, vertical_flow)         derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)         derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)         derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)          avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)         avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)          # This updates the flow as proposed in the paper (Step 12)         update = (             derivative_x * avg_horizontal_velocity             + derivative_y * avg_vertical_velocity             + derivative_t         )         update = update / (alpha**2 + derivative_x**2 + derivative_y**2)          horizontal_flow = avg_horizontal_velocity - derivative_x * update         vertical_flow = avg_vertical_velocity - derivative_y * update      return horizontal_flow, vertical_flow\n1: def gravitational_law(     force: float, mass_1: float, mass_2: float, distance: float ) -> dict[str, float]:      product_of_mass = mass_1 * mass_2      if (force, mass_1, mass_2, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if force < 0:         raise ValueError(\"Gravitational force can not be negative\")     if distance < 0:         raise ValueError(\"Distance can not be negative\")     if mass_1 < 0 or mass_2 < 0:         raise ValueError(\"Mass can not be negative\")     if force == 0:         force = GRAVITATIONAL_CONSTANT * product_of_mass / (distance**2)         return {\"force\": force}     elif mass_1 == 0:         mass_1 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_2)         return {\"mass_1\": mass_1}     elif mass_2 == 0:         mass_2 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_1)         return {\"mass_2\": mass_2}     elif distance == 0:         distance = (GRAVITATIONAL_CONSTANT * product_of_mass / (force)) ** 0.5         return {\"distance\": distance}     raise ValueError(\"One and only one argument must be 0\")\n2: def solution():     script_dir = os.path.dirname(os.path.realpath(__file__))     triangle = os.path.join(script_dir, \"triangle.txt\")      with open(triangle) as f:         triangle = f.readlines()      a = []     for line in triangle:         numbers_from_line = []         for number in line.strip().split(\" \"):             numbers_from_line.append(int(number))         a.append(numbers_from_line)      for i in range(1, len(a)):         for j in range(len(a[i])):             number1 = a[i - 1][j] if j != len(a[i - 1]) else 0             number2 = a[i - 1][j - 1] if j > 0 else 0             a[i][j] += max(number1, number2)     return max(a[-1])", "output": "2"}
{"task": "search", "input": "search code:\nDisplay Forbes real-time billionaires in a rich table.\n\nChoices:\n0: def add(digits, k, addend):     for j in range(k, len(digits)):         s = digits[j] + addend         if s >= 10:             quotient, digits[j] = divmod(s, 10)             addend = addend // 10 + quotient         else:             digits[j] = s             addend = addend // 10          if addend == 0:             break      while addend > 0:         addend, digit = divmod(addend, 10)         digits.append(digit)\n1: def display_billionaires(forbes_billionaires: list[dict[str, int | str]]) -> None:      table = rich_table.Table(         title=f\"Forbes Top {LIMIT} Real-Time Billionaires at {TODAY:%Y-%m-%d %H:%M}\",         style=\"green\",         highlight=True,         box=box.SQUARE,     )     for key in forbes_billionaires[0]:         table.add_column(key)      for billionaire in forbes_billionaires:         table.add_row(*billionaire.values())      rich_console.Console().print(table)\n2: def diophantine_all_soln(a: int, b: int, c: int, n: int = 2) -> None:     (x0, y0) = diophantine(a, b, c)  # Initial value     d = greatest_common_divisor(a, b)     p = a // d     q = b // d      for i in range(n):         x = x0 + i * q         y = y0 - i * p         print(x, y)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef intcomma(value, ndigits=None):\n    sep = thousands_separator()\n    try:\n        if isinstance(value, str):\n            float(value.replace(sep, \"\"))\n        else:\n            float(value)\n    except (TypeError, ValueError):\n        return value\n\n    if ndigits:\n        orig = \"{0:.{1}f}\".format(value, ndigits)\n    else:\n        orig = str(value)\n\n    new = re.sub(r\"^(-?\\d+)(\\d{3})\", rf\"\\g<1>{sep}\\g<2>\", orig)\n    if orig == new:\n        return new\n    else:\n        return intcomma(new)", "output": "Converts an integer to a string containing commas every three digits."}
{"task": "summary", "input": "summarize code:\ndef allocation_num(number_of_bytes: int, partitions: int) -> list[str]:\n    if partitions <= 0:\n        raise ValueError(\"partitions must be a positive number!\")\n    if partitions > number_of_bytes:\n        raise ValueError(\"partitions can not > number_of_bytes!\")\n    bytes_per_partition = number_of_bytes // partitions\n    allocation_list = []\n    for i in range(partitions):\n        start_bytes = i * bytes_per_partition + 1\n        end_bytes = (\n            number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition\n        )\n        allocation_list.append(f\"{start_bytes}-{end_bytes}\")\n    return allocation_list", "output": "Divide a number of bytes into x partitions."}
{"task": "summary", "input": "summarize code:\ndef solution():\n    with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:\n        names = str(file.readlines()[0])\n        names = names.replace('\"', \"\").split(\",\")\n\n    names.sort()\n\n    name_score = 0\n    total_score = 0\n\n    for i, name in enumerate(names):\n        for letter in name:\n            name_score += ord(letter) - 64\n\n        total_score += (i + 1) * name_score\n        name_score = 0\n    return total_score", "output": "Returns the total of all the name scores in the file."}
{"task": "repair", "input": "fix bug:\ndef maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)", "output": "def maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)"}
{"task": "search", "input": "search code:\nRecursively reconstructs one of the optimal subsets given\n\nChoices:\n0: def sum_reverse(n: int) -> int:     return int(n) + int(str(n)[::-1])\n1: def _construct_solution(dp: list, wt: list, i: int, j: int, optimal_set: set):     # for the current item i at a maximum weight j to be part of an optimal subset,     # the optimal value at (i, j) must be greater than the optimal value at (i-1, j).     # where i - 1 means considering only the previous items at the given maximum weight     if i > 0 and j > 0:         if dp[i - 1][j] == dp[i][j]:             _construct_solution(dp, wt, i - 1, j, optimal_set)         else:             optimal_set.add(i)             _construct_solution(dp, wt, i - 1, j - wt[i - 1], optimal_set)\n2: def find_winner(num_people: int, step_size: int) -> int:     return josephus_recursive(num_people, step_size) + 1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    message = input(\"Enter message to encode or decode: \").strip()\n    key = input(\"Enter keyword: \").strip()\n    option = input(\"Encipher or decipher? E/D:\").strip()[0].lower()\n    try:\n        func = {\"e\": encipher, \"d\": decipher}[option]\n    except KeyError:\n        raise KeyError(\"invalid input option\")\n    cipher_map = create_cipher_map(key)\n    print(func(message, cipher_map))", "output": "Handles I/O"}
{"task": "summary", "input": "summarize code:\ndef strip_iter(iterable, strip_value=None):\n    return rstrip_iter(lstrip_iter(iterable, strip_value), strip_value)", "output": "Strips values from the beginning and end of an iterable. Stripped items"}
{"task": "search", "input": "search code:\nReturn the reverse bit string of a 32 bit integer\n\nChoices:\n0: def get_reverse_bit_string(number: int) -> str:     if not isinstance(number, int):         msg = (             \"operation can not be conducted on an object of type \"             f\"{type(number).__name__}\"         )         raise TypeError(msg)     bit_string = \"\"     for _ in range(32):         bit_string += str(number % 2)         number >>= 1     return bit_string\n1: def solution() -> int:      for a in range(300):         for b in range(a + 1, 400):             for c in range(b + 1, 500):                 if (a + b + c) == 1000 and (a**2) + (b**2) == (c**2):                     return a * b * c      return -1\n2: def mean_absolute_error(predicted_y, original_y):     total = sum(abs(y - predicted_y[i]) for i, y in enumerate(original_y))     return total / len(original_y)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )", "output": "CORRECT"}
{"task": "search", "input": "search code:\nPrints the boards that have a successful combination.\n\nChoices:\n0: def solution() -> int:      return next(         iter(             [                 a * b * (1000 - a - b)                 for a in range(1, 999)                 for b in range(a, 999)                 if (a * a + b * b == (1000 - a - b) ** 2)             ]         )     )\n1: def printboard(board: list[list[int]]) -> None:     for i in range(len(board)):         for j in range(len(board)):             if board[i][j] == 1:                 print(\"Q\", end=\" \")  # Queen is present             else:                 print(\".\", end=\" \")  # Empty cell         print()\n2: def int_ranges_from_int_list(range_string, delim=',', range_delim='-'):     int_tuples = []     # Normalize the range string to our internal format for processing.     range_string = format_int_list(         parse_int_list(range_string, delim, range_delim))     if range_string:         for bounds in range_string.split(','):             if '-' in bounds:                 start, end = bounds.split('-')             else:                 start, end = bounds, bounds             int_tuples.append((int(start), int(end)))     return tuple(int_tuples)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef has_same_digits(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if num1 and num2 have the same frequency of every digit, False\n    otherwise.\n\n    >>> has_same_digits(123456789, 987654321)\n    True\n\n    >>> has_same_digits(123, 23)\n    False\n\n    >>> has_same_digits(1234566, 123456)\n    False\n    \"\"\"\n    return sorted(str(num1)) == sorted(str(num2))", "output": "def has_same_digits(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if num1 and num2 have the same frequency of every digit, False\n    otherwise.\n\n    >>> has_same_digits(123456789, 987654321)\n    True\n\n    >>> has_same_digits(123, 23)\n    False\n\n    >>> has_same_digits(1234566, 123456)\n    False\n    \"\"\"\n    return sorted(str(num1)) == sorted(str(num2))"}
{"task": "search", "input": "search code:\nA version of :func:`zip` that \"broadcasts\" any scalar\n\nChoices:\n0: def zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):      def is_scalar(obj):         if scalar_types and isinstance(obj, scalar_types):             return True         try:             iter(obj)         except TypeError:             return True         else:             return False      size = len(objects)     if not size:         return      new_item = [None] * size     iterables, iterable_positions = [], []     for i, obj in enumerate(objects):         if is_scalar(obj):             new_item[i] = obj         else:             iterables.append(iter(obj))             iterable_positions.append(i)      if not iterables:         yield tuple(objects)         return      for item in zip(*iterables, strict=strict):         for i, new_item[i] in zip(iterable_positions, item):             pass         yield tuple(new_item)\n1: def calculate_turn_around_time(     process_name: list, arrival_time: list, burst_time: list, no_of_process: int ) -> list:      current_time = 0     # Number of processes finished     finished_process_count = 0     # Displays the finished process.     # If it is 0, the performance is completed if it is 1, before the performance.     finished_process = [0] * no_of_process     # List to include calculation results     turn_around_time = [0] * no_of_process      # Sort by arrival time.     burst_time = [burst_time[i] for i in np.argsort(arrival_time)]     process_name = [process_name[i] for i in np.argsort(arrival_time)]     arrival_time.sort()      while no_of_process > finished_process_count:         i = 0         while finished_process[i] == 1:             i += 1         current_time = max(current_time, arrival_time[i])          response_ratio = 0         # Index showing the location of the process being performed         loc = 0         # Saves the current response ratio.         temp = 0         for i in range(no_of_process):             if finished_process[i] == 0 and arrival_time[i] <= current_time:                 temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[                     i                 ]             if response_ratio < temp:                 response_ratio = temp                 loc = i          # Calculate the turn around time         turn_around_time[loc] = current_time + burst_time[loc] - arrival_time[loc]         current_time += burst_time[loc]         # Indicates that the process has been performed.         finished_process[loc] = 1         # Increase finished_process_count by 1         finished_process_count += 1      return turn_around_time\n2: def shear_stress(     stress: float,     tangential_force: float,     area: float, ) -> tuple[str, float]:     if (stress, tangential_force, area).count(0) != 1:         raise ValueError(\"You cannot supply more or less than 2 values\")     elif stress < 0:         raise ValueError(\"Stress cannot be negative\")     elif tangential_force < 0:         raise ValueError(\"Tangential Force cannot be negative\")     elif area < 0:         raise ValueError(\"Area cannot be negative\")     elif stress == 0:         return (             \"stress\",             tangential_force / area,         )     elif tangential_force == 0:         return (             \"tangential_force\",             stress * area,         )     else:         return (             \"area\",             tangential_force / stress,         )", "output": "0"}
{"task": "detection", "input": "classify code:\ndef lower(word: str) -> str:\n    \"\"\"\n    Will convert the entire string to lowercase letters\n\n    >>> lower(\"wow\")\n    'wow'\n    >>> lower(\"HellZo\")\n    'hellzo'\n    >>> lower(\"WHAT\")\n    'what'\n    >>> lower(\"wh[]32\")\n    'wh[]32'\n    >>> lower(\"whAT\")\n    'what'\n    \"\"\"\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn the number of items in *iterable*.\n\nChoices:\n0: def ilen(iterable):     # This is the \"most beautiful of the fast variants\" of this function.     # If you think you can improve on it, please ensure that your version     # is both 10x faster and 10x more beautiful.     return sum(compress(repeat(1), zip(iterable)))\n1: def random_anime_character() -> tuple[str, str, str]:     soup = BeautifulSoup(         httpx.get(URL, headers=headers, timeout=10).text, \"html.parser\"     )     title = soup.find(\"meta\", attrs={\"property\": \"og:title\"}).attrs[\"content\"]     image_url = soup.find(\"meta\", attrs={\"property\": \"og:image\"}).attrs[\"content\"]     description = soup.find(\"p\", id=\"description\").get_text()     _, image_extension = os.path.splitext(os.path.basename(image_url))     image_title = title.strip().replace(\" \", \"_\")     image_title = f\"{image_title}{image_extension}\"     save_image(image_url, image_title)     return (title, description, image_title)\n2: def get_multiplier(color: str) -> float:     if color not in multiplier_color_values:         msg = f\"{color} is not a valid color for multiplier band\"         raise ValueError(msg)     return multiplier_color_values[color]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef pretty_print(n):\n    if n <= 0:\n        return \"       ...       ....        nothing printing :(\"\n    upper_half = floyd(n)  # upper half\n    lower_half = reverse_floyd(n)  # lower half\n    return upper_half + lower_half", "output": "Print a complete diamond pattern with '*' characters."}
{"task": "summary", "input": "summarize code:\ndef charging_capacitor(\n    source_voltage: float,  # voltage in volts.\n    resistance: float,  # resistance in ohms.\n    capacitance: float,  # capacitance in farads.\n    time_sec: float,  # time in seconds after charging initiation of capacitor.\n) -> float:\n\n    if source_voltage <= 0:\n        raise ValueError(\"Source voltage must be positive.\")\n    if resistance <= 0:\n        raise ValueError(\"Resistance must be positive.\")\n    if capacitance <= 0:\n        raise ValueError(\"Capacitance must be positive.\")\n    return round(source_voltage * (1 - exp(-time_sec / (resistance * capacitance))), 3)", "output": "Find capacitor voltage at any nth second after initiating its charging."}
{"task": "detection", "input": "classify code:\ndef get_squares(n: int) -> list[int]:\n    \"\"\"\n    >>> get_squares(0)\n    []\n    >>> get_squares(1)\n    [0]\n    >>> get_squares(2)\n    [0, 1]\n    >>> get_squares(3)\n    [0, 1, 4]\n    >>> get_squares(4)\n    [0, 1, 4, 9]\n    \"\"\"\n    return [number * number for number in range(n)]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef preorder(root: Node | None) -> Generator[int]:\n    if not root:\n        return\n    yield root.data\n    yield from preorder(root.left)\n    yield from preorder(root.right)", "output": "Pre-order traversal visits root node, left subtree, right subtree."}
{"task": "detection", "input": "classify code:\ndef dp_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Dynamic programming matching algorithm.\n\n    | Time complexity: O(\\|text\\| * \\|pattern\\|)\n    | Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCheck if a linked list is a palindrome.\n\nChoices:\n0: def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:     return sum(turnaround_times) / len(turnaround_times)\n1: def longest_common_subsequence(x: str, y: str):     # find the length of strings      assert x is not None     assert y is not None      m = len(x)     n = len(y)      # declaring the array for storing the dp values     dp = [[0] * (n + 1) for _ in range(m + 1)]      for i in range(1, m + 1):         for j in range(1, n + 1):             match = 1 if x[i - 1] == y[j - 1] else 0              dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)      seq = \"\"     i, j = m, n     while i > 0 and j > 0:         match = 1 if x[i - 1] == y[j - 1] else 0          if dp[i][j] == dp[i - 1][j - 1] + match:             if match == 1:                 seq = x[i - 1] + seq             i -= 1             j -= 1         elif dp[i][j] == dp[i - 1][j]:             i -= 1         else:             j -= 1      return dp[m][n], seq\n2: def is_palindrome(head: ListNode | None) -> bool:     if not head:         return True     # split the list to two parts     fast: ListNode | None = head.next_node     slow: ListNode | None = head     while fast and fast.next_node:         fast = fast.next_node.next_node         slow = slow.next_node if slow else None     if slow:         # slow will always be defined,         # adding this check to resolve mypy static check         second = slow.next_node         slow.next_node = None  # Don't forget here! But forget still works!     # reverse the second part     node: ListNode | None = None     while second:         nxt = second.next_node         second.next_node = node         node = second         second = nxt     # compare two parts     # second part has the same or one less node     while node and head:         if node.val != head.val:             return False         node = node.next_node         head = head.next_node     return True", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef evaluate_recursive(expression: list[str]):\n\n    op = expression.pop(0)\n    if is_operand(op):\n        return int(op)\n\n    operation = operators[op]\n\n    a = evaluate_recursive(expression)\n    b = evaluate_recursive(expression)\n    return operation(a, b)", "output": "Alternative recursive implementation"}
{"task": "search", "input": "search code:\nIs the bit at position set?\n\nChoices:\n0: def lstrip(iterable, strip_value=None):     return list(lstrip_iter(iterable, strip_value))\n1: def is_bit_set(number: int, position: int) -> bool:     return ((number >> position) & 1) == 1\n2: def convex_hull_bf(points: list[Point]) -> list[Point]:      points = sorted(_validate_input(points))     n = len(points)     convex_set = set()      for i in range(n - 1):         for j in range(i + 1, n):             points_left_of_ij = points_right_of_ij = False             ij_part_of_convex_hull = True             for k in range(n):                 if k not in {i, j}:                     det_k = _det(points[i], points[j], points[k])                      if det_k > 0:                         points_left_of_ij = True                     elif det_k < 0:                         points_right_of_ij = True                     # point[i], point[j], point[k] all lie on a straight line                     # if point[k] is to the left of point[i] or it's to the                     # right of point[j], then point[i], point[j] cannot be                     # part of the convex hull of A                     elif points[k] < points[i] or points[k] > points[j]:                         ij_part_of_convex_hull = False                         break                  if points_left_of_ij and points_right_of_ij:                     ij_part_of_convex_hull = False                     break              if ij_part_of_convex_hull:                 convex_set.update([points[i], points[j]])      return sorted(convex_set)", "output": "1"}
{"task": "search", "input": "search code:\nrotations and the index of the original string at ordered rotations list\n\nChoices:\n0: def invert_matrix(matrix: list[list[float]]) -> list[list[float]]:     np_matrix = np.array(matrix)      try:         inv_matrix = np.linalg.inv(np_matrix)     except np.linalg.LinAlgError:         raise ValueError(\"Matrix is not invertible\")      return inv_matrix.tolist()\n1: def bwt_transform(s: str) -> BWTTransformDict:     if not isinstance(s, str):         raise TypeError(\"The parameter s type must be str.\")     if not s:         raise ValueError(\"The parameter s must not be empty.\")      rotations = all_rotations(s)     rotations.sort()  # sort the list of rotations in alphabetically order     # make a string composed of the last char of each rotation     response: BWTTransformDict = {         \"bwt_string\": \"\".join([word[-1] for word in rotations]),         \"idx_original_string\": rotations.index(s),     }     return response\n2: def unit_basis_vector(dimension: int, pos: int) -> Vector:     # precondition     assert isinstance(dimension, int)     assert isinstance(pos, int)     ans = [0] * dimension     ans[pos] = 1     return Vector(ans)", "output": "1"}
{"task": "search", "input": "search code:\nReturn gray image from rgb image\n\nChoices:\n0: def solution() -> float:      peter_totals_frequencies = total_frequency_distribution(         sides_number=4, dice_number=9     )     colin_totals_frequencies = total_frequency_distribution(         sides_number=6, dice_number=6     )      peter_wins_count = 0     min_peter_total = 9     max_peter_total = 4 * 9     min_colin_total = 6     for peter_total in range(min_peter_total, max_peter_total + 1):         peter_wins_count += peter_totals_frequencies[peter_total] * sum(             colin_totals_frequencies[min_colin_total:peter_total]         )      total_games_number = (4**9) * (6**6)     peter_win_probability = peter_wins_count / total_games_number      rounded_peter_win_probability = round(peter_win_probability, ndigits=7)      return rounded_peter_win_probability\n1: def solution(min_block_length: int = 50) -> int:      fill_count_functions = [1] * min_block_length      for n in count(min_block_length):         fill_count_functions.append(1)          for block_length in range(min_block_length, n + 1):             for block_start in range(n - block_length):                 fill_count_functions[n] += fill_count_functions[                     n - block_start - block_length - 1                 ]              fill_count_functions[n] += 1          if fill_count_functions[n] > 1_000_000:             break      return n\n2: def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:     r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]     return 0.2989 * r + 0.5870 * g + 0.1140 * b", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:\n    arr.sort()\n    n = len(arr)\n    for i in range(n - 1):\n        left, right = i + 1, n - 1\n        while left < right:\n            if arr[i] + arr[left] + arr[right] == target:\n                return (arr[i], arr[left], arr[right])\n            elif arr[i] + arr[left] + arr[right] < target:\n                left += 1\n            elif arr[i] + arr[left] + arr[right] > target:\n                right -= 1\n    return (0, 0, 0)", "output": "Returns a triplet in the array with sum equal to target,"}
{"task": "summary", "input": "summarize code:\ndef slow_solution(max_number: int = 10**8) -> int:\n\n    prime_numbers = slow_calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left <= right:\n        while prime_numbers[left] * prime_numbers[right] >= max_number:\n            right -= 1\n        semiprimes_count += right - left + 1\n        left += 1\n\n    return semiprimes_count", "output": "Returns the number of composite integers below max_number have precisely two,"}
{"task": "detection", "input": "classify code:\ndef selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef invert_matrix(matrix: list[list[float]]) -> list[list[float]]:\n    np_matrix = np.array(matrix)\n\n    try:\n        inv_matrix = np.linalg.inv(np_matrix)\n    except np.linalg.LinAlgError:\n        raise ValueError(\"Matrix is not invertible\")\n\n    return inv_matrix.tolist()", "output": "Returns the inverse of a square matrix using NumPy."}
{"task": "summary", "input": "summarize code:\ndef is_prime(number: int) -> bool:\n\n    # precondition\n    if not isinstance(number, int) or not number >= 0:\n        raise ValueError(\"is_prime() only accepts positive integers\")\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True", "output": "Checks to see if a number is a prime in O(sqrt(n))."}
{"task": "summary", "input": "summarize code:\ndef num_digits(n: int) -> int:\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    digits = 0\n    n = abs(n)\n    while True:\n        n = n // 10\n        digits += 1\n        if n == 0:\n            break\n    return digits", "output": "Find the number of digits in a number."}
{"task": "detection", "input": "classify code:\ndef is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef draw_fractal_recursive(x: float, y: float, length: float, depth: float):\n    if depth == 0:\n        draw_cross(x, y, length)\n        return\n\n    draw_fractal_recursive(x, y, length / 3, depth - 1)\n    draw_fractal_recursive(x + length / 3, y, length / 3, depth - 1)\n    draw_fractal_recursive(x - length / 3, y, length / 3, depth - 1)\n    draw_fractal_recursive(x, y + length / 3, length / 3, depth - 1)\n    draw_fractal_recursive(x, y - length / 3, length / 3, depth - 1)", "output": "Recursively draw the Vicsek fractal at the specified position, with the"}
{"task": "search", "input": "search code:\nReturn the number of times a term occurs within\n\nChoices:\n0: def heap_sort(unsorted: list[int]) -> list[int]:     n = len(unsorted)     for i in range(n // 2 - 1, -1, -1):         heapify(unsorted, i, n)     for i in range(n - 1, 0, -1):         unsorted[0], unsorted[i] = unsorted[i], unsorted[0]         heapify(unsorted, 0, i)     return unsorted\n1: def term_frequency(term: str, document: str) -> int:     # strip all punctuation and newlines and replace it with ''     document_without_punctuation = document.translate(         str.maketrans(\"\", \"\", string.punctuation)     ).replace(\"\\n\", \"\")     tokenize_document = document_without_punctuation.split(\" \")  # word tokenization     return len([word for word in tokenize_document if word.lower() == term.lower()])\n2: def generate_image(cells: list[list[int]]) -> Image.Image:     # Create the output image     img = Image.new(\"RGB\", (len(cells[0]), len(cells)))     pixels = img.load()     # Generates image     for w in range(img.width):         for h in range(img.height):             color = 255 - int(255 * cells[h][w])             pixels[w, h] = (color, color, color)     return img", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef encrypt_message(\n    message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5\n) -> str:\n    message, alphabet, character_to_number, number_to_character = __prepare(\n        message, alphabet\n    )\n\n    encrypted_numeric = \"\"\n    for i in range(0, len(message) + 1, period):\n        encrypted_numeric += __encrypt_part(\n            message[i : i + period], character_to_number\n        )\n\n    encrypted = \"\"\n    for i in range(0, len(encrypted_numeric), 3):\n        encrypted += number_to_character[encrypted_numeric[i : i + 3]]\n    return encrypted", "output": "encrypt_message"}
{"task": "repair", "input": "fix bug:\ndef two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum([15, 2, 11, 7], 13)\n    [1, 2]\n    >>> two_sum([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum([7, 15, 11, 2], 18)\n    [0, 2]\n    >>> two_sum([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum([2, 7, 11, 15], 8)\n    []\n    >>> two_sum([3 * i for i in range(10)], 19)\n    []\n    \"\"\"\n    chk_map: dict[int, int] = {}\n    for index, val in enumerate(nums):\n        compl = target - val\n        if compl in chk_map:\n            return [chk_map[compl], index]\n        chk_map[val] = index\n    return []", "output": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum([15, 2, 11, 7], 13)\n    [1, 2]\n    >>> two_sum([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum([7, 15, 11, 2], 18)\n    [0, 2]\n    >>> two_sum([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum([2, 7, 11, 15], 8)\n    []\n    >>> two_sum([3 * i for i in range(10)], 19)\n    []\n    \"\"\"\n    chk_map: dict[int, int] = {}\n    for index, val in enumerate(nums):\n        compl = target - val\n        if compl in chk_map:\n            return [chk_map[compl], index]\n        chk_map[val] = index\n    return []"}
{"task": "detection", "input": "classify code:\ndef get_valid_pos(position: tuple[int], n: int) -> list[tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "CORRECT"}
{"task": "search", "input": "search code:\nWe merge 2 trees into one.\n\nChoices:\n0: def difference(iterable, func=sub, *, initial=None):     a, b = tee(iterable)     try:         first = [next(b)]     except StopIteration:         return iter([])      if initial is not None:         first = []      return chain(first, map(func, b, a))\n1: def merge(left: Node | None, right: Node | None) -> Node | None:     if (not left) or (not right):  # If one node is None, return the other         return left or right     elif left.prior < right.prior:         left.right = merge(left.right, right)         return left     else:         right.left = merge(left, right.left)         return right\n2: def modular_division2(a: int, b: int, n: int) -> int:     s = invert_modulo(a, n)     x = (b * s) % n     return x", "output": "1"}
{"task": "detection", "input": "classify code:\ndef find_longest_chain(chain: list[int], max_num: int) -> int:\n    \"\"\"\n    Finds the smallest element of longest chain\n\n    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n    6\n    \"\"\"\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch", "output": "def score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch"}
{"task": "search", "input": "search code:\nThis function calculates the average of the waiting times\n\nChoices:\n0: def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:     right = right or len(list_data) - 1     if left > right:         return -1     elif list_data[left] == key:         return left     elif list_data[right] == key:         return right     else:         return search(list_data, key, left + 1, right - 1)\n1: def calculate_average_waiting_time(waiting_times: list[int]) -> float:     return sum(waiting_times) / len(waiting_times)\n2: def sum_of_squares(it):     return _sumprod(*tee(it))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef resolve_path_parts(path_parts):\n    # TODO: what to do with multiple slashes\n    ret = []\n\n    for part in path_parts:\n        if part == '.':\n            pass\n        elif part == '..':\n            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting\n                ret.pop()\n        else:\n            ret.append(part)\n\n    if list(path_parts[-1:]) in (['.'], ['..']):\n        ret.append('')\n\n    return ret", "output": "Normalize the URL path by resolving segments of '.' and '..',"}
{"task": "search", "input": "search code:\nReturn an iterator flattening one level of nesting in a list of lists.\n\nChoices:\n0: def flatten(listOfLists):     return chain.from_iterable(listOfLists)\n1: def flip_bit(number: int, position: int) -> int:     return number ^ (1 << position)\n2: def power_of_4(number: int) -> bool:     if not isinstance(number, int):         raise TypeError(\"number must be an integer\")     if number <= 0:         raise ValueError(\"number must be positive\")     if number & (number - 1) == 0:         c = 0         while number:             c += 1             number >>= 1         return c % 2 == 1     else:         return False", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    import seaborn as sns\n\n    mpg_data = sns.load_dataset(\"mpg\")\n\n    poly_reg = PolynomialRegression(degree=2)\n    poly_reg.fit(mpg_data.weight, mpg_data.mpg)\n\n    weight_sorted = np.sort(mpg_data.weight)\n    predictions = poly_reg.predict(weight_sorted)\n\n    plt.scatter(mpg_data.weight, mpg_data.mpg, color=\"gray\", alpha=0.5)\n    plt.plot(weight_sorted, predictions, color=\"red\", linewidth=3)\n    plt.title(\"Predicting Fuel Efficiency Using Polynomial Regression\")\n    plt.xlabel(\"Weight (lbs)\")\n    plt.ylabel(\"Fuel Efficiency (mpg)\")\n    plt.show()", "output": "Fit a polynomial regression model to predict fuel efficiency using seaborn's mpg"}
{"task": "summary", "input": "summarize code:\ndef solve_all(grids, name=\"\", showif=0.0):\n\n    def time_solve(grid):\n        start = time.monotonic()\n        values = solve(grid)\n        t = time.monotonic() - start\n        ## Display puzzles that take long enough\n        if showif is not None and t > showif:\n            display(grid_values(grid))\n            if values:\n                display(values)\n            print(f\"({t:.5f} seconds)\\n\")\n        return (t, solved(values))\n\n    times, results = zip(*[time_solve(grid) for grid in grids])\n    if (n := len(grids)) > 1:\n        print(\n            \"Solved %d of %d %s puzzles (avg %.2f secs (%d Hz), max %.2f secs).\"  # noqa: UP031\n            % (sum(results), n, name, sum(times) / n, n / sum(times), max(times))\n        )", "output": "Attempt to solve a sequence of grids. Report results."}
{"task": "summary", "input": "summarize code:\ndef to_complex_case(text: str, upper: bool, separator: str) -> str:\n    try:\n        string_split = split_input(text)\n        if upper:\n            res_str = \"\".join(\n                [\n                    separator.join([char.upper() for char in sub_str])\n                    for sub_str in string_split\n                ]\n            )\n        else:\n            res_str = \"\".join(\n                [\n                    separator.join([char.lower() for char in sub_str])\n                    for sub_str in string_split\n                ]\n            )\n        return res_str\n    except IndexError:\n        return \"not valid string\"", "output": "Returns the string concatenated with the delimiter we provide."}
{"task": "summary", "input": "summarize code:\ndef issubclass(subclass, baseclass):\n    try:\n        return _issubclass(subclass, baseclass)\n    except TypeError:\n        return False", "output": "Just like the built-in :func:`issubclass`, this function checks"}
{"task": "detection", "input": "classify code:\ndef odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 200) -> int:\n    total = 0\n    for i in range(2, n + 1):\n        max_length = 0\n        while True:\n            nums = [1]\n            max_length += 1\n            if solve(nums=nums, goal=i, depth=max_length):\n                break\n        total += max_length\n    return total", "output": "Calculates sum of smallest number of multiplactions for each number up to"}
{"task": "summary", "input": "summarize code:\ndef iter_merge_sort(input_list: list) -> list:\n    if len(input_list) <= 1:\n        return input_list\n    input_list = list(input_list)\n\n    # iteration for two-way merging\n    p = 2\n    while p <= len(input_list):\n        # getting low, high and middle value for merge-sort of single list\n        for i in range(0, len(input_list), p):\n            low = i\n            high = i + p - 1\n            mid = (low + high + 1) // 2\n            input_list = merge(input_list, low, mid, high)\n        # final merge of last two parts\n        if p * 2 >= len(input_list):\n            mid = i\n            input_list = merge(input_list, 0, mid, len(input_list) - 1)\n            break\n        p *= 2\n\n    return input_list", "output": "Return a sorted copy of the input list"}
{"task": "summary", "input": "summarize code:\ndef circular_shifts(iterable, steps=1):\n    buffer = deque(iterable)\n    if steps == 0:\n        raise ValueError('Steps should be a non-zero integer')\n\n    buffer.rotate(steps)\n    steps = -steps\n    n = len(buffer)\n    n //= math.gcd(n, steps)\n\n    for _ in repeat(None, n):\n        buffer.rotate(steps)\n        yield tuple(buffer)", "output": "Yield the circular shifts of *iterable*."}
{"task": "search", "input": "search code:\nReturn all contiguous non-empty subslices of *iterable*.\n\nChoices:\n0: def extended_gcd(a: int, b: int) -> tuple[int, int, int]:     assert a >= 0     assert b >= 0      if b == 0:         d, x, y = a, 1, 0     else:         (d, p, q) = extended_gcd(b, a % b)         x = q         y = p - q * (a // b)      assert a % d == 0     assert b % d == 0     assert d == a * x + b * y      return (d, x, y)\n1: def subslices(iterable):     seq = list(iterable)     slices = starmap(slice, combinations(range(len(seq) + 1), 2))     return map(getitem, repeat(seq), slices)\n2: def transpose(it):     return zip(*it, strict=True)", "output": "1"}
{"task": "search", "input": "search code:\nPerforms multiplication of a graph's adjacency list representation with a vector.\n\nChoices:\n0: def multiply_matrix_vector(     graph: list[list[int | None]], vector: np.ndarray ) -> np.ndarray:     num_nodes: int = len(graph)     if vector.shape[0] != num_nodes:         raise ValueError(\"Vector length must match the number of nodes in the graph.\")      result: np.ndarray = np.zeros(num_nodes)     for node_index, neighbors in enumerate(graph):         for neighbor_index in neighbors:             result[node_index] += vector[neighbor_index]     return result\n1: def compress(source_path: str, destination_path: str) -> None:     data_bits = read_file_binary(source_path)     data_bits = remove_prefix(data_bits)     decompressed = decompress_data(data_bits)     write_file_binary(destination_path, decompressed)\n2: def distance(city1: list[int], city2: list[int]) -> float:     return (((city1[0] - city2[0]) ** 2) + ((city1[1] - city2[1]) ** 2)) ** 0.5", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef data_safety_checker(list_vote: list, actual_result: float) -> bool:\n    safe = 0\n    not_safe = 0\n\n    if not isinstance(actual_result, float):\n        raise TypeError(\"Actual result should be float. Value passed is a list\")\n\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        elif abs(abs(i) - abs(actual_result)) <= 0.1:\n            safe += 1\n        else:\n            not_safe += 1\n    return safe > not_safe", "output": "Used to review all the votes (list result prediction)"}
{"task": "search", "input": "search code:\nReturn the number of right triangles OPQ that can be formed by two points P, Q\n\nChoices:\n0: def check_direction(     starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int] ) -> Direction:     x0, y0 = starting     x1, y1 = via     x2, y2 = target     via_angle = degrees(atan2(y1 - y0, x1 - x0))     via_angle %= 360     target_angle = degrees(atan2(y2 - y0, x2 - x0))     target_angle %= 360     # t-     #  \\ \\     #   \\ v     #    \\|     #     s     # via_angle is always lower than target_angle, if direction is left.     # If they are same, it means they are on a same line of convex hull.     if target_angle > via_angle:         return Direction.left     elif target_angle == via_angle:         return Direction.straight     else:         return Direction.right\n1: def normalization(data: list, ndigits: int = 3) -> list:     # variables for calculation     x_min = min(data)     x_max = max(data)     # normalize data     return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]\n2: def solution(limit: int = 50) -> int:     return sum(         1         for pt1, pt2 in combinations(product(range(limit + 1), repeat=2), 2)         if is_right(*pt1, *pt2)     )", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef binary_tree_left_side_view(root: TreeNode) -> list[int]:\n\n    def depth_first_search(\n        root: TreeNode | None, depth: int, left_view: list[int]\n    ) -> None:\n        if not root:\n            return\n\n        if depth == len(left_view):\n            left_view.append(root.val)\n\n        depth_first_search(root.left, depth + 1, left_view)\n        depth_first_search(root.right, depth + 1, left_view)\n\n    left_view: list = []\n    if not root:\n        return left_view\n\n    depth_first_search(root, 0, left_view)\n    return left_view", "output": "Function returns the left side view of binary tree."}
{"task": "search", "input": "search code:\nRotates a list to the right by steps positions.\n\nChoices:\n0: def calculate_probabilities(instance_count: int, total_count: int) -> float:     # number of instances in specific class divided by number of all instances     return instance_count / total_count\n1: def rotate_array(arr: list[int], steps: int) -> list[int]:      n = len(arr)     if n == 0:         return arr      steps = steps % n      if steps < 0:         steps += n      def reverse(start: int, end: int) -> None:          while start < end:             arr[start], arr[end] = arr[end], arr[start]             start += 1             end -= 1      reverse(0, n - 1)     reverse(0, steps - 1)     reverse(steps, n - 1)      return arr\n2: def pairwise(src, end=_UNSET):     return windowed(src, 2, fill=end)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef create_state_space_tree(\n    sequence: list[int | str],\n    current_sequence: list[int | str],\n    index: int,\n    index_used: list[int],\n) -> None:\n\n    if index == len(sequence):\n        print(current_sequence)\n        return\n\n    for i in range(len(sequence)):\n        if not index_used[i]:\n            current_sequence.append(sequence[i])\n            index_used[i] = True\n            create_state_space_tree(sequence, current_sequence, index + 1, index_used)\n            current_sequence.pop()\n            index_used[i] = False", "output": "Creates a state space tree to iterate through each branch using DFS."}
{"task": "detection", "input": "classify code:\ndef bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1", "output": "BUGGY"}
