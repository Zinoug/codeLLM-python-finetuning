{"task": "summary", "input": "summarize code:\ndef bin_to_hexadecimal(binary_str: str) -> str:\n    # Sanitising parameter\n    binary_str = str(binary_str).strip()\n\n    # Exceptions\n    if not binary_str:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = binary_str[0] == \"-\"\n    binary_str = binary_str[1:] if is_negative else binary_str\n    if not all(char in \"01\" for char in binary_str):\n        raise ValueError(\"Non-binary value was passed to the function\")\n\n    binary_str = (\n        \"0\" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str\n    )\n\n    hexadecimal = []\n    for x in range(0, len(binary_str), 4):\n        hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])\n    hexadecimal_str = \"0x\" + \"\".join(hexadecimal)\n\n    return \"-\" + hexadecimal_str if is_negative else hexadecimal_str", "output": "Converting a binary string into hexadecimal using Grouping Method"}
{"task": "search", "input": "search code:\nReturns the number under n that generates the longest sequence using the\n\nChoices:\n0: def solution(min_total: int = 10**12) -> int:      prev_numerator = 1     prev_denominator = 0      numerator = 1     denominator = 1      while numerator <= 2 * min_total - 1:         prev_numerator += 2 * numerator         numerator += 2 * prev_numerator          prev_denominator += 2 * denominator         denominator += 2 * prev_denominator      return (denominator + 1) // 2\n1: def read_file_binary(file_path: str) -> str:     result = \"\"     try:         with open(file_path, \"rb\") as binary_file:             data = binary_file.read()         for dat in data:             curr_byte = f\"{dat:08b}\"             result += curr_byte         return result     except OSError:         print(\"File not accessible\")         sys.exit()\n2: def solution(n: int = 1000000) -> int:     largest_number = 1     pre_counter = 1     counters = {1: 1}      for input1 in range(2, n):         counter = 0         number = input1          while True:             if number in counters:                 counter += counters[number]                 break             if number % 2 == 0:                 number //= 2                 counter += 1             else:                 number = (3 * number) + 1                 counter += 1          if input1 not in counters:             counters[input1] = counter          if counter > pre_counter:             largest_number = input1             pre_counter = counter     return largest_number", "output": "2"}
{"task": "detection", "input": "classify code:\ndef prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef validate_initial_digits(credit_card_number: str) -> bool:\n    return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))", "output": "Function to validate initial digits of a given credit card number."}
{"task": "repair", "input": "fix bug:\ndef tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)", "output": "def tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)"}
{"task": "detection", "input": "classify code:\ndef is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn the nth or the last item of *iterable*,\n\nChoices:\n0: def perfect_cube_binary_search(n: int) -> bool:     if not isinstance(n, int):         raise TypeError(\"perfect_cube_binary_search() only accepts integers\")     if n < 0:         n = -n     left = 0     right = n     while left <= right:         mid = left + (right - left) // 2         if mid * mid * mid == n:             return True         elif mid * mid * mid < n:             left = mid + 1         else:             right = mid - 1     return False\n1: def valid_input(     input_type: Callable[[object], num],  # Usually float or int     input_msg: str,     err_msg: str,     condition: Callable[[num], bool] = lambda _: True,     default: str | None = None, ) -> num:     while True:         try:             user_input = input_type(input(input_msg).strip() or default)             if condition(user_input):                 return user_input             else:                 print(f\"{user_input}: {err_msg}\")                 continue         except ValueError:             print(                 f\"{user_input}: Incorrect input type, expected {input_type.__name__!r}\"             )\n2: def nth_or_last(iterable, n, default=_marker):     return last(islice(iterable, n + 1), default=default)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef run(n: int) -> list[int]:\n\n    # Incrementor variable for our group list comprehension.\n    # This is the first number in each list of values\n    # to test.\n    base = 2\n\n    while True:\n        # Increment each value of a generated range\n        group = [base + i for i in range(n)]\n\n        # Run elements through the unique_prime_factors function\n        # Append our target number to the end.\n        checker = [upf_len(x) for x in group]\n        checker.append(n)\n\n        # If all numbers in the list are equal, return the group variable.\n        if equality(checker):\n            return group\n\n        # Increment our base variable by 1\n        base += 1", "output": "Runs core process to find problem solution."}
{"task": "search", "input": "search code:\nCalculates the first n (1-indexed) Fibonacci numbers using iteration with yield\n\nChoices:\n0: def fib_iterative_yield(n: int) -> Iterator[int]:     if n < 0:         raise ValueError(\"n is negative\")     a, b = 0, 1     yield a     for _ in range(n):         yield b         a, b = b, a + b\n1: def build_sparse_table(number_list: list[int]) -> list[list[int]]:     if not number_list:         raise ValueError(\"empty number list not allowed\")      length = len(number_list)     # Initialise sparse_table -- sparse_table[j][i] represents the minimum value of the     # subset of length (2 ** j) of number_list, starting from index i.      # smallest power of 2 subset length that fully covers number_list     row = int(log2(length)) + 1     sparse_table = [[0 for i in range(length)] for j in range(row)]      # minimum of subset of length 1 is that value itself     for i, value in enumerate(number_list):         sparse_table[0][i] = value     j = 1      # compute the minimum value for all intervals with size (2 ** j)     while (1 << j) <= length:         i = 0         # while subset starting from i still have at least (2 ** j) elements         while (i + (1 << j) - 1) < length:             # split range [i, i + 2 ** j] and find minimum of 2 halves             sparse_table[j][i] = min(                 sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]             )             i += 1         j += 1     return sparse_table\n2: def num_digits_fast(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      return 1 if n == 0 else math.floor(math.log(abs(n), 10) + 1)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef extended_euclidean_algorithm(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b", "output": "def extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b"}
{"task": "summary", "input": "summarize code:\ndef stalin_sort(sequence: list[int]) -> list[int]:\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result", "output": "Sorts a list using the Stalin sort algorithm."}
{"task": "repair", "input": "fix bug:\ndef _msd_radix_sort(list_of_ints: List[int], bit_position: int) -> List[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res", "output": "def _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res"}
{"task": "search", "input": "search code:\nA convenience function to get standard summary statistics useful\n\nChoices:\n0: def describe(data, quantiles=None, format=None):     return Stats(data).describe(quantiles=quantiles, format=format)\n1: def erase(root: Node | None, value: int) -> Node | None:     left, right = split(root, value - 1)     _, right = split(right, value)     return merge(left, right)\n2: def second_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )", "output": "0"}
{"task": "detection", "input": "classify code:\ndef combination_sum_iv_dp_array(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations with using bottom up approach,\n    and returns the count of possible combination in O(N^2) Time Complexity\n    as we are using Dynamic programming array here.\n\n    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    dp_array = [0] * (target + 1)\n    dp_array[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - array[j] >= 0:\n                dp_array[i] += dp_array[i - array[j]]\n\n    return dp_array[target]", "output": "def combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations with using bottom up approach,\n    and returns the count of possible combination in O(N^2) Time Complexity\n    as we are using Dynamic programming array here.\n\n    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    dp_array = [0] * (target + 1)\n    dp_array[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - array[j] >= 0:\n                dp_array[i] += dp_array[i - array[j]]\n\n    return dp_array[target]"}
{"task": "detection", "input": "classify code:\ndef levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef mish(vector: np.ndarray) -> np.ndarray:\n    return vector * np.tanh(softplus(vector))", "output": "Implements the Mish activation function."}
{"task": "search", "input": "search code:\nUsage examples:\n\nChoices:\n0: def quantum_fourier_transform(number_of_qubits: int = 3) -> qiskit.result.counts.Counts:     if isinstance(number_of_qubits, str):         raise TypeError(\"number of qubits must be a integer.\")     if number_of_qubits <= 0:         raise ValueError(\"number of qubits must be > 0.\")     if math.floor(number_of_qubits) != number_of_qubits:         raise ValueError(\"number of qubits must be exact integer.\")     if number_of_qubits > 10:         raise ValueError(\"number of qubits too large to simulate(>10).\")      qr = QuantumRegister(number_of_qubits, \"qr\")     cr = ClassicalRegister(number_of_qubits, \"cr\")      quantum_circuit = QuantumCircuit(qr, cr)      counter = number_of_qubits      for i in range(counter):         quantum_circuit.h(number_of_qubits - i - 1)         counter -= 1         for j in range(counter):             quantum_circuit.cp(np.pi / 2 ** (counter - j), j, counter)      for k in range(number_of_qubits // 2):         quantum_circuit.swap(k, number_of_qubits - k - 1)      # measure all the qubits     quantum_circuit.measure(qr, cr)     # simulate with 10000 shots     backend = Aer.get_backend(\"qasm_simulator\")     job = execute(quantum_circuit, backend, shots=10000)      return job.result().get_counts(quantum_circuit)\n1: def astable_duty_cycle(resistance_1: float, resistance_2: float) -> float:      if resistance_1 <= 0 or resistance_2 <= 0:         raise ValueError(\"All values must be positive\")     return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100\n2: def is_arithmetic_series(series: list) -> bool:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     if len(series) == 1:         return True     common_diff = series[1] - series[0]     for index in range(len(series) - 1):         if series[index + 1] - series[index] != common_diff:             return False     return True", "output": "1"}
{"task": "detection", "input": "classify code:\ndef is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )", "output": "BUGGY"}
{"task": "search", "input": "search code:\nGo through the number of iterations determined by the argument \"steps\".\n\nChoices:\n0: def circle_sort(collection: list) -> list:      if len(collection) < 2:         return collection      def circle_sort_util(collection: list, low: int, high: int) -> bool:          swapped = False          if low == high:             return swapped          left = low         right = high          while left < right:             if collection[left] > collection[right]:                 collection[left], collection[right] = (                     collection[right],                     collection[left],                 )                 swapped = True              left += 1             right -= 1          if left == right and collection[left] > collection[right + 1]:             collection[left], collection[right + 1] = (                 collection[right + 1],                 collection[left],             )              swapped = True          mid = low + int((high - low) / 2)         left_swap = circle_sort_util(collection, low, mid)         right_swap = circle_sort_util(collection, mid + 1, high)          return swapped or left_swap or right_swap      is_not_sorted = True      while is_not_sorted is True:         is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)      return collection\n1: def iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:     vectors = initial_vectors     for _ in range(steps):         vectors = iteration_step(vectors)     return vectors\n2: def eval_exponential(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:     return np.exp(z_values) + c_parameter", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef map_if(iterable, pred, func, func_else=None):\n\n    if func_else is None:\n        for item in iterable:\n            yield func(item) if pred(item) else item\n\n    else:\n        for item in iterable:\n            yield func(item) if pred(item) else func_else(item)", "output": "Evaluate each item from *iterable* using *pred*. If the result is"}
{"task": "repair", "input": "fix bug:\ndef prefix_function(input_string: str) -> list:\n    \"\"\"\n    For the given string this function computes value for each index(i),\n    which represents the longest coincidence of prefix and suffix\n    for given substring (input_str[0...i])\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> prefix_function(\"aabcdaabc\")\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\n    >>> prefix_function(\"asdasdad\")\n    [0, 0, 0, 1, 2, 3, 4, 0]\n    \"\"\"\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result", "output": "def prefix_function(input_string: str) -> list:\n    \"\"\"\n    For the given string this function computes value for each index(i),\n    which represents the longest coincidence of prefix and suffix\n    for given substring (input_str[0...i])\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> prefix_function(\"aabcdaabc\")\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\n    >>> prefix_function(\"asdasdad\")\n    [0, 0, 0, 1, 2, 3, 4, 0]\n    \"\"\"\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result"}
{"task": "search", "input": "search code:\nInput Parameters:\n\nChoices:\n0: def validate(*values: float) -> bool:     result = len(values) > 0 and all(value > 0.0 for value in values)     return result\n1: def calculate_signal_power(audio_fft: np.ndarray) -> np.ndarray:     # Calculate the power by squaring the absolute values of the FFT coefficients     return np.square(np.abs(audio_fft))\n2: def pluperfect_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False      # Init a \"histogram\" of the digits     digit_histogram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]     digit_total = 0     total = 0     temp = n     while temp > 0:         temp, rem = divmod(temp, 10)         digit_histogram[rem] += 1         digit_total += 1      for cnt, i in zip(digit_histogram, range(len(digit_histogram))):         total += cnt * i**digit_total      return n == total", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef pigeon_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "def pigeon_sort(array: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array"}
{"task": "summary", "input": "summarize code:\ndef time_func(func, *args, **kwargs):\n    start = time()\n    output = func(*args, **kwargs)\n    end = time()\n    if int(end - start) > 0:\n        print(f\"{func.__name__} runtime: {(end - start):0.4f} s\")\n    else:\n        print(f\"{func.__name__} runtime: {(end - start) * 1000:0.4f} ms\")\n    return output", "output": "Times the execution of a function with parameters"}
{"task": "detection", "input": "classify code:\ndef selection(chart: List[List[int]], prime_implicants: List[str]) -> List[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFind Minimum Number in a List\n\nChoices:\n0: def catalan_numbers(upper_limit: int) -> \"list[int]\":     if upper_limit < 0:         raise ValueError(\"Limit for the Catalan sequence must be â‰¥ 0\")      catalan_list = [0] * (upper_limit + 1)      # Base case: C(0) = C(1) = 1     catalan_list[0] = 1     if upper_limit > 0:         catalan_list[1] = 1      # Recurrence relation: C(i) = sum(C(j).C(i-j-1)), from j = 0 to i     for i in range(2, upper_limit + 1):         for j in range(i):             catalan_list[i] += catalan_list[j] * catalan_list[i - j - 1]      return catalan_list\n1: def not_gate(input_1: int) -> int:      return 1 if input_1 == 0 else 0\n2: def find_min_iterative(nums: list[int | float]) -> int | float:     if len(nums) == 0:         raise ValueError(\"find_min_iterative() arg is an empty sequence\")     min_num = nums[0]     for num in nums:         min_num = min(min_num, num)     return min_num", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "def calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]"}
{"task": "summary", "input": "summarize code:\ndef nth_permutation(iterable, r, index):\n    pool = list(iterable)\n    n = len(pool)\n\n    if r is None or r == n:\n        r, c = n, factorial(n)\n    elif not 0 <= r < n:\n        raise ValueError\n    else:\n        c = perm(n, r)\n    assert c > 0  # factorial(n)>0, and r<n so perm(n,r) is never zero\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = [0] * r\n    q = index * factorial(n) // c if r < n else index\n    for d in range(1, n + 1):\n        q, i = divmod(q, d)\n        if 0 <= n - d < r:\n            result[n - d] = i\n        if q == 0:\n            break\n\n    return tuple(map(pool.pop, result))", "output": "Equivalent to ``list(permutations(iterable, r))[index]```"}
{"task": "detection", "input": "classify code:\ndef median(nums: list) -> Union[int, float]:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns a list of nodes value from a whole binary tree in Level Order Traverse.\n\nChoices:\n0: def pairwise_iter(src, end=_UNSET):     return windowed_iter(src, 2, fill=end)\n1: def my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:     kernels = {         1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),         3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),         5: np.array(             [                 [0, 0, -1, 0, 0],                 [0, -1, -2, -1, 0],                 [-1, -2, 16, -2, -1],                 [0, -1, -2, -1, 0],                 [0, 0, -1, 0, 0],             ]         ),         7: np.array(             [                 [0, 0, 0, -1, 0, 0, 0],                 [0, 0, -2, -3, -2, 0, 0],                 [0, -2, -7, -10, -7, -2, 0],                 [-1, -3, -10, 68, -10, -3, -1],                 [0, -2, -7, -10, -7, -2, 0],                 [0, 0, -2, -3, -2, 0, 0],                 [0, 0, 0, -1, 0, 0, 0],             ]         ),     }     if ksize not in kernels:         msg = f\"ksize must be in {tuple(kernels)}\"         raise ValueError(msg)      # Apply the Laplacian kernel using convolution     return filter2D(         src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)     )\n2: def level_order(root: Node | None) -> Generator[int]:      if root is None:         return      process_queue = deque([root])      while process_queue:         node = process_queue.popleft()         yield node.data          if node.left:             process_queue.append(node.left)         if node.right:             process_queue.append(node.right)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef max_sub_array(nums: List[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef collect_dataset() -> tuple[ndarray, ndarray]:\n    iris_dataset = load_iris()\n    return np.array(iris_dataset.data), np.array(iris_dataset.target)", "output": "Load the Iris dataset and return features and labels."}
{"task": "repair", "input": "fix bug:\ndef three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )", "output": "def three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )"}
{"task": "detection", "input": "classify code:\ndef is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True", "output": "CORRECT"}
{"task": "search", "input": "search code:\nInput Parameters\n\nChoices:\n0: def quick_sort(collection: list) -> list:     # Base case: if the collection has 0 or 1 elements, it is already sorted     if len(collection) < 2:         return collection      # Randomly select a pivot index and remove the pivot element from the collection     pivot_index = randrange(len(collection))     pivot = collection.pop(pivot_index)      # Partition the remaining elements into two groups: lesser or equal, and greater     lesser = [item for item in collection if item <= pivot]     greater = [item for item in collection if item > pivot]      # Recursively sort the lesser and greater groups, and combine with the pivot     return [*quick_sort(lesser), pivot, *quick_sort(greater)]\n1: def ind_reactance(     inductance: float, frequency: float, reactance: float ) -> dict[str, float]:      if (inductance, frequency, reactance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if inductance < 0:         raise ValueError(\"Inductance cannot be negative\")     if frequency < 0:         raise ValueError(\"Frequency cannot be negative\")     if reactance < 0:         raise ValueError(\"Inductive reactance cannot be negative\")     if inductance == 0:         return {\"inductance\": reactance / (2 * pi * frequency)}     elif frequency == 0:         return {\"frequency\": reactance / (2 * pi * inductance)}     elif reactance == 0:         return {\"reactance\": 2 * pi * frequency * inductance}     else:         raise ValueError(\"Exactly one argument must be 0\")\n2: def gravitational_law(     force: float, mass_1: float, mass_2: float, distance: float ) -> dict[str, float]:      product_of_mass = mass_1 * mass_2      if (force, mass_1, mass_2, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if force < 0:         raise ValueError(\"Gravitational force can not be negative\")     if distance < 0:         raise ValueError(\"Distance can not be negative\")     if mass_1 < 0 or mass_2 < 0:         raise ValueError(\"Mass can not be negative\")     if force == 0:         force = GRAVITATIONAL_CONSTANT * product_of_mass / (distance**2)         return {\"force\": force}     elif mass_1 == 0:         mass_1 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_2)         return {\"mass_1\": mass_1}     elif mass_2 == 0:         mass_2 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_1)         return {\"mass_2\": mass_2}     elif distance == 0:         distance = (GRAVITATIONAL_CONSTANT * product_of_mass / (force)) ** 0.5         return {\"distance\": distance}     raise ValueError(\"One and only one argument must be 0\")", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None", "output": "def find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 4000000) -> int:\n\n    if n <= 1:\n        return 0\n    a = 0\n    b = 2\n    count = 0\n    while 4 * b + a <= n:\n        a, b = b, 4 * b + a\n        count += a\n    return count + b", "output": "Returns the sum of all even fibonacci sequence elements that are lower"}
{"task": "search", "input": "search code:\nReturns two maps of (*types*, *funcs*) from *mod*, optionally\n\nChoices:\n0: def assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:     if i == 0 and j == 0:         return []     elif ops[i][j][0] in {\"C\", \"R\"}:         seq = assemble_transformation(ops, i - 1, j - 1)         seq.append(ops[i][j])         return seq     elif ops[i][j][0] == \"D\":         seq = assemble_transformation(ops, i - 1, j)         seq.append(ops[i][j])         return seq     else:         seq = assemble_transformation(ops, i, j - 1)         seq.append(ops[i][j])         return seq\n1: def repeat_each(iterable, n=2):     return chain.from_iterable(map(repeat, iterable, repeat(n)))\n2: def get_module_callables(mod, ignore=None):     if isinstance(mod, str):         mod = sys.modules[mod]     types, funcs = {}, {}     for attr_name in dir(mod):         if ignore and ignore(attr_name):             continue         try:             attr = getattr(mod, attr_name)         except Exception:             continue         try:             attr_mod_name = attr.__module__         except AttributeError:             continue         if attr_mod_name != mod.__name__:             continue         if isinstance(attr, type):             types[attr_name] = attr         elif callable(attr):             funcs[attr_name] = attr     return types, funcs", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef match_pattern(input_string: str, pattern: str) -> bool:\n    \"\"\"\n    uses bottom-up dynamic programming solution for matching the input\n    string with a given pattern.\n\n    Runtime: O(len(input_string)*len(pattern))\n\n    Arguments\n    --------\n    input_string: str, any string which should be compared with the pattern\n    pattern: str, the string that represents a pattern and may contain\n    '.' for single character matches and '*' for zero or more of preceding character\n    matches\n\n    Note\n    ----\n    the pattern cannot start with a '*',\n    because there should be at least one character before *\n\n    Returns\n    -------\n    A Boolean denoting whether the given string follows the pattern\n\n    Examples\n    -------\n    >>> match_pattern(\"aab\", \"c*a*b\")\n    True\n    >>> match_pattern(\"dabc\", \"*abc\")\n    False\n    >>> match_pattern(\"aaa\", \"aa\")\n    False\n    >>> match_pattern(\"aaa\", \"a.a\")\n    True\n    >>> match_pattern(\"aaab\", \"aa*\")\n    False\n    >>> match_pattern(\"aaab\", \".*\")\n    True\n    >>> match_pattern(\"a\", \"bbbb\")\n    False\n    >>> match_pattern(\"\", \"bbbb\")\n    False\n    >>> match_pattern(\"a\", \"\")\n    False\n    >>> match_pattern(\"\", \"\")\n    True\n    \"\"\"\n\n    len_string = len(input_string) + 1\n    len_pattern = len(pattern) + 1\n\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\n    # length i of input_string matches with prefix string of length j of\n    # given pattern.\n    # \"dp\" stands for dynamic programming.\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\n\n    # since string of zero length match pattern of zero length\n    dp[0][0] = 1\n\n    # since pattern of zero length will never match with string of non-zero length\n    for i in range(1, len_string):\n        dp[i][0] = 0\n\n    # since string of zero length will match with pattern where there\n    # is at least one * alternatively\n    for j in range(1, len_pattern):\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \"*\" else 0\n\n    # now using bottom-up approach to find for all remaining lengths\n    for i in range(1, len_string):\n        for j in range(1, len_pattern):\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \".\":\n                dp[i][j] = dp[i - 1][j - 1]\n\n            elif pattern[j - 1] == \"*\":\n                if dp[i][j - 2] == 1:\n                    dp[i][j] = 1\n                elif pattern[j - 2] in (input_string[i - 1], \".\"):\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n\n    return bool(dp[-1][-1])", "output": "def match_pattern(input_string: str, pattern: str) -> bool:\n    \"\"\"\n    uses bottom-up dynamic programming solution for matching the input\n    string with a given pattern.\n\n    Runtime: O(len(input_string)*len(pattern))\n\n    Arguments\n    --------\n    input_string: str, any string which should be compared with the pattern\n    pattern: str, the string that represents a pattern and may contain\n    '.' for single character matches and '*' for zero or more of preceding character\n    matches\n\n    Note\n    ----\n    the pattern cannot start with a '*',\n    because there should be at least one character before *\n\n    Returns\n    -------\n    A Boolean denoting whether the given string follows the pattern\n\n    Examples\n    -------\n    >>> match_pattern(\"aab\", \"c*a*b\")\n    True\n    >>> match_pattern(\"dabc\", \"*abc\")\n    False\n    >>> match_pattern(\"aaa\", \"aa\")\n    False\n    >>> match_pattern(\"aaa\", \"a.a\")\n    True\n    >>> match_pattern(\"aaab\", \"aa*\")\n    False\n    >>> match_pattern(\"aaab\", \".*\")\n    True\n    >>> match_pattern(\"a\", \"bbbb\")\n    False\n    >>> match_pattern(\"\", \"bbbb\")\n    False\n    >>> match_pattern(\"a\", \"\")\n    False\n    >>> match_pattern(\"\", \"\")\n    True\n    \"\"\"\n\n    len_string = len(input_string) + 1\n    len_pattern = len(pattern) + 1\n\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\n    # length i of input_string matches with prefix string of length j of\n    # given pattern.\n    # \"dp\" stands for dynamic programming.\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\n\n    # since string of zero length match pattern of zero length\n    dp[0][0] = 1\n\n    # since pattern of zero length will never match with string of non-zero length\n    for i in range(1, len_string):\n        dp[i][0] = 0\n\n    # since string of zero length will match with pattern where there\n    # is at least one * alternatively\n    for j in range(1, len_pattern):\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \"*\" else 0\n\n    # now using bottom-up approach to find for all remaining lengths\n    for i in range(1, len_string):\n        for j in range(1, len_pattern):\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \".\":\n                dp[i][j] = dp[i - 1][j - 1]\n\n            elif pattern[j - 1] == \"*\":\n                if dp[i][j - 2] == 1:\n                    dp[i][j] = 1\n                elif pattern[j - 2] in (input_string[i - 1], \".\"):\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n\n    return bool(dp[-1][-1])"}
{"task": "summary", "input": "summarize code:\ndef _hypothesis_value(data_input_tuple):\n    hyp_val = 0\n    for i in range(len(parameter_vector) - 1):\n        hyp_val += data_input_tuple[i] * parameter_vector[i + 1]\n    hyp_val += parameter_vector[0]\n    return hyp_val", "output": "Calculates hypothesis function value for a given input"}
{"task": "detection", "input": "classify code:\ndef equality(iterable: list) -> bool:\n    \"\"\"\n    Check the equality of ALL elements in an iterable\n    >>> equality([1, 2, 3, 4])\n    False\n    >>> equality([2, 2, 2, 2])\n    True\n    >>> equality([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    return len(set(iterable)) in (0, 1)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n    return compute_nums(1)[0]", "output": "Return the solution to the problem"}
{"task": "search", "input": "search code:\nDetermine whether the string is a valid phone number or not\n\nChoices:\n0: def solution(n: int = 20) -> int:     n = 2 * n  # middle entry of odd rows starting at row 3 is the solution for n = 1,     # 2, 3,...     k = n // 2      return int(factorial(n) / (factorial(k) * factorial(n - k)))\n1: def indian_phone_validator(phone: str) -> bool:     pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")     if match := re.search(pat, phone):         return match.string == phone     return False\n2: def get_module_callables(mod, ignore=None):     if isinstance(mod, str):         mod = sys.modules[mod]     types, funcs = {}, {}     for attr_name in dir(mod):         if ignore and ignore(attr_name):             continue         try:             attr = getattr(mod, attr_name)         except Exception:             continue         try:             attr_mod_name = attr.__module__         except AttributeError:             continue         if attr_mod_name != mod.__name__:             continue         if isinstance(attr, type):             types[attr_name] = attr         elif callable(attr):             funcs[attr_name] = attr     return types, funcs", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef combination_sum_iv(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)", "output": "def combination_sum_iv(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)"}
{"task": "detection", "input": "classify code:\ndef is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef scalar_multiply(matrix: list[list], n: int) -> list[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef rstrip_iter(iterable, strip_value=None):\n    iterator = iter(iterable)\n    for i in iterator:\n        if i == strip_value:\n            cache = list()\n            cache.append(i)\n            broken = False\n            for i in iterator:\n                if i == strip_value:\n                    cache.append(i)\n                else:\n                    broken = True\n                    break\n            if not broken:  # Return to caller here because the end of the\n                return     # iterator has been reached\n            yield from cache\n        yield i", "output": "Strips values from the end of an iterable. Stripped items will"}
{"task": "search", "input": "search code:\n:param n: dimension for nxn matrix\n\nChoices:\n0: def find_repeat(     matrix_g: list[list[str]], row: int, column: int, size: int ) -> set[tuple[int, int]]:      column = size - 1 - column     visited = set()     repeated = set()      if (color := matrix_g[column][row]) != \"-\":          def dfs(row_n: int, column_n: int) -> None:             if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:                 return             if (row_n, column_n) in visited:                 return             visited.add((row_n, column_n))             if matrix_g[row_n][column_n] == color:                 repeated.add((row_n, column_n))                 dfs(row_n - 1, column_n)                 dfs(row_n + 1, column_n)                 dfs(row_n, column_n - 1)                 dfs(row_n, column_n + 1)          dfs(column, row)      return repeated\n1: def identity(n: int) -> list[list[int]]:     n = int(n)     return [[int(row == column) for column in range(n)] for row in range(n)]\n2: def run(n: int) -> list[int]:      # Incrementor variable for our group list comprehension.     # This is the first number in each list of values     # to test.     base = 2      while True:         # Increment each value of a generated range         group = [base + i for i in range(n)]          # Run elements through the unique_prime_factors function         # Append our target number to the end.         checker = [upf_len(x) for x in group]         checker.append(n)          # If all numbers in the list are equal, return the group variable.         if equality(checker):             return group          # Increment our base variable by 1         base += 1", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef base16_encode(inp: str) -> bytes:\n    \"\"\"\n    Encodes a given utf-8 string into base-16.\n\n    >>> base16_encode('Hello World!')\n    b'48656C6C6F20576F726C6421'\n    >>> base16_encode('HELLO WORLD!')\n    b'48454C4C4F20574F524C4421'\n    >>> base16_encode('')\n    b''\n    \"\"\"\n    # encode the input into a bytes-like object and then encode b16encode that\n    return base64.b16encode(inp.encode(\"utf-8\"))", "output": "def base16_encode(data: bytes) -> str:\n    \"\"\"\n    Encodes the given bytes into base16.\n\n    >>> base16_encode(b'Hello World!')\n    '48656C6C6F20576F726C6421'\n    >>> base16_encode(b'HELLO WORLD!')\n    '48454C4C4F20574F524C4421'\n    >>> base16_encode(b'')\n    ''\n    \"\"\"\n    # Turn the data into a list of integers (where each integer is a byte),\n    # Then turn each byte into its hexadecimal representation, make sure\n    # it is uppercase, and then join everything together and return it.\n    return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])"}
{"task": "search", "input": "search code:\nAn extension of :func:`reversed` that supports all iterables, not\n\nChoices:\n0: def always_reversible(iterable):     try:         return reversed(iterable)     except TypeError:         return reversed(list(iterable))\n1: def inorder(curr_node: Node | None) -> list[Node]:     node_list = []     if curr_node is not None:         node_list = [*inorder(curr_node.left), curr_node, *inorder(curr_node.right)]     return node_list\n2: def _extract_labels(f, one_hot=False, num_classes=10):     print(\"Extracting\", f.name)     with gzip.GzipFile(fileobj=f) as bytestream:         magic = _read32(bytestream)         if magic != 2049:             msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"             raise ValueError(msg)         num_items = _read32(bytestream)         buf = bytestream.read(num_items)         labels = np.frombuffer(buf, dtype=np.uint8)         if one_hot:             return _dense_to_one_hot(labels, num_classes)         return labels", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)"}
{"task": "detection", "input": "classify code:\ndef two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(num: int = 100) -> int:\n    return sum(int(x) for x in str(factorial(num)))", "output": "Returns the sum of the digits in the factorial of num"}
{"task": "detection", "input": "classify code:\ndef real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]", "output": "def find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]"}
{"task": "summary", "input": "summarize code:\ndef left_rotation(node: MyNode) -> MyNode:\n    print(\"right rotation node:\", node.get_data())\n    ret = node.get_right()\n    assert ret is not None\n    node.set_right(ret.get_left())\n    ret.set_left(node)\n    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1\n    node.set_height(h1)\n    h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1\n    ret.set_height(h2)\n    return ret", "output": "a mirror symmetry rotation of the left_rotation"}
{"task": "search", "input": "search code:\nConvert grid into a dict of {square: char} with '0' or '.' for empties.\n\nChoices:\n0: def interpolation_search(sorted_collection: list[int], item: int) -> int | None:     left = 0     right = len(sorted_collection) - 1      while left <= right:         # avoid divided by 0 during interpolation         if sorted_collection[left] == sorted_collection[right]:             if sorted_collection[left] == item:                 return left             return None          point = left + ((item - sorted_collection[left]) * (right - left)) // (             sorted_collection[right] - sorted_collection[left]         )          # out of range check         if point < 0 or point >= len(sorted_collection):             return None          current_item = sorted_collection[point]         if current_item == item:             return point         if point < left:             right = left             left = point         elif point > right:             left = right             right = point         elif item < current_item:             right = point - 1         else:             left = point + 1     return None\n1: def grid_values(grid):     chars = [c for c in grid if c in digits or c in \"0.\"]     assert len(chars) == 81     return dict(zip(squares, chars))\n2: def random_graph(     vertices_number: int, probability: float, directed: bool = False ) -> dict:     graph: dict = {i: [] for i in range(vertices_number)}      # if probability is greater or equal than 1, then generate a complete graph     if probability >= 1:         return complete_graph(vertices_number)     # if probability is lower or equal than 0, then return a graph without edges     if probability <= 0:         return graph      # for each couple of nodes, add an edge from u to v     # if the number randomly generated is greater than probability probability     for i in range(vertices_number):         for j in range(i + 1, vertices_number):             if random.random() < probability:                 graph[i].append(j)                 if not directed:                     # if the graph is undirected, add an edge in from j to i, either                     graph[j].append(i)     return graph", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef validate(n: int) -> bool:\n    return not (\n        len(str(n)) > 3\n        and (not is_prime(int(str(n)[-3:])) or not is_prime(int(str(n)[:3])))\n    )", "output": "To optimize the approach, we will rule out the numbers above 1000,"}
{"task": "repair", "input": "fix bug:\ndef largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up approach.\n\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n    0\n\n    \"\"\"\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area", "output": "def largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up approach.\n\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n    0\n\n    \"\"\"\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area"}
{"task": "search", "input": "search code:\nCalculate the turn around time of each processes\n\nChoices:\n0: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")      for value in (262144, 1125899906842624, 1267650600228229401496703205376):         for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):             benchmark_a_function(func, value)         print()\n1: def indian_phone_validator(phone: str) -> bool:     pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")     if match := re.search(pat, phone):         return match.string == phone     return False\n2: def calculate_turn_around_time(     process_name: list, arrival_time: list, burst_time: list, no_of_process: int ) -> list:      current_time = 0     # Number of processes finished     finished_process_count = 0     # Displays the finished process.     # If it is 0, the performance is completed if it is 1, before the performance.     finished_process = [0] * no_of_process     # List to include calculation results     turn_around_time = [0] * no_of_process      # Sort by arrival time.     burst_time = [burst_time[i] for i in np.argsort(arrival_time)]     process_name = [process_name[i] for i in np.argsort(arrival_time)]     arrival_time.sort()      while no_of_process > finished_process_count:         i = 0         while finished_process[i] == 1:             i += 1         current_time = max(current_time, arrival_time[i])          response_ratio = 0         # Index showing the location of the process being performed         loc = 0         # Saves the current response ratio.         temp = 0         for i in range(no_of_process):             if finished_process[i] == 0 and arrival_time[i] <= current_time:                 temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[                     i                 ]             if response_ratio < temp:                 response_ratio = temp                 loc = i          # Calculate the turn around time         turn_around_time[loc] = current_time + burst_time[loc] - arrival_time[loc]         current_time += burst_time[loc]         # Indicates that the process has been performed.         finished_process[loc] = 1         # Increase finished_process_count by 1         finished_process_count += 1      return turn_around_time", "output": "2"}
{"task": "detection", "input": "classify code:\ndef binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n    -1\n    \"\"\"\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef p_series(nth_term: int, power: int) -> list:\n    \"\"\"Pure Python implementation of P-Series algorithm\n\n    :return: The P-Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> p_series(5, 2)\n    [1, '1/4', '1/9', '1/16', '1/25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    [1, '1/0.25', '1/0.1111111111111111', '1/0.0625', '1/0.04']\n    >>> p_series(\"\", 1000)\n    ''\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    [1]\n    \"\"\"\n    if nth_term == \"\":\n        return nth_term\n    nth_term = int(nth_term)\n    power = int(power)\n    series = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1/{pow(temp + 1, int(power))}\" if series else 1)\n    return series", "output": "def p_series(nth_term: int | float | str, power: int | float | str) -> list[str]:\n    \"\"\"\n    Pure Python implementation of P-Series algorithm\n    :return: The P-Series starting from 1 to last (nth) term\n    Examples:\n    >>> p_series(5, 2)\n    ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']\n    >>> p_series(\"\", 1000)\n    ['']\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    ['1']\n    \"\"\"\n    if nth_term == \"\":\n        return [\"\"]\n    nth_term = int(nth_term)\n    power = int(power)\n    series: list[str] = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")\n    return series"}
{"task": "detection", "input": "classify code:\ndef dp_count(S, m, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 3, 4)\n    4\n    >>> dp_count([1, 2, 3], 3, 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 4, 10)\n    5\n    >>> dp_count([10], 1, 99)\n    0\n    >>> dp_count([4, 5, 6], 3, 0)\n    1\n    \"\"\"\n\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nBenchmark multiple functions, with three different length int values.\n\nChoices:\n0: def take(n, iterable):     return list(islice(iterable, n))\n1: def preprocess(edge_array):     for i in range(len(edge_array)):         for j in range(len(edge_array[i])):             t = edge_array[i][j].split(\"-\")             edge_array[i][j] = t\n2: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         # print(f\"{call:38} = {func(value)} -- {timing:.4f} seconds\")         print(f\"{call:38} -- {timing:.4f} seconds\")      for value in range(15):  # (1, 7, 14):         for func in (generate_pascal_triangle, generate_pascal_triangle_optimized):             benchmark_a_function(func, value)         print()", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef modular_division2(a: int, b: int, n: int) -> int:\n    s = invert_modulo(a, n)\n    x = (b * s) % n\n    return x", "output": "This function used the above inversion of a to find x = (b*a^(-1))mod n"}
{"task": "repair", "input": "fix bug:\ndef max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit", "output": "def max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit"}
{"task": "search", "input": "search code:\nExample function to calculate Mel Frequency Cepstral Coefficients\n\nChoices:\n0: def unwrap_text(text, ending='\\n\\n'):     all_grafs = []     cur_graf = []     for line in text.splitlines():         line = line.strip()         if line:             cur_graf.append(line)         else:             all_grafs.append(' '.join(cur_graf))             cur_graf = []     if cur_graf:         all_grafs.append(' '.join(cur_graf))     if ending is None:         return all_grafs     return ending.join(all_grafs)\n1: def example(wav_file_path: str = \"./path-to-file/sample.wav\") -> np.ndarray:     from scipy.io import wavfile      # Load the audio from the WAV file     sample_rate, audio = wavfile.read(wav_file_path)      # Calculate MFCCs     return mfcc(audio, sample_rate)\n2: def prime_generator() -> Iterator[int]:      num = 2     while True:         if is_prime(num):             yield num         num += 1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef digit_replacements(number: int) -> list[list[int]]:\n    number_str = str(number)\n    replacements = []\n    digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n\n    for duplicate in Counter(number_str) - Counter(set(number_str)):\n        family = [int(number_str.replace(duplicate, digit)) for digit in digits]\n        replacements.append(family)\n\n    return replacements", "output": "Returns all the possible families of digit replacements in a number which"}
{"task": "detection", "input": "classify code:\ndef is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result", "output": "def modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result"}
{"task": "detection", "input": "classify code:\ndef real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCheck that the arguments are valid\n\nChoices:\n0: def get_distance(highway_now: list, car_index: int) -> int:      distance = 0     cells = highway_now[car_index + 1 :]     for cell in range(len(cells)):  # May need a better name for this         if cells[cell] != -1:  # If the cell is not empty then             return distance  # we have the distance we wanted         distance += 1     # Here if the car is near the end of the highway     return distance + get_distance(highway_now, -1)\n1: def solution(n: int = 7) -> int:     pandigital_str = \"\".join(str(i) for i in range(1, n + 1))     perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]     pandigitals = [num for num in perm_list if is_prime(num)]     return max(pandigitals) if pandigitals else 0\n2: def check_args(init_velocity: float, angle: float) -> None:      # Ensure valid instance     if not isinstance(init_velocity, (int, float)):         raise TypeError(\"Invalid velocity. Should be an integer or float.\")      if not isinstance(angle, (int, float)):         raise TypeError(\"Invalid angle. Should be an integer or float.\")      # Ensure valid angle     if angle > 90 or angle < 1:         raise ValueError(\"Invalid angle. Range is 1-90 degrees.\")      # Ensure valid velocity     if init_velocity < 0:         raise ValueError(\"Invalid velocity. Should be a positive number.\")", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef knapsack_with_example_solution(w: int, wt: list, val: list):\n    if not (isinstance(wt, (list, tuple)) and isinstance(val, (list, tuple))):\n        raise ValueError(\n            \"Both the weights and values vectors must be either lists or tuples\"\n        )\n\n    num_items = len(wt)\n    if num_items != len(val):\n        msg = (\n            \"The number of weights must be the same as the number of values.\\n\"\n            f\"But got {num_items} weights and {len(val)} values\"\n        )\n        raise ValueError(msg)\n    for i in range(num_items):\n        if not isinstance(wt[i], int):\n            msg = (\n                \"All weights must be integers but got weight of \"\n                f\"type {type(wt[i])} at index {i}\"\n            )\n            raise TypeError(msg)\n\n    optimal_val, dp_table = knapsack(w, wt, val, num_items)\n    example_optional_set: set = set()\n    _construct_solution(dp_table, wt, num_items, w, example_optional_set)\n\n    return optimal_val, example_optional_set", "output": "Solves the integer weights knapsack problem returns one of"}
{"task": "search", "input": "search code:\nSorts a list using the binary insertion sort algorithm.\n\nChoices:\n0: def solution(min_block_length: int = 50) -> int:      fill_count_functions = [1] * min_block_length      for n in count(min_block_length):         fill_count_functions.append(1)          for block_length in range(min_block_length, n + 1):             for block_start in range(n - block_length):                 fill_count_functions[n] += fill_count_functions[                     n - block_start - block_length - 1                 ]              fill_count_functions[n] += 1          if fill_count_functions[n] > 1_000_000:             break      return n\n1: def binary_insertion_sort(collection: list) -> list:      n = len(collection)     for i in range(1, n):         value_to_insert = collection[i]         low = 0         high = i - 1          while low <= high:             mid = (low + high) // 2             if value_to_insert < collection[mid]:                 high = mid - 1             else:                 low = mid + 1         for j in range(i, low, -1):             collection[j] = collection[j - 1]         collection[low] = value_to_insert     return collection\n2: def largest_rectangle_area(heights: list[int]) -> int:     stack: list[int] = []     max_area = 0     heights = [*heights, 0]  # make a new list by appending the sentinel 0     n = len(heights)      for i in range(n):         # make sure the stack remains in increasing order         while stack and heights[i] < heights[stack[-1]]:             h = heights[stack.pop()]  # height of the bar             # if stack is empty, it means entire width can be taken from index 0 to i-1             w = i if not stack else i - stack[-1] - 1  # calculate width             max_area = max(max_area, h * w)          stack.append(i)      return max_area", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef choose(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n    >>> choose(4,2)\n    6\n    >>> choose(5,3)\n    10\n    >>> choose(20,6)\n    38760\n    \"\"\"\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)", "output": "def choose(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n    >>> choose(4,2)\n    6\n    >>> choose(5,3)\n    10\n    >>> choose(20,6)\n    38760\n    \"\"\"\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)"}
{"task": "summary", "input": "summarize code:\ndef summation_of_cost_derivative(index, end=m):\n    summation_value = 0\n    for i in range(end):\n        if index == -1:\n            summation_value += _error(i)\n        else:\n            summation_value += _error(i) * train_data[i][0][index]\n    return summation_value", "output": "Calculates the sum of cost function derivative"}
{"task": "detection", "input": "classify code:\ndef subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n\n    Args:\n        * `elements`: The list of elements from which combinations will be generated.\n        * `n`: The number of elements in each combination.\n\n    Returns:\n        A list of tuples, each representing a combination of `n` elements.\n\n    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n    >>> subset_combinations(elements=[1, 2, 3], n=1)\n    [(1,), (2,), (3,)]\n    >>> subset_combinations(elements=[1, 2, 3], n=3)\n    [(1, 2, 3)]\n    >>> subset_combinations(elements=[42], n=1)\n    [(42,)]\n    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n    [(6, 7, 8, 9)]\n    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n    [()]\n    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n    >>> subset_combinations(elements=['single'], n=0)\n    [()]\n    >>> subset_combinations(elements=[], n=9)\n    []\n    >>> from itertools import combinations\n    >>> all(subset_combinations(items, n) == list(combinations(items, n))\n    ...     for items, n in (\n    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n    True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef lstrip(iterable, strip_value=None):\n    return list(lstrip_iter(iterable, strip_value))", "output": "Strips values from the beginning of an iterable. Stripped items will"}
{"task": "search", "input": "search code:\nDivide `value` by `divisor` returning the quotient and remainder.\n\nChoices:\n0: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n1: def _quotient_and_remainder(value, divisor, unit, minimum_unit, suppress):     if unit == minimum_unit:         return (value / divisor, 0)     elif unit in suppress:         return (0, value)     else:         return divmod(value, divisor)\n2: def merge_sort(collection: list) -> list:      def merge(left: list, right: list) -> list:         result = []         while left and right:             result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))         result.extend(left)         result.extend(right)         return result      if len(collection) <= 1:         return collection     mid_index = len(collection) // 2     return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor", "output": "def real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor"}
{"task": "summary", "input": "summarize code:\ndef dilation(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:\n    output = np.zeros_like(image)\n    image_padded = np.zeros(\n        (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)\n    )\n\n    # Copy image to padded image\n    image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image\n\n    # Iterate over image & apply kernel\n    for x in range(image.shape[1]):\n        for y in range(image.shape[0]):\n            summation = (\n                kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]\n            ).sum()\n            output[y, x] = int(summation > 0)\n    return output", "output": "Return dilated image"}
{"task": "search", "input": "search code:\nTakes a format string, turns it into a list of alternating string\n\nChoices:\n0: def tokenize_format_str(fstr, resolve_pos=True):     ret = []     if resolve_pos:         fstr = infer_positional_format_args(fstr)     formatter = Formatter()     for lit, fname, fspec, conv in formatter.parse(fstr):         if lit:             ret.append(lit)         if fname is None:             continue         ret.append(BaseFormatField(fname, fspec, conv))     return ret\n1: def apply_tsne(     data_matrix: ndarray,     n_components: int = 2,     learning_rate: float = 200.0,     n_iter: int = 500, ) -> ndarray:     if n_components < 1 or n_iter < 1:         raise ValueError(\"n_components and n_iter must be >= 1\")      n_samples = data_matrix.shape[0]     rng = np.random.default_rng()     embedding = rng.standard_normal((n_samples, n_components)) * 1e-4      high_dim_affinities = compute_pairwise_affinities(data_matrix)     high_dim_affinities = np.maximum(high_dim_affinities, 1e-12)      embedding_increment = np.zeros_like(embedding)     momentum = 0.5      for iteration in range(n_iter):         low_dim_affinities, numerator_matrix = compute_low_dim_affinities(embedding)         low_dim_affinities = np.maximum(low_dim_affinities, 1e-12)          affinity_diff = high_dim_affinities - low_dim_affinities          gradient = 4 * (             np.dot((affinity_diff * numerator_matrix), embedding)             - np.multiply(                 np.sum(affinity_diff * numerator_matrix, axis=1)[:, np.newaxis],                 embedding,             )         )          embedding_increment = momentum * embedding_increment - learning_rate * gradient         embedding += embedding_increment          if iteration == int(n_iter / 4):             momentum = 0.8      return embedding\n2: def exactly_n(iterable, n, predicate=bool):     iterator = filter(predicate, iterable)     if n <= 0:         if n < 0:             return False         for _ in iterator:             return False         return True      iterator = islice(iterator, n - 1, None)     for _ in iterator:         for _ in iterator:             return False         return True     return False", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef apply_table(inp, table):\n    \"\"\"\n    >>> apply_table(\"0123456789\", list(range(10)))\n    '9012345678'\n    >>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n    '8765432109'\n    \"\"\"\n    res = \"\"\n    for i in table:\n        res += inp[i - 1]\n    return res", "output": "def apply_table(inp, table):\n    \"\"\"\n    >>> apply_table(\"0123456789\", list(range(10)))\n    '9012345678'\n    >>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n    '8765432109'\n    \"\"\"\n    res = \"\"\n    for i in table:\n        res += inp[i - 1]\n    return res"}
{"task": "detection", "input": "classify code:\ndef strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nSolves the integer weights knapsack problem returns one of\n\nChoices:\n0: def freq_to_mel(freq: float) -> float:     # Use the formula to convert frequency to the mel scale     return 2595.0 * np.log10(1.0 + freq / 700.0)\n1: def knapsack_with_example_solution(w: int, wt: list, val: list):     if not (isinstance(wt, (list, tuple)) and isinstance(val, (list, tuple))):         raise ValueError(             \"Both the weights and values vectors must be either lists or tuples\"         )      num_items = len(wt)     if num_items != len(val):         msg = (             \"The number of weights must be the same as the number of values.\\n\"             f\"But got {num_items} weights and {len(val)} values\"         )         raise ValueError(msg)     for i in range(num_items):         if not isinstance(wt[i], int):             msg = (                 \"All weights must be integers but got weight of \"                 f\"type {type(wt[i])} at index {i}\"             )             raise TypeError(msg)      optimal_val, dp_table = knapsack(w, wt, val, num_items)     example_optional_set: set = set()     _construct_solution(dp_table, wt, num_items, w, example_optional_set)      return optimal_val, example_optional_set\n2: def chunked(src, size, count=None, **kw):     chunk_iter = chunked_iter(src, size, **kw)     if count is None:         return list(chunk_iter)     else:         return list(itertools.islice(chunk_iter, count))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef generate_neighbours(path):\n\n    dict_of_neighbours = {}\n\n    with open(path) as f:\n        for line in f:\n            if line.split()[0] not in dict_of_neighbours:\n                _list = []\n                _list.append([line.split()[1], line.split()[2]])\n                dict_of_neighbours[line.split()[0]] = _list\n            else:\n                dict_of_neighbours[line.split()[0]].append(\n                    [line.split()[1], line.split()[2]]\n                )\n            if line.split()[1] not in dict_of_neighbours:\n                _list = []\n                _list.append([line.split()[0], line.split()[2]])\n                dict_of_neighbours[line.split()[1]] = _list\n            else:\n                dict_of_neighbours[line.split()[1]].append(\n                    [line.split()[0], line.split()[2]]\n                )\n\n    return dict_of_neighbours", "output": "Pure implementation of generating a dictionary of neighbors and the cost with each"}
{"task": "repair", "input": "fix bug:\ndef binary_multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply 'a' and 'b' using bitwise multiplication.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: a * b\n\n    Examples:\n    >>> binary_multiply(2, 3)\n    6\n    >>> binary_multiply(5, 0)\n    0\n    >>> binary_multiply(3, 4)\n    12\n    >>> binary_multiply(10, 5)\n    50\n    >>> binary_multiply(0, 5)\n    0\n    >>> binary_multiply(2, 1)\n    2\n    >>> binary_multiply(1, 10)\n    10\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res", "output": "def binary_multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply 'a' and 'b' using bitwise multiplication.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: a * b\n\n    Examples:\n    >>> binary_multiply(2, 3)\n    6\n    >>> binary_multiply(5, 0)\n    0\n    >>> binary_multiply(3, 4)\n    12\n    >>> binary_multiply(10, 5)\n    50\n    >>> binary_multiply(0, 5)\n    0\n    >>> binary_multiply(2, 1)\n    2\n    >>> binary_multiply(1, 10)\n    10\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res"}
{"task": "detection", "input": "classify code:\ndef prefix_function(input_string: str) -> list:\n    \"\"\"\n    For the given string this function computes value for each index(i),\n    which represents the longest coincidence of prefix and suffix\n    for given substring (input_str[0...i])\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> prefix_function(\"aabcdaabc\")\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\n    >>> prefix_function(\"asdasdad\")\n    [0, 0, 0, 1, 2, 3, 4, 0]\n    \"\"\"\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result", "output": "CORRECT"}
{"task": "search", "input": "search code:\nExtended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n\nChoices:\n0: def extended_gcd(a: int, b: int) -> tuple[int, int, int]:     assert a >= 0     assert b >= 0      if b == 0:         d, x, y = a, 1, 0     else:         (d, p, q) = extended_gcd(b, a % b)         x = q         y = p - q * (a // b)      assert a % d == 0     assert b % d == 0     assert d == a * x + b * y      return (d, x, y)\n1: def slow_solution(max_power: int = 9) -> int:     result = 0     for length in range(1, max_power + 1):         result += slow_reversible_numbers(length, 0, [0] * length, length)     return result\n2: def z_function(input_str: str) -> list[int]:     z_result = [0 for i in range(len(input_str))]      # initialize interval's left pointer and right pointer     left_pointer, right_pointer = 0, 0      for i in range(1, len(input_str)):         # case when current index is inside the interval         if i <= right_pointer:             min_edge = min(right_pointer - i + 1, z_result[i - left_pointer])             z_result[i] = min_edge          while go_next(i, z_result, input_str):             z_result[i] += 1          # if new index's result gives us more right interval,         # we've to update left_pointer and right_pointer         if i + z_result[i] - 1 > right_pointer:             left_pointer, right_pointer = i, i + z_result[i] - 1      return z_result", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]", "output": "def hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]"}
{"task": "detection", "input": "classify code:\ndef alt_ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    >>> alt_ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> alt_ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    \"\"\"\n    return int(\"0x\" + \"\".join(f\"{int(i):02x}\" for i in ipv4_address.split(\".\")), 16)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False", "output": "Return True if it's possible to search the word suffix"}
{"task": "summary", "input": "summarize code:\ndef get_parent_position(position: int) -> int:\n    return (position - 1) // 2", "output": "heap helper function get the position of the parent of the current node"}
{"task": "detection", "input": "classify code:\ndef linear_search(sequence, target):\n    \"\"\"Pure implementation of linear search algorithm in Python\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return None", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef minor(matrix: List[list], row: int, column: int) -> List[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]", "output": "def minor(matrix: list[list], row: int, column: int) -> list[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]"}
{"task": "search", "input": "search code:\nCheck if an integer is palindromic.\n\nChoices:\n0: def update_image_and_anno(     img_list: list, anno_list: list, flip_type: int = 1 ) -> tuple[list, list, list]:     new_annos_lists = []     path_list = []     new_imgs_list = []     for idx in range(len(img_list)):         new_annos = []         path = img_list[idx]         path_list.append(path)         img_annos = anno_list[idx]         img = cv2.imread(path)         if flip_type == 1:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 x_center_new = 1 - bbox[1]                 new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])         elif flip_type == 0:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 y_center_new = 1 - bbox[2]                 new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])         new_annos_lists.append(new_annos)         new_imgs_list.append(new_img)     return new_imgs_list, new_annos_lists, path_list\n1: def is_palindrome(n: int) -> bool:     if n % 10 == 0:         return False     s = str(n)     return s == s[::-1]\n2: def is_palindrome(n: int | str) -> bool:     n = str(n)     return n == n[::-1]", "output": "1"}
{"task": "search", "input": "search code:\nBenchmark the Levenshtein distance function.\n\nChoices:\n0: def score_function(     source_char: str,     target_char: str,     match: int = 1,     mismatch: int = -1,     gap: int = -2, ) -> int:     if \"-\" in (source_char, target_char):         return gap     return match if source_char == target_char else mismatch\n1: def printboard(board: list[list[int]]) -> None:     for i in range(len(board)):         for j in range(len(board)):             if board[i][j] == 1:                 print(\"Q\", end=\" \")  # Queen is present             else:                 print(\".\", end=\" \")  # Empty cell         print()\n2: def benchmark_levenshtein_distance(func: Callable) -> None:     from timeit import timeit      stmt = f\"{func.__name__}('sitting', 'kitten')\"     setup = f\"from __main__ import {func.__name__}\"     number = 25_000     result = timeit(stmt=stmt, setup=setup, number=number)     print(f\"{func.__name__:<30} finished {number:,} runs in {result:.5f} seconds\")", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef coulombs_law(q1: float, q2: float, radius: float) -> float:\n    \"\"\"\n    Calculate the electrostatic force of attraction or repulsion\n    between two point charges\n\n    >>> coulombs_law(15.5, 20, 15)\n    12382849136.06\n    >>> coulombs_law(1, 15, 5)\n    5392531075.38\n    >>> coulombs_law(20, -50, 15)\n    -39944674632.44\n    >>> coulombs_law(-5, -8, 10)\n    3595020716.92\n    >>> coulombs_law(50, 100, 50)\n    17975103584.6\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)", "output": "def coulombs_law(q1: float, q2: float, radius: float) -> float:\n    \"\"\"\n    Calculate the electrostatic force of attraction or repulsion\n    between two point charges\n\n    >>> coulombs_law(15.5, 20, 15)\n    12382849136.06\n    >>> coulombs_law(1, 15, 5)\n    5392531075.38\n    >>> coulombs_law(20, -50, 15)\n    -39944674632.44\n    >>> coulombs_law(-5, -8, 10)\n    3595020716.92\n    >>> coulombs_law(50, 100, 50)\n    17975103584.6\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)"}
{"task": "detection", "input": "classify code:\ndef is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n    limit = 7 * factorial(9) + 1\n    return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)", "output": "Returns the sum of all numbers whose"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    triangle_path = os.path.join(script_dir, \"triangle.txt\")\n\n    with open(triangle_path) as in_file:\n        triangle = [[int(i) for i in line.split()] for line in in_file]\n\n    while len(triangle) != 1:\n        last_row = triangle.pop()\n        curr_row = triangle[-1]\n        for j in range(len(last_row) - 1):\n            curr_row[j] += max(last_row[j], last_row[j + 1])\n    return triangle[0][0]", "output": "Finds the maximum total in a triangle as described by the problem statement"}
{"task": "repair", "input": "fix bug:\ndef fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]", "output": "def fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]"}
{"task": "detection", "input": "classify code:\ndef moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to volume.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_volume(0.82, 3, 300)\n      90\n      >>> moles_to_volume(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (pressure)))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nBounds for the nth prime (counting from 1): lb < p_n < ub.\n\nChoices:\n0: def _nth_prime_bounds(n):     # At and above 688,383, the lb/ub spread is under 0.003 * p_n.      if n < 1:         raise ValueError      if n < 6:         return (n, 2.25 * n)      # https://en.wikipedia.org/wiki/Prime-counting_function#Inequalities     upper_bound = n * log(n * log(n))     lower_bound = upper_bound - n     if n >= 688_383:         upper_bound -= n * (1.0 - (log(log(n)) - 2.0) / log(n))      return lower_bound, upper_bound\n1: def solution(n: int = 600851475143) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     i = 2     ans = 0     if n == 2:         return 2     while n > 2:         while n % i != 0:             i += 1         ans = i         while n % i == 0:             n = n // i         i += 1     return int(ans)\n2: def solution(n: int = 10000) -> int:     total = sum(         i         for i in range(1, n)         if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i     )     return total", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)", "output": "def knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)"}
{"task": "detection", "input": "classify code:\ndef swap_case(sentence: str) -> str:\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n\n    return new_string", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the difference between the sum of the squares of the first n\n\nChoices:\n0: def solution(n: int = 100) -> int:      sum_of_squares = sum(i * i for i in range(1, n + 1))     square_of_sum = int(math.pow(sum(range(1, n + 1)), 2))     return square_of_sum - sum_of_squares\n1: def throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:     dices = [Dice() for i in range(num_dice)]     count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)     for _ in range(num_throws):         count_of_sum[sum(dice.roll() for dice in dices)] += 1     probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]     return probability[num_dice:]  # remove probability of sums that never appear\n2: def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:     return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef generate_image(cells: list[list[int]]) -> Image.Image:\n    # Create the output image\n    img = Image.new(\"RGB\", (len(cells[0]), len(cells)))\n    pixels = img.load()\n    # Generates image\n    for w in range(img.width):\n        for h in range(img.height):\n            color = 255 - int(255 * cells[h][w])\n            pixels[w, h] = (color, color, color)\n    return img", "output": "Convert the cells into a greyscale PIL.Image.Image and return it to the caller."}
{"task": "search", "input": "search code:\nThis function is the inverse of :func:`itertools.accumulate`. By default\n\nChoices:\n0: def iter_merge_sort(input_list: list) -> list:     if len(input_list) <= 1:         return input_list     input_list = list(input_list)      # iteration for two-way merging     p = 2     while p <= len(input_list):         # getting low, high and middle value for merge-sort of single list         for i in range(0, len(input_list), p):             low = i             high = i + p - 1             mid = (low + high + 1) // 2             input_list = merge(input_list, low, mid, high)         # final merge of last two parts         if p * 2 >= len(input_list):             mid = i             input_list = merge(input_list, 0, mid, len(input_list) - 1)             break         p *= 2      return input_list\n1: def difference(iterable, func=sub, *, initial=None):     a, b = tee(iterable)     try:         first = [next(b)]     except StopIteration:         return iter([])      if initial is not None:         first = []      return chain(first, map(func, b, a))\n2: def lin_search(left: int, right: int, array: list[int], target: int) -> int:     for i in range(left, right):         if array[i] == target:             return i     return -1", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n\n    >>> split(\";abbb;;c;\", separator=';')\n    ['', 'abbb', '', 'c', '']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words"}
{"task": "summary", "input": "summarize code:\ndef display(values):\n    width = 1 + max(len(values[s]) for s in squares)\n    line = \"+\".join([\"-\" * (width * 3)] * 3)\n    for r in rows:\n        print(\n            \"\".join(\n                values[r + c].center(width) + (\"|\" if c in \"36\" else \"\") for c in cols\n            )\n        )\n        if r in \"CF\":\n            print(line)\n    print()", "output": "Display these values as a 2-D grid."}
{"task": "detection", "input": "classify code:\ndef capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Create a dictionary that maps lowercase letters to uppercase letters\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    lower_to_upper = dict(zip(ascii_lowercase, ascii_uppercase))\n    return lower_to_upper.get(sentence[0], sentence[0]) + sentence[1:]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nAssembles the transformations based on the ops table.\n\nChoices:\n0: def _ngettext_noop(singular, plural):     return (singular, plural)\n1: def solution(n: int = 100) -> int:      sum_of_squares = sum(i * i for i in range(1, n + 1))     square_of_sum = int(math.pow(sum(range(1, n + 1)), 2))     return square_of_sum - sum_of_squares\n2: def assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:     if i == 0 and j == 0:         return []     elif ops[i][j][0] in {\"C\", \"R\"}:         seq = assemble_transformation(ops, i - 1, j - 1)         seq.append(ops[i][j])         return seq     elif ops[i][j][0] == \"D\":         seq = assemble_transformation(ops, i - 1, j)         seq.append(ops[i][j])         return seq     else:         seq = assemble_transformation(ops, i, j - 1)         seq.append(ops[i][j])         return seq", "output": "2"}
{"task": "detection", "input": "classify code:\ndef calc_profit(profit: list, weight: list, max_weight: int) -> Union[str, int]:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain", "output": "Function description is as follows-"}
{"task": "repair", "input": "fix bug:\ndef is_pangram_fastest(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_fastest()\n    True\n    \"\"\"\n    return len({char for char in input_str.lower() if char.isalpha()}) == 26", "output": "def is_pangram_fastest(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_fastest()\n    True\n    \"\"\"\n    return len({char for char in input_str.lower() if char.isalpha()}) == 26"}
{"task": "repair", "input": "fix bug:\ndef swap(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b", "output": "def swap(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b"}
{"task": "search", "input": "search code:\nCalculate the area of a triangle given the base and height.\n\nChoices:\n0: def area_triangle(base: float, height: float) -> float:     if base < 0 or height < 0:         raise ValueError(\"area_triangle() only accepts non-negative values\")     return (base * height) / 2\n1: def decode(coded: str) -> str:     if set(coded) - {\"A\", \"B\", \" \"} != set():         raise Exception(\"decode() accepts only 'A', 'B' and spaces\")     decoded = \"\"     for word in coded.split():         while len(word) != 0:             decoded += decode_dict[word[:5]]             word = word[5:]         decoded += \" \"     return decoded.strip()\n2: def solution(limit=28123):     sum_divs = [1] * (limit + 1)      for i in range(2, int(limit**0.5) + 1):         sum_divs[i * i] += i         for k in range(i + 1, limit // i + 1):             sum_divs[k * i] += k + i      abundants = set()     res = 0      for n in range(1, limit + 1):         if sum_divs[n] > n:             abundants.add(n)          if not any((n - a in abundants) for a in abundants):             res += n      return res", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef add_three(\n    x_num: int, x_den: int, y_num: int, y_den: int, z_num: int, z_den: int\n) -> tuple[int, int]:\n    top: int = x_num * y_den * z_den + y_num * x_den * z_den + z_num * x_den * y_den\n    bottom: int = x_den * y_den * z_den\n    hcf: int = gcd(top, bottom)\n    top //= hcf\n    bottom //= hcf\n    return top, bottom", "output": "Given the numerators and denominators of three fractions, return the"}
{"task": "detection", "input": "classify code:\ndef is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    return subset[arr_len][required_sum]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef binary_tree_top_side_view(root: TreeNode) -> list[int]:\n\n    def breadth_first_search(root: TreeNode, top_view: list[int]) -> None:\n        queue = [(root, 0)]\n        lookup = defaultdict(list)\n\n        while queue:\n            first = queue.pop(0)\n            node, hd = first\n\n            lookup[hd].append(node.val)\n\n            if node.left:\n                queue.append((node.left, hd - 1))\n            if node.right:\n                queue.append((node.right, hd + 1))\n\n        for pair in sorted(lookup.items(), key=lambda each: each[0]):\n            top_view.append(pair[1][0])\n\n    top_view: list = []\n    if not root:\n        return top_view\n\n    breadth_first_search(root, top_view)\n    return top_view", "output": "Function returns the top side view of binary tree."}
{"task": "repair", "input": "fix bug:\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)"}
{"task": "search", "input": "search code:\nReturns the sequence elements *n* times\n\nChoices:\n0: def ncycles(iterable, n):     return chain.from_iterable(repeat(tuple(iterable), n))\n1: def interleave_evenly(iterables, lengths=None):     if lengths is None:         try:             lengths = [len(it) for it in iterables]         except TypeError:             raise ValueError(                 'Iterable lengths could not be determined automatically. '                 'Specify them with the lengths keyword.'             )     elif len(iterables) != len(lengths):         raise ValueError('Mismatching number of iterables and lengths.')      dims = len(lengths)      # sort iterables by length, descending     lengths_permute = sorted(         range(dims), key=lambda i: lengths[i], reverse=True     )     lengths_desc = [lengths[i] for i in lengths_permute]     iters_desc = [iter(iterables[i]) for i in lengths_permute]      # the longest iterable is the primary one (Bresenham: the longest     # distance along an axis)     delta_primary, deltas_secondary = lengths_desc[0], lengths_desc[1:]     iter_primary, iters_secondary = iters_desc[0], iters_desc[1:]     errors = [delta_primary // dims] * len(deltas_secondary)      to_yield = sum(lengths)     while to_yield:         yield next(iter_primary)         to_yield -= 1         # update errors for each secondary iterable         errors = [e - delta for e, delta in zip(errors, deltas_secondary)]          # those iterables for which the error is negative are yielded         # (\"diagonal step\" in Bresenham)         for i, e_ in enumerate(errors):             if e_ < 0:                 yield next(iters_secondary[i])                 to_yield -= 1                 errors[i] += delta_primary\n2: def sieve(n):     # This implementation comes from an older version of the itertools     # documentation.  The newer implementation is easier to read but is     # less lazy.     if n > 2:         yield 2     start = 3     data = bytearray((0, 1)) * (n // 2)     for p in iter_index(data, 1, start, stop=isqrt(n) + 1):         yield from iter_index(data, 1, start, p * p)         data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))         start = p * p     yield from iter_index(data, 1, start)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef linear_search(sequence: list, target: int) -> int:\n    \"\"\"A pure Python implementation of a linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return -1", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)", "output": "def sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)"}
{"task": "search", "input": "search code:\nCalculate the waiting time of each processes.\n\nChoices:\n0: def calculate_waiting_time(     process_name: list,  # noqa: ARG001     turn_around_time: list,     burst_time: list,     no_of_process: int, ) -> list:      waiting_time = [0] * no_of_process     for i in range(no_of_process):         waiting_time[i] = turn_around_time[i] - burst_time[i]     return waiting_time\n1: def archimedes_principle(     fluid_density: float, volume: float, gravity: float = g ) -> float:      if fluid_density <= 0:         raise ValueError(\"Impossible fluid density\")     if volume <= 0:         raise ValueError(\"Impossible object volume\")     if gravity < 0:         raise ValueError(\"Impossible gravity\")      return fluid_density * gravity * volume\n2: def display(values):     width = 1 + max(len(values[s]) for s in squares)     line = \"+\".join([\"-\" * (width * 3)] * 3)     for r in rows:         print(             \"\".join(                 values[r + c].center(width) + (\"|\" if c in \"36\" else \"\") for c in cols             )         )         if r in \"CF\":             print(line)     print()", "output": "0"}
{"task": "detection", "input": "classify code:\ndef longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef counting_sort(collection):\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered", "output": "Pure implementation of counting sort algorithm in Python"}
{"task": "detection", "input": "classify code:\ndef list_truncated_nums(n: int) -> List[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r", "output": "BUGGY"}
{"task": "search", "input": "search code:\n| Return pure symbols and their values to satisfy clause.\n\nChoices:\n0: def split_at(iterable, pred, maxsplit=-1, keep_separator=False):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         if pred(item):             yield buf             if keep_separator:                 yield [item]             if maxsplit == 1:                 yield list(it)                 return             buf = []             maxsplit -= 1         else:             buf.append(item)     yield buf\n1: def main(     cities: dict[int, list[int]],     ants_num: int,     iterations_num: int,     pheromone_evaporation: float,     alpha: float,     beta: float,     q: float,  # Pheromone system parameters Q, which is a constant ) -> tuple[list[int], float]:     # Initialize the pheromone matrix     cities_num = len(cities)     pheromone = [[1.0] * cities_num] * cities_num      best_path: list[int] = []     best_distance = float(\"inf\")     for _ in range(iterations_num):         ants_route = []         for _ in range(ants_num):             unvisited_cities = copy.deepcopy(cities)             current_city = {next(iter(cities.keys())): next(iter(cities.values()))}             del unvisited_cities[next(iter(current_city.keys()))]             ant_route = [next(iter(current_city.keys()))]             while unvisited_cities:                 current_city, unvisited_cities = city_select(                     pheromone, current_city, unvisited_cities, alpha, beta                 )                 ant_route.append(next(iter(current_city.keys())))             ant_route.append(0)             ants_route.append(ant_route)          pheromone, best_path, best_distance = pheromone_update(             pheromone,             cities,             pheromone_evaporation,             ants_route,             q,             best_path,             best_distance,         )     return best_path, best_distance\n2: def find_pure_symbols(     clauses: list[Clause], symbols: list[str], model: dict[str, bool | None] ) -> tuple[list[str], dict[str, bool | None]]:     pure_symbols = []     assignment: dict[str, bool | None] = {}     literals = []      for clause in clauses:         if clause.evaluate(model):             continue         for literal in clause.literals:             literals.append(literal)      for s in symbols:         sym = s + \"'\"         if (s in literals and sym not in literals) or (             s not in literals and sym in literals         ):             pure_symbols.append(s)     for p in pure_symbols:         assignment[p] = None     for s in pure_symbols:         sym = s + \"'\"         if s in literals:             assignment[s] = True         elif sym in literals:             assignment[s] = False     return pure_symbols, assignment", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef analyze_text(text: str) -> tuple[dict, dict]:\n    single_char_strings = Counter()  # type: ignore[var-annotated]\n    two_char_strings = Counter()  # type: ignore[var-annotated]\n    single_char_strings[text[-1]] += 1\n\n    # first case when we have space at start.\n    two_char_strings[\" \" + text[0]] += 1\n    for i in range(len(text) - 1):\n        single_char_strings[text[i]] += 1\n        two_char_strings[text[i : i + 2]] += 1\n    return single_char_strings, two_char_strings", "output": "Convert text input into two dicts of counts."}
{"task": "repair", "input": "fix bug:\ndef pig_latin(word: str) -> str:\n    \"\"\"Compute the piglatin of a given string.\n\n    https://en.wikipedia.org/wiki/Pig_Latin\n\n    Usage examples:\n    >>> pig_latin(\"pig\")\n    'igpay'\n    >>> pig_latin(\"latin\")\n    'atinlay'\n    >>> pig_latin(\"banana\")\n    'ananabay'\n    >>> pig_latin(\"friends\")\n    'iendsfray'\n    >>> pig_latin(\"smile\")\n    'ilesmay'\n    >>> pig_latin(\"string\")\n    'ingstray'\n    >>> pig_latin(\"eat\")\n    'eatway'\n    >>> pig_latin(\"omelet\")\n    'omeletway'\n    >>> pig_latin(\"are\")\n    'areway'\n    >>> pig_latin(\" \")\n    ''\n    >>> pig_latin(None)\n    ''\n    \"\"\"\n    if not (word or \"\").strip():\n        return \"\"\n    word = word.lower()\n    if word[0] in \"aeiou\":\n        return f\"{word}way\"\n    for i, char in enumerate(word):  # noqa: B007\n        if char in \"aeiou\":\n            break\n    return f\"{word[i:]}{word[:i]}ay\"", "output": "def pig_latin(word: str) -> str:\n    \"\"\"Compute the piglatin of a given string.\n\n    https://en.wikipedia.org/wiki/Pig_Latin\n\n    Usage examples:\n    >>> pig_latin(\"pig\")\n    'igpay'\n    >>> pig_latin(\"latin\")\n    'atinlay'\n    >>> pig_latin(\"banana\")\n    'ananabay'\n    >>> pig_latin(\"friends\")\n    'iendsfray'\n    >>> pig_latin(\"smile\")\n    'ilesmay'\n    >>> pig_latin(\"string\")\n    'ingstray'\n    >>> pig_latin(\"eat\")\n    'eatway'\n    >>> pig_latin(\"omelet\")\n    'omeletway'\n    >>> pig_latin(\"are\")\n    'areway'\n    >>> pig_latin(\" \")\n    ''\n    >>> pig_latin(None)\n    ''\n    \"\"\"\n    if not (word or \"\").strip():\n        return \"\"\n    word = word.lower()\n    if word[0] in \"aeiou\":\n        return f\"{word}way\"\n    for i, char in enumerate(word):  # noqa: B007\n        if char in \"aeiou\":\n            break\n    return f\"{word[i:]}{word[:i]}ay\""}
{"task": "summary", "input": "summarize code:\ndef dutch_national_flag_sort(sequence: list) -> list:\n    if not sequence:\n        return []\n    if len(sequence) == 1:\n        return list(sequence)\n    low = 0\n    high = len(sequence) - 1\n    mid = 0\n    while mid <= high:\n        if sequence[mid] == colors[0]:\n            sequence[low], sequence[mid] = sequence[mid], sequence[low]\n            low += 1\n            mid += 1\n        elif sequence[mid] == colors[1]:\n            mid += 1\n        elif sequence[mid] == colors[2]:\n            sequence[mid], sequence[high] = sequence[high], sequence[mid]\n            high -= 1\n        else:\n            msg = f\"The elements inside the sequence must contains only {colors} values\"\n            raise ValueError(msg)\n    return sequence", "output": "A pure Python implementation of Dutch National Flag sort algorithm."}
{"task": "search", "input": "search code:\nLike `naturalday`, but append a year for dates more than ~five months away.\n\nChoices:\n0: def naturaldate(value) -> str:     try:         value = dt.date(value.year, value.month, value.day)     except AttributeError:         # Passed value wasn't date-ish         return value     except (OverflowError, ValueError):         # Date arguments out of range         return value     delta = _abs_timedelta(value - dt.date.today())     if delta.days >= 5 * 365 / 12:         return naturalday(value, \"%b %d %Y\")     return naturalday(value)\n1: def longest_common_substring(text1: str, text2: str) -> str:      if not (isinstance(text1, str) and isinstance(text2, str)):         raise ValueError(\"longest_common_substring() takes two strings for inputs\")      if not text1 or not text2:         return \"\"      text1_length = len(text1)     text2_length = len(text2)      dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]     end_pos = 0     max_length = 0      for i in range(1, text1_length + 1):         for j in range(1, text2_length + 1):             if text1[i - 1] == text2[j - 1]:                 dp[i][j] = 1 + dp[i - 1][j - 1]                 if dp[i][j] > max_length:                     end_pos = i                     max_length = dp[i][j]      return text1[end_pos - max_length : end_pos]\n2: def unit_basis_vector(dimension: int, pos: int) -> Vector:     # precondition     assert isinstance(dimension, int)     assert isinstance(pos, int)     ans = [0] * dimension     ans[pos] = 1     return Vector(ans)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef peak(lst: list[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef surface_area_cube(side_length: Union[int, float]) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * pow(side_length, 2)\r", "output": "def surface_area_cube(side_length: float) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * side_length ** 2\r"}
{"task": "search", "input": "search code:\nSimple function that should be used when no effect is desired.\n\nChoices:\n0: def quick_sort_3partition(sorting: list, left: int, right: int) -> None:     if right <= left:         return     a = i = left     b = right     pivot = sorting[left]     while i <= b:         if sorting[i] < pivot:             sorting[a], sorting[i] = sorting[i], sorting[a]             a += 1             i += 1         elif sorting[i] > pivot:             sorting[b], sorting[i] = sorting[i], sorting[b]             b -= 1         else:             i += 1     quick_sort_3partition(sorting, left, a - 1)     quick_sort_3partition(sorting, b + 1, right)\n1: def clone_graph(node: Node | None) -> Node | None:     if not node:         return None      originals_to_clones = {}  # map nodes to clones      stack = [node]      while stack:         original = stack.pop()          if original in originals_to_clones:             continue          originals_to_clones[original] = Node(original.value)          stack.extend(original.neighbors or [])      for original, clone in originals_to_clones.items():         for neighbor in original.neighbors or []:             cloned_neighbor = originals_to_clones[neighbor]              if not clone.neighbors:                 clone.neighbors = []              clone.neighbors.append(cloned_neighbor)      return originals_to_clones[node]\n2: def noop(*args, **kwargs):     return None", "output": "2"}
{"task": "detection", "input": "classify code:\ndef max_sub_array(nums: list[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n    return sum(compute_truncated_primes(11))", "output": "Returns the sum of truncated primes"}
{"task": "repair", "input": "fix bug:\ndef check_anagrams(a: str, b: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return sorted(a.lower()) == sorted(b.lower())\r", "output": "def check_anagrams(first_str: str, second_str: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('This is    a      string', 'Is     this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return (\r\n        \"\".join(sorted(first_str.lower())).strip()\r\n        == \"\".join(sorted(second_str.lower())).strip()\r\n    )\r"}
{"task": "summary", "input": "summarize code:\ndef construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway", "output": "Build the highway following the parameters given"}
{"task": "search", "input": "search code:\nCounts the number of inversions using a naive brute-force algorithm\n\nChoices:\n0: def count_inversions_bf(arr):      num_inversions = 0     n = len(arr)      for i in range(n - 1):         for j in range(i + 1, n):             if arr[i] > arr[j]:                 num_inversions += 1      return num_inversions\n1: def permutation_index(element, iterable):     index = 0     pool = list(iterable)     for i, x in zip(range(len(pool), -1, -1), element):         r = pool.index(x)         index = index * i + r         del pool[r]      return index\n2: def _subsum(     digit_pos_to_extract: int, denominator_addend: int, precision: int ) -> float:     # only care about first digit of fractional part; don't need decimal     total = 0.0     for sum_index in range(digit_pos_to_extract + precision):         denominator = 8 * sum_index + denominator_addend         if sum_index < digit_pos_to_extract:             # if the exponential term is an integer and we mod it by the denominator             # before dividing, only the integer part of the sum will change;             # the fractional part will not             exponential_term = pow(                 16, digit_pos_to_extract - 1 - sum_index, denominator             )         else:             exponential_term = pow(16, digit_pos_to_extract - 1 - sum_index)         total += exponential_term / denominator     return total", "output": "0"}
{"task": "detection", "input": "classify code:\ndef selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)"}
{"task": "repair", "input": "fix bug:\ndef solution_fast() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution_fast()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(400):\n            c = 1000 - a - b\n            if a < b < c and (a**2) + (b**2) == (c**2):\n                return a * b * c\n\n    return -1", "output": "def solution_fast() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution_fast()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(400):\n            c = 1000 - a - b\n            if a < b < c and (a**2) + (b**2) == (c**2):\n                return a * b * c\n\n    return -1"}
{"task": "search", "input": "search code:\nOpening filter, defined as the sequence of\n\nChoices:\n0: def bisection(function: Callable[[float], float], a: float, b: float) -> float:     start: float = a     end: float = b     if function(a) == 0:  # one of the a or b is a root for the function         return a     elif function(b) == 0:         return b     elif (         function(a) * function(b) > 0     ):  # if none of these are root and they are both positive or negative,         # then this algorithm can't find the root         raise ValueError(\"could not find root in given interval.\")     else:         mid: float = start + (end - start) / 2.0         while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7             if function(mid) == 0:                 return mid             elif function(mid) * function(start) < 0:                 end = mid             else:                 start = mid             mid = start + (end - start) / 2.0         return mid\n1: def closing_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:     if kernel is None:         kernel = np.ones((3, 3))     return transform(transform(image, \"erosion\", kernel), \"dilation\", kernel)\n2: def recursive_lucas_number(n_th_number: int) -> int:     if not isinstance(n_th_number, int):         raise TypeError(\"recursive_lucas_number accepts only integer arguments.\")     if n_th_number == 0:         return 2     if n_th_number == 1:         return 1      return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(         n_th_number - 2     )", "output": "1"}
{"task": "detection", "input": "classify code:\ndef construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef length_conversion(value: float, from_type: str, to_type: str) -> float:\n\n    from_sanitized = from_type.lower().strip(\"s\")\n    to_sanitized = to_type.lower().strip(\"s\")\n\n    from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)\n    to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)\n\n    if from_sanitized not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'from_type' value: {from_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    if to_sanitized not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'to_type' value: {to_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    from_exponent = METRIC_CONVERSION[from_sanitized]\n    to_exponent = METRIC_CONVERSION[to_sanitized]\n    exponent = 1\n\n    if from_exponent > to_exponent:\n        exponent = from_exponent - to_exponent\n    else:\n        exponent = -(to_exponent - from_exponent)\n\n    return value * pow(10, exponent)", "output": "Conversion between astronomical length units."}
{"task": "summary", "input": "summarize code:\ndef is_isogram(string: str) -> bool:\n    if not all(x.isalpha() for x in string):\n        raise ValueError(\"String must only contain alphabetic characters.\")\n\n    letters = sorted(string.lower())\n    return len(letters) == len(set(letters))", "output": "An isogram is a word in which no letter is repeated."}
{"task": "search", "input": "search code:\nReturn a standardized list of values.\n\nChoices:\n0: def _norm_args_typeerror(other):     if type(other) in (set, frozenset):         inc, exc = other, None     elif type(other) is _ComplementSet:         inc, exc = other._included, other._excluded     else:         raise TypeError('argument must be another set or complement(set)')     return inc, exc\n1: def nth(iterable, n, default=None):     return next(islice(iterable, n, None), default)\n2: def standardization(data: list, ndigits: int = 3) -> list:     # variables for calculation     mu = mean(data)     sigma = stdev(data)     # standardize data     return [round((x - mu) / (sigma), ndigits) for x in data]", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef minimum_cost_path(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]", "output": "def minimum_cost_path(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]"}
{"task": "detection", "input": "classify code:\ndef question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef rsafactor(d: int, e: int, n: int) -> list[int]:\n    k = d * e - 1\n    p = 0\n    q = 0\n    while p == 0:\n        g = random.randint(2, n - 1)\n        t = k\n        while True:\n            if t % 2 == 0:\n                t = t // 2\n                x = (g**t) % n\n                y = math.gcd(x - 1, n)\n                if x > 1 and y > 1:\n                    p = y\n                    q = n // y\n                    break  # find the correct factors\n            else:\n                break  # t is not divisible by 2, break and choose another g\n    return sorted([p, q])", "output": "This function returns the factors of N, where p*q=N"}
{"task": "detection", "input": "classify code:\ndef fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n    \"\"\"[summary]\n\n    This function will take input of drug name and zipcode,\n    then request to the BASE_URL site.\n    Get the page data and scrape it to generate the\n    list of the lowest prices for the prescription drug.\n\n    Args:\n        drug_name (str): [Drug name]\n        zip_code(str): [Zip code]\n\n    Returns:\n        list: [List of pharmacy name and price]\n\n    >>> print(fetch_pharmacy_and_price_list(None, None))\n    None\n    >>> print(fetch_pharmacy_and_price_list(None, 30303))\n    None\n    >>> print(fetch_pharmacy_and_price_list(\"eliquis\", None))\n    None\n    \"\"\"\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReq = R1 + R2 + ... + Rn\n\nChoices:\n0: def calculate_fft(audio_windowed: np.ndarray, ftt_size: int = 1024) -> np.ndarray:     # Transpose the audio data to have time in rows and channels in columns     audio_transposed = np.transpose(audio_windowed)      # Initialize an array to store the FFT results     audio_fft = np.empty(         (int(1 + ftt_size // 2), audio_transposed.shape[1]),         dtype=np.complex64,         order=\"F\",     )      # Compute FFT for each channel     for n in range(audio_fft.shape[1]):         audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]      # Transpose the FFT results back to the original shape     return np.transpose(audio_fft)\n1: def check_bouncy(n: int) -> bool:     if not isinstance(n, int):         raise ValueError(\"check_bouncy() accepts only integer arguments\")     str_n = str(n)     sorted_str_n = \"\".join(sorted(str_n))     return str_n not in {sorted_str_n, sorted_str_n[::-1]}\n2: def resistor_series(resistors: list[float]) -> float:     sum_r = 0.00     for index, resistor in enumerate(resistors):         sum_r += resistor         if resistor < 0:             msg = f\"Resistor at index {index} has a negative value!\"             raise ValueError(msg)     return sum_r", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    A Pangram String contains all the alphabets at least once.\n    >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram(\"My name is Unknown\")\n    False\n    >>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram()\n    True\n    \"\"\"\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26", "output": "def is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    A Pangram String contains all the alphabets at least once.\n    >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram(\"My name is Unknown\")\n    False\n    >>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram()\n    True\n    \"\"\"\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26"}
{"task": "summary", "input": "summarize code:\ndef left_rotate_32(i: int, shift: int) -> int:\n    if i < 0:\n        raise ValueError(\"Input must be non-negative\")\n    if shift < 0:\n        raise ValueError(\"Shift must be non-negative\")\n    return ((i << shift) ^ (i >> (32 - shift))) % 2**32", "output": "Rotate the bits of a given int left by a given amount."}
{"task": "repair", "input": "fix bug:\ndef merge_insertion_sort(collection: List[int]) -> List[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result", "output": "def merge_insertion_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result"}
{"task": "search", "input": "search code:\nThis value is Negative, if the model underpredicts,\n\nChoices:\n0: def merge_sort(collection: list) -> list:      def merge(left: list, right: list) -> list:         result = []         while left and right:             result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))         result.extend(left)         result.extend(right)         return result      if len(collection) <= 1:         return collection     mid_index = len(collection) // 2     return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))\n1: def mbd(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     numerator = np.sum(difference) / len(predict)     denumerator = np.sum(actual) / len(predict)     # print(numerator, denumerator)     score = float(numerator) / denumerator * 100      return score\n2: def solution(max_base: int = 10, max_power: int = 22) -> int:     bases = range(1, max_base)     powers = range(1, max_power)     return sum(         1 for power in powers for base in bases if len(str(base**power)) == power     )", "output": "1"}
{"task": "detection", "input": "classify code:\ndef add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(num: int = 100) -> int:\n    nfact = factorial(num)\n    result = split_and_add(nfact)\n    return result", "output": "Returns the sum of the digits in the factorial of num"}
{"task": "detection", "input": "classify code:\ndef score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch", "output": "BUGGY"}
{"task": "search", "input": "search code:\nConvert a frequency in Hertz to the mel scale.\n\nChoices:\n0: def freq_to_mel(freq: float) -> float:     # Use the formula to convert frequency to the mel scale     return 2595.0 * np.log10(1.0 + freq / 700.0)\n1: def permute_backtrack(nums: list[int]) -> list[list[int]]:      def backtrack(start: int) -> None:         if start == len(nums) - 1:             output.append(nums[:])         else:             for i in range(start, len(nums)):                 nums[start], nums[i] = nums[i], nums[start]                 backtrack(start + 1)                 nums[start], nums[i] = nums[i], nums[start]  # backtrack      output: list[list[int]] = []     backtrack(0)     return output\n2: def split(string: str, separator: str = \" \") -> list:      split_words = []      last_index = 0     for index, char in enumerate(string):         if char == separator:             split_words.append(string[last_index:index])             last_index = index + 1         if index + 1 == len(string):             split_words.append(string[last_index : index + 1])     return split_words", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef sum_reverse(n: int) -> int:\n    \"\"\"\n    Returns the sum of n and reverse of n.\n    >>> sum_reverse(123)\n    444\n    >>> sum_reverse(3478)\n    12221\n    >>> sum_reverse(12)\n    33\n    \"\"\"\n    return int(n) + int(str(n)[::-1])", "output": "def sum_reverse(n: int) -> int:\n    \"\"\"\n    Returns the sum of n and reverse of n.\n    >>> sum_reverse(123)\n    444\n    >>> sum_reverse(3478)\n    12221\n    >>> sum_reverse(12)\n    33\n    \"\"\"\n    return int(n) + int(str(n)[::-1])"}
{"task": "summary", "input": "summarize code:\ndef get_distance(highway_now: list, car_index: int) -> int:\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)", "output": "Get the distance between a car (at index car_index) and the next car"}
{"task": "detection", "input": "classify code:\ndef check(binary: list[str]) -> list[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "def calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]"}
{"task": "search", "input": "search code:\nEncrypt a given `plaintext` (string) and `key` (string), returning the\n\nChoices:\n0: def solution(max_base: int = 10, max_power: int = 22) -> int:     bases = range(1, max_base)     powers = range(1, max_power)     return sum(         1 for power in powers for base in bases if len(str(base**power)) == power     )\n1: def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:     # Mark current node as visited and add to recursion stack     visited.add(vertex)     rec_stk.add(vertex)      for node in graph[vertex]:         if node not in visited:             if depth_first_search(graph, node, visited, rec_stk):                 return True         elif node in rec_stk:             return True      # The node needs to be removed from recursion stack before function ends     rec_stk.remove(vertex)     return False\n2: def encrypt(plaintext: str, key: str) -> str:     if not isinstance(plaintext, str):         raise TypeError(\"plaintext must be a string\")     if not isinstance(key, str):         raise TypeError(\"key must be a string\")      if not plaintext:         raise ValueError(\"plaintext is empty\")     if not key:         raise ValueError(\"key is empty\")      key += plaintext     plaintext = plaintext.lower()     key = key.lower()     plaintext_iterator = 0     key_iterator = 0     ciphertext = \"\"     while plaintext_iterator < len(plaintext):         if (             ord(plaintext[plaintext_iterator]) < 97             or ord(plaintext[plaintext_iterator]) > 122         ):             ciphertext += plaintext[plaintext_iterator]             plaintext_iterator += 1         elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:             key_iterator += 1         else:             ciphertext += chr(                 (                     (ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))                     - 97                 )                 % 26                 + 97             )             key_iterator += 1             plaintext_iterator += 1     return ciphertext", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef reverse_letters(input_str: str) -> str:\n    \"\"\"\n    Reverses letters in a given string without adjusting the position of the words\n    >>> reverse_letters('The cat in the hat')\n    'ehT tac ni eht tah'\n    >>> reverse_letters('The quick brown fox jumped over the lazy dog.')\n    'ehT kciuq nworb xof depmuj revo eht yzal .god'\n    >>> reverse_letters('Is this true?')\n    'sI siht ?eurt'\n    >>> reverse_letters(\"I   love       Python\")\n    'I evol nohtyP'\n    \"\"\"\n    return \" \".join([word[::-1] for word in input_str.split()])", "output": "def reverse_letters(sentence: str, length: int = 0) -> str:\n    \"\"\"\n    Reverse all words that are longer than the given length of characters in a sentence.\n    If unspecified, length is taken as 0\n\n    >>> reverse_letters(\"Hey wollef sroirraw\", 3)\n    'Hey fellow warriors'\n    >>> reverse_letters(\"nohtyP is nohtyP\", 2)\n    'Python is Python'\n    >>> reverse_letters(\"1 12 123 1234 54321 654321\", 0)\n    '1 21 321 4321 12345 123456'\n    >>> reverse_letters(\"racecar\")\n    'racecar'\n    \"\"\"\n    return \" \".join(\n        \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()\n    )"}
{"task": "detection", "input": "classify code:\ndef lin_search(left: int, right: int, array: list[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1", "output": "CORRECT"}
{"task": "search", "input": "search code:\nChecking whether coordinate (row, col) is valid or not.\n\nChoices:\n0: def get_distance(highway_now: list, car_index: int) -> int:      distance = 0     cells = highway_now[car_index + 1 :]     for cell in range(len(cells)):  # May need a better name for this         if cells[cell] != -1:  # If the cell is not empty then             return distance  # we have the distance we wanted         distance += 1     # Here if the car is near the end of the highway     return distance + get_distance(highway_now, -1)\n1: def vol_spherical_cap(height: float, radius: float) -> float:     if height < 0 or radius < 0:         raise ValueError(\"vol_spherical_cap() only accepts non-negative values\")     # Volume is 1/3 pi * height squared * (3 * radius - height)     return 1 / 3 * pi * pow(height, 2) * (3 * radius - height)\n2: def is_safe(row: int, col: int, rows: int, cols: int) -> bool:     return 0 <= row < rows and 0 <= col < cols", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef format_invocation(name='', args=(), kwargs=None, **kw):\n    _repr = kw.pop('repr', repr)\n    if kw:\n        raise TypeError('unexpected keyword args: %r' % ', '.join(kw.keys()))\n    kwargs = kwargs or {}\n    a_text = ', '.join([_repr(a) for a in args])\n    if isinstance(kwargs, dict):\n        kwarg_items = [(k, kwargs[k]) for k in sorted(kwargs)]\n    else:\n        kwarg_items = kwargs\n    kw_text = ', '.join([f'{k}={_repr(v)}' for k, v in kwarg_items])\n\n    all_args_text = a_text\n    if all_args_text and kw_text:\n        all_args_text += ', '\n    all_args_text += kw_text\n\n    return f'{name}({all_args_text})'", "output": "Given a name, positional arguments, and keyword arguments, format"}
{"task": "detection", "input": "classify code:\ndef strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef _batched(iterable, n, *, strict=False):  # pragma: no cover\n    if n < 1:\n        raise ValueError('n must be at least one')\n    iterator = iter(iterable)\n    while batch := tuple(islice(iterator, n)):\n        if strict and len(batch) != n:\n            raise ValueError('batched(): incomplete batch')\n        yield batch", "output": "Batch data into tuples of length *n*. If the number of items in"}
{"task": "search", "input": "search code:\nRecursive function for calculating the height of the binary tree.\n\nChoices:\n0: def trapezoidal_rule(boundary, steps):     h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 2.0) * f(a)     for i in x_i:         y += h * f(i)     y += (h / 2.0) * f(b)     return y\n1: def choose(n: int, r: int) -> int:     ret = 1.0     for i in range(1, r + 1):         ret *= (n + 1 - i) / i     return round(ret)\n2: def height(root: Node | None) -> int:     return (max(height(root.left), height(root.right)) + 1) if root else 0", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef euclidean_distance_sqr(point1, point2):\n    \"\"\"\n    >>> euclidean_distance_sqr([1,2],[2,4])\n    5\n    \"\"\"\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2", "output": "def euclidean_distance_sqr(point1, point2):\n    \"\"\"\n    >>> euclidean_distance_sqr([1,2],[2,4])\n    5\n    \"\"\"\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2"}
{"task": "search", "input": "search code:\nYield the index of each item in *iterable* for which *pred* returns\n\nChoices:\n0: def opening_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:     if kernel is None:         np.ones((3, 3))      return transform(transform(image, \"dilation\", kernel), \"erosion\", kernel)\n1: def harmonic_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 0     for val in series:         answer += 1 / val     return len(series) / answer\n2: def rlocate(iterable, pred=bool, window_size=None):     if window_size is None:         try:             len_iter = len(iterable)             return (len_iter - i - 1 for i in locate(reversed(iterable), pred))         except TypeError:             pass      return reversed(list(locate(iterable, pred, window_size)))", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef edit_distance(source: str, target: str) -> int:\n    \"\"\"\n    Edit distance algorithm is a string metric, i.e., it is a way of quantifying how\n    dissimilar two strings are to one another. It is measured by counting the minimum\n    number of operations required to transform one string into another.\n\n    This implementation assumes that the cost of operations (insertion, deletion and\n    substitution) is always 1\n\n    Args:\n    source: the initial string with respect to which we are calculating the edit\n        distance for the target\n    target: the target string, formed after performing n operations on the source string\n\n    >>> edit_distance(\"GATTIC\", \"GALTIC\")\n    1\n    >>> edit_distance(\"NUM3\", \"HUM2\")\n    2\n    >>> edit_distance(\"cap\", \"CAP\")\n    3\n    >>> edit_distance(\"Cat\", \"\")\n    3\n    >>> edit_distance(\"cat\", \"cat\")\n    0\n    >>> edit_distance(\"\", \"123456789\")\n    9\n    >>> edit_distance(\"Be@uty\", \"Beautyyyy!\")\n    5\n    >>> edit_distance(\"lstring\", \"lsstring\")\n    1\n    \"\"\"\n    if len(source) == 0:\n        return len(target)\n    elif len(target) == 0:\n        return len(source)\n\n    delta = int(source[-1] != target[-1])  # Substitution\n    return min(\n        edit_distance(source[:-1], target[:-1]) + delta,\n        edit_distance(source, target[:-1]) + 1,\n        edit_distance(source[:-1], target) + 1,\n    )", "output": "def edit_distance(source: str, target: str) -> int:\n    \"\"\"\n    Edit distance algorithm is a string metric, i.e., it is a way of quantifying how\n    dissimilar two strings are to one another. It is measured by counting the minimum\n    number of operations required to transform one string into another.\n\n    This implementation assumes that the cost of operations (insertion, deletion and\n    substitution) is always 1\n\n    Args:\n    source: the initial string with respect to which we are calculating the edit\n        distance for the target\n    target: the target string, formed after performing n operations on the source string\n\n    >>> edit_distance(\"GATTIC\", \"GALTIC\")\n    1\n    >>> edit_distance(\"NUM3\", \"HUM2\")\n    2\n    >>> edit_distance(\"cap\", \"CAP\")\n    3\n    >>> edit_distance(\"Cat\", \"\")\n    3\n    >>> edit_distance(\"cat\", \"cat\")\n    0\n    >>> edit_distance(\"\", \"123456789\")\n    9\n    >>> edit_distance(\"Be@uty\", \"Beautyyyy!\")\n    5\n    >>> edit_distance(\"lstring\", \"lsstring\")\n    1\n    \"\"\"\n    if len(source) == 0:\n        return len(target)\n    elif len(target) == 0:\n        return len(source)\n\n    delta = int(source[-1] != target[-1])  # Substitution\n    return min(\n        edit_distance(source[:-1], target[:-1]) + delta,\n        edit_distance(source, target[:-1]) + 1,\n        edit_distance(source[:-1], target) + 1,\n    )"}
{"task": "detection", "input": "classify code:\ndef _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef iteration_step(vectors: list[np.ndarray]) -> list[np.ndarray]:\n    new_vectors = []\n    for i, start_vector in enumerate(vectors[:-1]):\n        end_vector = vectors[i + 1]\n        new_vectors.append(start_vector)\n        difference_vector = end_vector - start_vector\n        new_vectors.append(start_vector + difference_vector / 3)\n        new_vectors.append(\n            start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)\n        )\n        new_vectors.append(start_vector + difference_vector * 2 / 3)\n    new_vectors.append(vectors[-1])\n    return new_vectors", "output": "Loops through each pair of adjacent vectors. Each line between two adjacent"}
{"task": "repair", "input": "fix bug:\ndef is_sum_subset(arr, arr_len, required_sum):\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 4, 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 4, 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    subset = [[False for i in range(required_sum + 1)] for i in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    # uncomment to print the subset\n    # for i in range(arrLen+1):\n    #     print(subset[i])\n    print(subset[arr_len][required_sum])", "output": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    return subset[arr_len][required_sum]"}
{"task": "detection", "input": "classify code:\ndef is_palindrome(n: int | str) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False", "output": "CORRECT"}
{"task": "search", "input": "search code:\nSplits an iterable based on a separator. Like :meth:`str.split`,\n\nChoices:\n0: def is_arithmetic_series(series: list) -> bool:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     if len(series) == 1:         return True     common_diff = series[1] - series[0]     for index in range(len(series) - 1):         if series[index + 1] - series[index] != common_diff:             return False     return True\n1: def solution(matrix_str: list[str] = MATRIX_2) -> int:      n = len(matrix_str)     arr = np.empty(shape=(n, n), dtype=int)     for row, matrix_row_str in enumerate(matrix_str):         matrix_row_list_str = matrix_row_str.split()         for col, elem_str in enumerate(matrix_row_list_str):             arr[row, col] = int(elem_str)      cache: dict[str, int] = {}     return solve(arr=arr, row=0, cols=set(range(n)), cache=cache)\n2: def split(src, sep=None, maxsplit=None):     return list(split_iter(src, sep, maxsplit))", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef mbd(predict, actual):\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    numerator = np.sum(difference) / len(predict)\n    denumerator = np.sum(actual) / len(predict)\n    # print(numerator, denumerator)\n    score = float(numerator) / denumerator * 100\n\n    return score", "output": "This value is Negative, if the model underpredicts,"}
{"task": "detection", "input": "classify code:\ndef swap_case(sentence: str) -> str:\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n\n    return new_string", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "def calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)"}
{"task": "summary", "input": "summarize code:\ndef difference(iterable, func=sub, *, initial=None):\n    a, b = tee(iterable)\n    try:\n        first = [next(b)]\n    except StopIteration:\n        return iter([])\n\n    if initial is not None:\n        first = []\n\n    return chain(first, map(func, b, a))", "output": "This function is the inverse of :func:`itertools.accumulate`. By default"}
{"task": "search", "input": "search code:\nDynamic programming matching algorithm.\n\nChoices:\n0: def dp_match(text: str, pattern: str) -> bool:     m = len(text)     n = len(pattern)     dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]     dp[0][0] = True      for j in range(1, n + 1):         dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]      for i in range(1, m + 1):         for j in range(1, n + 1):             if pattern[j - 1] in {\".\", text[i - 1]}:                 dp[i][j] = dp[i - 1][j - 1]             elif pattern[j - 1] == \"*\":                 dp[i][j] = dp[i][j - 2]                 if pattern[j - 2] in {\".\", text[i - 1]}:                     dp[i][j] |= dp[i - 1][j]             else:                 dp[i][j] = False      return dp[m][n]\n1: def move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:      new_list = []      for row in range(size):         if matrix_g[row][column] != \"-\":             new_list.append(matrix_g[row][column])         else:             new_list.insert(0, matrix_g[row][column])     for row in range(size):         matrix_g[row][column] = new_list[row]     return matrix_g\n2: def gaussian_elimination(     coefficients: NDArray[float64], vector: NDArray[float64] ) -> NDArray[float64]:     # coefficients must to be a square matrix so we need to check first     rows, columns = np.shape(coefficients)     if rows != columns:         return np.array((), dtype=float)      # augmented matrix     augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)     augmented_mat = augmented_mat.astype(\"float64\")      # scale the matrix leaving it triangular     for row in range(rows - 1):         pivot = augmented_mat[row, row]         for col in range(row + 1, columns):             factor = augmented_mat[col, row] / pivot             augmented_mat[col, :] -= factor * augmented_mat[row, :]      x = retroactive_resolution(         augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]     )      return x", "output": "0"}
{"task": "detection", "input": "classify code:\ndef generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCalculate the Surface Area of a Cube.\n\nChoices:\n0: def check_bouncy(n: int) -> bool:     if not isinstance(n, int):         raise ValueError(\"check_bouncy() accepts only integer arguments\")     str_n = str(n)     sorted_str_n = \"\".join(sorted(str_n))     return str_n not in {sorted_str_n, sorted_str_n[::-1]}\n1: def sum_digits(num: int) -> int:     digit_sum = 0     while num > 0:         digit_sum += num % 10         num //= 10     return digit_sum\n2: def surface_area_cube(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"surface_area_cube() only accepts non-negative values\")     return 6 * side_length**2", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef find_longest_chain(chain: list[int], max_num: int) -> int:\n    \"\"\"\n    Finds the smallest element of longest chain\n\n    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n    6\n    \"\"\"\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem", "output": "def find_longest_chain(chain: list[int], max_num: int) -> int:\n    \"\"\"\n    Finds the smallest element of longest chain\n\n    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n    6\n    \"\"\"\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem"}
{"task": "summary", "input": "summarize code:\ndef multiply(\n    chain: list[int],\n    primes: list[int],\n    min_prime_idx: int,\n    prev_num: int,\n    max_num: int,\n    prev_sum: int,\n    primes_degrees: dict[int, int],\n) -> None:\n\n    min_prime = primes[min_prime_idx]\n    num = prev_num * min_prime\n\n    min_prime_degree = primes_degrees.get(min_prime, 0)\n    min_prime_degree += 1\n    primes_degrees[min_prime] = min_prime_degree\n\n    new_sum = prev_sum * min_prime + (prev_sum + prev_num) * (min_prime - 1) // (\n        min_prime**min_prime_degree - 1\n    )\n    chain[num] = new_sum\n\n    for prime_idx in range(min_prime_idx, len(primes)):\n        if primes[prime_idx] * num > max_num:\n            break\n\n        multiply(\n            chain=chain,\n            primes=primes,\n            min_prime_idx=prime_idx,\n            prev_num=num,\n            max_num=max_num,\n            prev_sum=new_sum,\n            primes_degrees=primes_degrees.copy(),\n        )", "output": "Run over all prime combinations to generate non-prime numbers."}
{"task": "summary", "input": "summarize code:\ndef _complex_sumprod(v1, v2):\n\n    real = attrgetter('real')\n    imag = attrgetter('imag')\n    r1 = chain(map(real, v1), map(neg, map(imag, v1)))\n    r2 = chain(map(real, v2), map(imag, v2))\n    i1 = chain(map(real, v1), map(imag, v1))\n    i2 = chain(map(imag, v2), map(real, v2))\n    return complex(_fsumprod(r1, r2), _fsumprod(i1, i2))", "output": "High precision sumprod() for complex numbers."}
{"task": "search", "input": "search code:\nWe can find Catalan number many ways but here we use Binomial Coefficient because it\n\nChoices:\n0: def normalization(data: list, ndigits: int = 3) -> list:     # variables for calculation     x_min = min(data)     x_max = max(data)     # normalize data     return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]\n1: def recursive_match(text: str, pattern: str) -> bool:     if not pattern:         return not text      if not text:         return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])      if text[-1] == pattern[-1] or pattern[-1] == \".\":         return recursive_match(text[:-1], pattern[:-1])      if pattern[-1] == \"*\":         return recursive_match(text[:-1], pattern) or recursive_match(             text, pattern[:-2]         )      return False\n2: def catalan_number(node_count: int) -> int:     return binomial_coefficient(2 * node_count, node_count) // (node_count + 1)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n    \"\"\"\n    Simulates gravity in a specific column.\n\n    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n    [['-', '-'], ['-', 'A'], ['-', 'C']]\n    \"\"\"\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g", "output": "def move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n    \"\"\"\n    Simulates gravity in a specific column.\n\n    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n    [['-', '-'], ['-', 'A'], ['-', 'C']]\n    \"\"\"\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g"}
{"task": "detection", "input": "classify code:\ndef reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> sentence = \"I love Python\"\n    >>> reverse_words(sentence) == \" \".join(sentence.split()[::-1])\n    True\n    >>> reverse_words(sentence)\n    'Python love I'\n    \"\"\"\n    return \" \".join(reversed(input_str.split(\" \")))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn the number of right triangles OPQ that can be formed by two points P, Q\n\nChoices:\n0: def check_direction(     starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int] ) -> Direction:     x0, y0 = starting     x1, y1 = via     x2, y2 = target     via_angle = degrees(atan2(y1 - y0, x1 - x0))     via_angle %= 360     target_angle = degrees(atan2(y2 - y0, x2 - x0))     target_angle %= 360     # t-     #  \\ \\     #   \\ v     #    \\|     #     s     # via_angle is always lower than target_angle, if direction is left.     # If they are same, it means they are on a same line of convex hull.     if target_angle > via_angle:         return Direction.left     elif target_angle == via_angle:         return Direction.straight     else:         return Direction.right\n1: def normalization(data: list, ndigits: int = 3) -> list:     # variables for calculation     x_min = min(data)     x_max = max(data)     # normalize data     return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]\n2: def solution(limit: int = 50) -> int:     return sum(         1         for pt1, pt2 in combinations(product(range(limit + 1), repeat=2), 2)         if is_right(*pt1, *pt2)     )", "output": "2"}
{"task": "detection", "input": "classify code:\ndef digit_sum(n: int) -> int:\n    \"\"\"\n    Returns the sum of the digits of the number.\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(456)\n    15\n    >>> digit_sum(78910)\n    25\n    \"\"\"\n    return sum(int(digit) for digit in str(n))", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef solution(n):\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    [2, 8]\r\n    >>> solution(15)\r\n    [2, 8]\r\n    >>> solution(2)\r\n    [2]\r\n    >>> solution(1)\r\n    []\r\n    >>> solution(34)\r\n    [2, 8, 34]\r\n    \"\"\"\r\n    ls = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            ls.append(b)\r\n        a, b = b, a + b\r\n    return ls\r", "output": "def solution(n: int = 4000000) -> int:\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    10\r\n    >>> solution(15)\r\n    10\r\n    >>> solution(2)\r\n    2\r\n    >>> solution(1)\r\n    0\r\n    >>> solution(34)\r\n    44\r\n    \"\"\"\r\n    even_fibs = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            even_fibs.append(b)\r\n        a, b = b, a + b\r\n    return sum(even_fibs)\r"}
{"task": "summary", "input": "summarize code:\ndef erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:\n    output = np.zeros_like(image)\n    image_padded = np.zeros(\n        (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)\n    )\n\n    # Copy image to padded image\n    image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image\n\n    # Iterate over image & apply kernel\n    for x in range(image.shape[1]):\n        for y in range(image.shape[0]):\n            summation = (\n                kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]\n            ).sum()\n            output[y, x] = int(summation == 5)\n    return output", "output": "Return eroded image"}
{"task": "repair", "input": "fix bug:\ndef circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection", "output": "def circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection"}
{"task": "search", "input": "search code:\nCalculate the distance between the two endpoints of two vectors without numpy.\n\nChoices:\n0: def while_solution(max_number: int = 10**8) -> int:      prime_numbers = calculate_prime_numbers(max_number // 2)      semiprimes_count = 0     left = 0     right = len(prime_numbers) - 1     while left <= right:         while prime_numbers[left] * prime_numbers[right] >= max_number:             right -= 1         semiprimes_count += right - left + 1         left += 1      return semiprimes_count\n1: def locate(iterable, pred=bool, window_size=None):     if window_size is None:         return compress(count(), map(pred, iterable))      if window_size < 1:         raise ValueError('window size must be at least 1')      it = windowed(iterable, window_size, fillvalue=_marker)     return compress(count(), starmap(pred, it))\n2: def euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:     return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 20) -> int:\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    i = 0\n    while 1:\n        i += n * (n - 1)\n        nfound = 0\n        for j in range(2, n):\n            if i % j != 0:\n                nfound = 1\n                break\n        if nfound == 0:\n            if i == 0:\n                i = 1\n            return i\n    return None", "output": "Returns the smallest positive number that is evenly divisible (divisible"}
{"task": "detection", "input": "classify code:\ndef maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef dir_dict(obj, raise_exc=False):\n    # TODO: separate function for handling descriptors on types?\n    ret = {}\n    for k in dir(obj):\n        try:\n            ret[k] = getattr(obj, k)\n        except Exception:\n            if raise_exc:\n                raise\n    return ret", "output": "Return a dictionary of attribute names to values for a given"}
{"task": "detection", "input": "classify code:\ndef pig_latin(word: str) -> str:\n    \"\"\"Compute the piglatin of a given string.\n\n    https://en.wikipedia.org/wiki/Pig_Latin\n\n    Usage examples:\n    >>> pig_latin(\"pig\")\n    'igpay'\n    >>> pig_latin(\"latin\")\n    'atinlay'\n    >>> pig_latin(\"banana\")\n    'ananabay'\n    >>> pig_latin(\"friends\")\n    'iendsfray'\n    >>> pig_latin(\"smile\")\n    'ilesmay'\n    >>> pig_latin(\"string\")\n    'ingstray'\n    >>> pig_latin(\"eat\")\n    'eatway'\n    >>> pig_latin(\"omelet\")\n    'omeletway'\n    >>> pig_latin(\"are\")\n    'areway'\n    >>> pig_latin(\" \")\n    ''\n    >>> pig_latin(None)\n    ''\n    \"\"\"\n    if not (word or \"\").strip():\n        return \"\"\n    word = word.lower()\n    if word[0] in \"aeiou\":\n        return f\"{word}way\"\n    for i, char in enumerate(word):  # noqa: B007\n        if char in \"aeiou\":\n            break\n    return f\"{word[i:]}{word[:i]}ay\"", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef split(string: str, seperator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values seperated by the seperator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",seperator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",seperator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",seperator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == seperator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words"}
{"task": "search", "input": "search code:\nCalculate the area of a rectangle.\n\nChoices:\n0: def data_safety_checker(list_vote: list, actual_result: float) -> bool:     safe = 0     not_safe = 0      if not isinstance(actual_result, float):         raise TypeError(\"Actual result should be float. Value passed is a list\")      for i in list_vote:         if i > actual_result:             safe = not_safe + 1         elif abs(abs(i) - abs(actual_result)) <= 0.1:             safe += 1         else:             not_safe += 1     return safe > not_safe\n1: def area_rectangle(length: float, width: float) -> float:     if length < 0 or width < 0:         raise ValueError(\"area_rectangle() only accepts non-negative values\")     return length * width\n2: def solution(start: int = 144) -> int:     n = start     num = hexagonal_num(n)     while not is_pentagonal(num):         n += 1         num = hexagonal_num(n)     return num", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef is_palindrome(s):\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    \"\"\"\n    return s == s[::-1]", "output": "def is_palindrome(s: str) -> bool:\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    >>> is_palindrome(\"Able was I ere I saw Elba\")\n    True\n    >>> is_palindrome(\"racecar\")\n    True\n    >>> is_palindrome(\"Mr. Owl ate my metal worm?\")\n    True\n    \"\"\"\n    # Since Punctuation, capitalization, and spaces are usually ignored while checking Palindrome,\n    # we first remove them from our string.\n    s = \"\".join([character for character in s.lower() if character.isalnum()])\n    return s == s[::-1]"}
{"task": "search", "input": "search code:\nWe cannot get the optimal w of our kernel SVM model, which is different from a\n\nChoices:\n0: def get_path(root, path, default=_UNSET):     if isinstance(path, str):         path = path.split('.')     cur = root     try:         for seg in path:             try:                 cur = cur[seg]             except (KeyError, IndexError) as exc:                 raise PathAccessError(exc, seg, path)             except TypeError as exc:                 # either string index in a list, or a parent that                 # doesn't support indexing                 try:                     seg = int(seg)                     cur = cur[seg]                 except (ValueError, KeyError, IndexError, TypeError):                     if not is_iterable(cur):                         exc = TypeError('%r object is not indexable'                                         % type(cur).__name__)                     raise PathAccessError(exc, seg, path)     except PathAccessError:         if default is _UNSET:             raise         return default     return cur\n1: def plot_partition_boundary(     model, train_data, ax, resolution=100, colors=(\"b\", \"k\", \"r\") ):     train_data_x = train_data[:, 1]     train_data_y = train_data[:, 2]     train_data_tags = train_data[:, 0]     xrange = np.linspace(train_data_x.min(), train_data_x.max(), resolution)     yrange = np.linspace(train_data_y.min(), train_data_y.max(), resolution)     test_samples = np.array([(x, y) for x in xrange for y in yrange]).reshape(         resolution * resolution, 2     )      test_tags = model.predict(test_samples, classify=False)     grid = test_tags.reshape((len(xrange), len(yrange)))      # Plot contour map which represents the partition boundary     ax.contour(         xrange,         yrange,         np.asmatrix(grid).T,         levels=(-1, 0, 1),         linestyles=(\"--\", \"-\", \"--\"),         linewidths=(1, 1, 1),         colors=colors,     )     # Plot all train samples     ax.scatter(         train_data_x,         train_data_y,         c=train_data_tags,         cmap=plt.cm.Dark2,         lw=0,         alpha=0.5,     )      # Plot support vectors     support = model.support     ax.scatter(         train_data_x[support],         train_data_y[support],         c=train_data_tags[support],         cmap=plt.cm.Dark2,     )\n2: def not_32(i: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")      i_str = format(i, \"032b\")     new_str = \"\"     for c in i_str:         new_str += \"1\" if c == \"0\" else \"0\"     return int(new_str, 2)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef binary_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:\n    if length > 1:\n        middle = int(length / 2)\n        for i in range(low, low + middle):\n            comp_and_swap(array, i, i + middle, direction)\n        bitonic_merge(array, low, middle, direction)\n        bitonic_merge(array, low + middle, middle, direction)", "output": "It recursively sorts a bitonic sequence in ascending order, if direction = 1, and in"}
{"task": "search", "input": "search code:\nReturn a list of all primes numbers up to max.\n\nChoices:\n0: def krusk(e_and_n):     (e, n) = e_and_n     e.sort(reverse=True, key=lambda x: x[2])     s = [{i} for i in range(1, n + 1)]     while True:         if len(s) == 1:             break         print(s)         x = e.pop()         for i in range(len(s)):             if x[0] in s[i]:                 break         for j in range(len(s)):             if x[1] in s[j]:                 if i == j:                     break                 s[j].update(s[i])                 s.pop(i)                 break\n1: def get_nodes_from_left_to_right(root: Node | None, level: int) -> Generator[int]:      def populate_output(root: Node | None, level: int) -> Generator[int]:         if not root:             return         if level == 1:             yield root.data         elif level > 1:             yield from populate_output(root.left, level - 1)             yield from populate_output(root.right, level - 1)      yield from populate_output(root, level)\n2: def primes(max_n: int) -> Generator[int]:     numbers: Generator = (i for i in range(1, (max_n + 1)))     for i in (n for n in numbers if n > 1):         # only need to check for factors up to sqrt(i)         bound = int(math.sqrt(i)) + 1         for j in range(2, bound):             if (i % j) == 0:                 break         else:             yield i", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> sentence = \"I love Python\"\n    >>> reverse_words(sentence) == \" \".join(sentence.split()[::-1])\n    True\n    >>> reverse_words(sentence)\n    'Python love I'\n    \"\"\"\n    return \" \".join(reversed(input_str.split(\" \")))", "output": "def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])"}
{"task": "detection", "input": "classify code:\ndef remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Remove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    >>> remove_duplicates(\"Python   is      great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split())))", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solve(\n    digit: int, prev1: int, prev2: int, sum_max: int, first: bool, cache: dict[str, int]\n) -> int:\n    if digit == 0:\n        return 1\n\n    cache_str = f\"{digit},{prev1},{prev2}\"\n    if cache_str in cache:\n        return cache[cache_str]\n\n    comb = 0\n    for curr in range(sum_max - prev1 - prev2 + 1):\n        if first and curr == 0:\n            continue\n\n        comb += solve(\n            digit=digit - 1,\n            prev1=curr,\n            prev2=prev1,\n            sum_max=sum_max,\n            first=False,\n            cache=cache,\n        )\n\n    cache[cache_str] = comb\n    return comb", "output": "Solve for remaining 'digit' digits, with previous 'prev1' digit, and"}
{"task": "detection", "input": "classify code:\ndef f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef check1(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital from END\n\n    >>> check1(123456789987654321)\n    True\n\n    >>> check1(120000987654321)\n    True\n\n    >>> check1(12345678957656779870004321)\n    False\n\n    \"\"\"\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f", "output": "def check1(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital from END\n\n    >>> check1(123456789987654321)\n    True\n\n    >>> check1(120000987654321)\n    True\n\n    >>> check1(12345678957656779870004321)\n    False\n\n    \"\"\"\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f"}
{"task": "search", "input": "search code:\nReturns the value of the first triangle number to have over five hundred\n\nChoices:\n0: def res(x, y):     if 0 not in (x, y):         # We use the relation x^y = y*log10(x), where 10 is the base.         return y * math.log10(x)     elif x == 0:  # 0 raised to any number is 0         return 0     elif y == 0:         return 1  # any number raised to 0 is 1     raise AssertionError(\"This should never happen\")\n1: def solution():     return next(i for i in triangle_number_generator() if count_divisors(i) > 500)\n2: def pad_none(iterable):     return chain(iterable, repeat(None))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef generate_pascal_triangle(num_rows: int) -> list[list[int]]:\n\n    if not isinstance(num_rows, int):\n        raise TypeError(\"The input value of 'num_rows' should be 'int'\")\n\n    if num_rows == 0:\n        return []\n    elif num_rows < 0:\n        raise ValueError(\n            \"The input value of 'num_rows' should be greater than or equal to 0\"\n        )\n\n    triangle: list[list[int]] = []\n    for current_row_idx in range(num_rows):\n        current_row = populate_current_row(triangle, current_row_idx)\n        triangle.append(current_row)\n    return triangle", "output": "Create Pascal's triangle for different number of rows"}
{"task": "repair", "input": "fix bug:\ndef sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    \"\"\"\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res", "output": "def sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(-123)\n    6\n    >>> sum_of_digits(0)\n    0\n    \"\"\"\n    n = -n if n < 0 else n\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res"}
{"task": "search", "input": "search code:\nReturn the smallest integer that can be written as the sum of primes in over\n\nChoices:\n0: def format_exception_only(etype, value):     # Gracefully handle (the way Python 2.4 and earlier did) the case of     # being called with (None, None).     if etype is None:         return [_format_final_exc_line(etype, value)]      stype = etype.__name__     smod = etype.__module__     if smod not in (\"__main__\", \"builtins\", \"exceptions\"):         stype = smod + '.' + stype      if not issubclass(etype, SyntaxError):         return [_format_final_exc_line(stype, value)]      # It was a syntax error; show exactly where the problem was found.     lines = []     filename = value.filename or \"<string>\"     lineno = str(value.lineno) or '?'     lines.append(f'  File \"{filename}\", line {lineno}\\n')     badline = value.text     offset = value.offset     if badline is not None:         lines.append('    %s\\n' % badline.strip())         if offset is not None:             caretspace = badline.rstrip('\\n')[:offset].lstrip()             # non-space whitespace (likes tabs) must be kept for alignment             caretspace = ((c.isspace() and c or ' ') for c in caretspace)             # only three spaces to account for offset1 == pos 0             lines.append('   %s^\\n' % ''.join(caretspace))     msg = value.msg or \"<no detail available>\"     lines.append(f\"{stype}: {msg}\\n\")     return lines\n1: def nth_combination_with_replacement(iterable, r, index):     pool = tuple(iterable)     n = len(pool)     if (r < 0) or (r > n):         raise ValueError      c = comb(n + r - 1, r)      if index < 0:         index += c      if (index < 0) or (index >= c):         raise IndexError      result = []     i = 0     while r:         r -= 1         while n >= 0:             num_combs = comb(n + r - 1, r)             if index < num_combs:                 break             n -= 1             i += 1             index -= num_combs         result.append(pool[i])      return tuple(result)\n2: def solution(number_unique_partitions: int = 5000) -> int | None:     for number_to_partition in range(1, NUM_PRIMES):         if len(partition(number_to_partition)) > number_unique_partitions:             return number_to_partition     return None", "output": "2"}
{"task": "detection", "input": "classify code:\ndef decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef floor(x: float) -> int:\n    return int(x) if x - int(x) >= 0 else int(x) - 1", "output": "Return the floor of x as an Integral."}
{"task": "detection", "input": "classify code:\ndef calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nSplit *iterable* into pieces based on the output of *pred*.\n\nChoices:\n0: def partition(pred, iterable):     if pred is None:         pred = bool      t1, t2, p = tee(iterable, 3)     p1, p2 = tee(map(pred, p))     return (compress(t1, map(not_, p1)), compress(t2, p2))\n1: def extended_gcd(a: int, b: int) -> tuple[int, int, int]:     assert a >= 0     assert b >= 0      if b == 0:         d, x, y = a, 1, 0     else:         (d, p, q) = extended_gcd(b, a % b)         x = q         y = p - q * (a // b)      assert a % d == 0     assert b % d == 0     assert d == a * x + b * y      return (d, x, y)\n2: def split_when(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      it = iter(iterable)     try:         cur_item = next(it)     except StopIteration:         return      buf = [cur_item]     for next_item in it:         if pred(cur_item, next_item):             yield buf             if maxsplit == 1:                 yield [next_item, *it]                 return             buf = []             maxsplit -= 1          buf.append(next_item)         cur_item = next_item      yield buf", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef clone_graph(node: Node | None) -> Node | None:\n    if not node:\n        return None\n\n    originals_to_clones = {}  # map nodes to clones\n\n    stack = [node]\n\n    while stack:\n        original = stack.pop()\n\n        if original in originals_to_clones:\n            continue\n\n        originals_to_clones[original] = Node(original.value)\n\n        stack.extend(original.neighbors or [])\n\n    for original, clone in originals_to_clones.items():\n        for neighbor in original.neighbors or []:\n            cloned_neighbor = originals_to_clones[neighbor]\n\n            if not clone.neighbors:\n                clone.neighbors = []\n\n            clone.neighbors.append(cloned_neighbor)\n\n    return originals_to_clones[node]", "output": "This function returns a clone of a connected undirected graph."}
{"task": "repair", "input": "fix bug:\ndef alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    \"\"\"\n    The method arranges two lists as one list in alternative forms of the list elements.\n    :param first_input_list:\n    :param second_input_list:\n    :return: List\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\n    >>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\n    >>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list", "output": "def alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    \"\"\"\n    The method arranges two lists as one list in alternative forms of the list elements.\n    :param first_input_list:\n    :param second_input_list:\n    :return: List\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\n    >>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\n    >>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list"}
{"task": "detection", "input": "classify code:\ndef solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculate kinetic energy.\n\nChoices:\n0: def kinetic_energy(mass: float, velocity: float) -> float:     if mass < 0:         raise ValueError(\"The mass of a body cannot be negative\")     return 0.5 * mass * abs(velocity) * abs(velocity)\n1: def cosine_similarity(input_a: np.ndarray, input_b: np.ndarray) -> float:     return float(np.dot(input_a, input_b) / (norm(input_a) * norm(input_b)))\n2: def max_sum_in_array(array: list[int], k: int) -> int:     if len(array) < k or k < 0:         raise ValueError(\"Invalid Input\")     max_sum = current_sum = sum(array[:k])     for i in range(len(array) - k):         current_sum = current_sum - array[i] + array[i + k]         max_sum = max(max_sum, current_sum)     return max_sum", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef trapped_rainwater(heights: tuple[int, ...]) -> int:\n    if not heights:\n        return 0\n    if any(h < 0 for h in heights):\n        raise ValueError(\"No height can be negative\")\n    length = len(heights)\n\n    left_max = [0] * length\n    left_max[0] = heights[0]\n    for i, height in enumerate(heights[1:], start=1):\n        left_max[i] = max(height, left_max[i - 1])\n\n    right_max = [0] * length\n    right_max[-1] = heights[-1]\n    for i in range(length - 2, -1, -1):\n        right_max[i] = max(heights[i], right_max[i + 1])\n\n    return sum(\n        min(left, right) - height\n        for left, right, height in zip(left_max, right_max, heights)\n    )", "output": "The trapped_rainwater function calculates the total amount of rainwater that can be"}
{"task": "repair", "input": "fix bug:\ndef identity(n: int) -> List[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]", "output": "def identity(n: int) -> list[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]"}
{"task": "detection", "input": "classify code:\ndef peak(lst: List[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef p_series(nth_term: float | str, power: float | str) -> list[str]:\n    if nth_term == \"\":\n        return [\"\"]\n    nth_term = int(nth_term)\n    power = int(power)\n    series: list[str] = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")\n    return series", "output": "Pure Python implementation of P-Series algorithm"}
{"task": "search", "input": "search code:\nShifts all columns leftward when an entire column becomes empty.\n\nChoices:\n0: def camel_to_snake_case(input_str: str) -> str:      # check for invalid input type     if not isinstance(input_str, str):         msg = f\"Expected string as input, found {type(input_str)}\"         raise ValueError(msg)      snake_str = \"\"      for index, char in enumerate(input_str):         if char.isupper():             snake_str += \"_\" + char.lower()          # if char is lowercase but proceeded by a digit:         elif input_str[index - 1].isdigit() and char.islower():             snake_str += \"_\" + char          # if char is a digit proceeded by a letter:         elif input_str[index - 1].isalpha() and char.isnumeric():             snake_str += \"_\" + char.lower()          # if char is not alphanumeric:         elif not char.isalnum():             snake_str += \"_\"          else:             snake_str += char      # remove leading underscore     if snake_str[0] == \"_\":         snake_str = snake_str[1:]      return snake_str\n1: def largest_rectangle_area(heights: list[int]) -> int:     stack: list[int] = []     max_area = 0     heights = [*heights, 0]  # make a new list by appending the sentinel 0     n = len(heights)      for i in range(n):         # make sure the stack remains in increasing order         while stack and heights[i] < heights[stack[-1]]:             h = heights[stack.pop()]  # height of the bar             # if stack is empty, it means entire width can be taken from index 0 to i-1             w = i if not stack else i - stack[-1] - 1  # calculate width             max_area = max(max_area, h * w)          stack.append(i)      return max_area\n2: def move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:      empty_columns = []      for column in range(size - 1, -1, -1):         if all(matrix_g[row][column] == \"-\" for row in range(size)):             empty_columns.append(column)      for column in empty_columns:         for col in range(column + 1, size):             for row in range(size):                 matrix_g[row][col - 1] = matrix_g[row][col]         for row in range(size):             matrix_g[row][-1] = \"-\"      return matrix_g", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)"}
{"task": "search", "input": "search code:\nReturns the number of different ways to make X pence using any number of coins.\n\nChoices:\n0: def encrypt(plaintext: str, key: str) -> str:     if not isinstance(plaintext, str):         raise TypeError(\"plaintext must be a string\")     if not isinstance(key, str):         raise TypeError(\"key must be a string\")      if not plaintext:         raise ValueError(\"plaintext is empty\")     if not key:         raise ValueError(\"key is empty\")      key += plaintext     plaintext = plaintext.lower()     key = key.lower()     plaintext_iterator = 0     key_iterator = 0     ciphertext = \"\"     while plaintext_iterator < len(plaintext):         if (             ord(plaintext[plaintext_iterator]) < 97             or ord(plaintext[plaintext_iterator]) > 122         ):             ciphertext += plaintext[plaintext_iterator]             plaintext_iterator += 1         elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:             key_iterator += 1         else:             ciphertext += chr(                 (                     (ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))                     - 97                 )                 % 26                 + 97             )             key_iterator += 1             plaintext_iterator += 1     return ciphertext\n1: def softplus(vector: np.ndarray) -> np.ndarray:     return np.log(1 + np.exp(vector))\n2: def solution(pence: int = 200) -> int:     coins = [1, 2, 5, 10, 20, 50, 100, 200]     number_of_ways = [0] * (pence + 1)     number_of_ways[0] = 1  # base case: 1 way to make 0 pence      for coin in coins:         for i in range(coin, pence + 1, 1):             number_of_ways[i] += number_of_ways[i - coin]     return number_of_ways[pence]", "output": "2"}
{"task": "detection", "input": "classify code:\ndef pigeon_sort(array):\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if(len(array) == 0):\n        return array\n\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "CORRECT"}
