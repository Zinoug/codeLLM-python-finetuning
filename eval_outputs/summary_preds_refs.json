[
  {
    "pred": "Converts 3d point to a 2d drawable point",
    "ref": "Converts 3d point to a 2d drawable point"
  },
  {
    "pred": "Implements the SquarePlus activation function.",
    "ref": "Implements the SquarePlus activation function."
  },
  {
    "pred": "A pure Python implementation of a recursive linear search algorithm",
    "ref": "A pure Python implementation of a recursive linear search algorithm"
  },
  {
    "pred": "Function to reshape a row Numpy array into a column Numpy array >>> input_array = np.array([1, 2, 3]) >>> column_reshape(input_array) array([[1], [2],",
    "ref": "Function to reshape a row Numpy array into a column Numpy array >>> input_array = np.array([1, 2, 3]) >>> column_reshape(input_array) array([[1], [2], [3]])"
  },
  {
    "pred": "Mark two strings as pluralized translations without translating them.",
    "ref": "Mark two strings as pluralized translations without translating them."
  },
  {
    "pred": "Power Iteration. Find the largest eigenvalue and corresponding eigenvector of matrix input_matrix given a random vector in the same space. Will work so long as vector has component of largest eigenvector. input_matrix must be either",
    "ref": "Power Iteration. Find the largest eigenvalue and corresponding eigenvector of matrix input_matrix given a random vector in the same space. Will work so long as vector has component of largest eigenvector. input_matrix must be either real or Hermitian."
  },
  {
    "pred": "This function returns a clone of a connected undirected graph. >>> clone_graph(Node(1)) Node(value=1, neighbors=[]) >>> clone_graph(Node(1, [Node(2)])) Node(",
    "ref": "This function returns a clone of a connected undirected graph. >>> clone_graph(Node(1)) Node(value=1, neighbors=[]) >>> clone_graph(Node(1, [Node(2)])) Node(value=1, neighbors=[Node(value=2, neighbors=[])]) >>> clone_graph(None) is None True"
  },
  {
    "pred": "Returns the nth ugly number. >>> ugly_numbers(100) 1536 >>> ugly_numbers(0) 1 >>> ugly_numbers(20) 36 >>> ugly_numbers(-5) 1 >>> ugly_numbers(-5.5",
    "ref": "Returns the nth ugly number. >>> ugly_numbers(100) 1536 >>> ugly_numbers(0) 1 >>> ugly_numbers(20) 36 >>> ugly_numbers(-5) 1 >>> ugly_numbers(-5.5) Traceback (most recent call last): ... TypeError: 'float' object cannot be interpreted as an integer"
  },
  {
    "pred": "Iterate the function \"eval_function\" exactly nb_iterations times. The first argument of the function is a parameter which is contained in function_params. The variable z_0 is an array that contains the initial values to iterate from",
    "ref": "Iterate the function \"eval_function\" exactly nb_iterations times. The first argument of the function is a parameter which is contained in function_params. The variable z_0 is an array that contains the initial values to iterate from. This function returns the final iterates."
  },
  {
    "pred": "Reverse all words that are longer than the given length of characters in a sentence. If unspecified, length is taken as 0",
    "ref": "Reverse all words that are longer than the given length of characters in a sentence. If unspecified, length is taken as 0"
  },
  {
    "pred": "Function for finding the triplets with a given sum in the array using hashing.",
    "ref": "Function for finding the triplets with a given sum in the array using hashing."
  },
  {
    "pred": "| Return the clauses and symbols from a formula. | A symbol is the uncomplemented form of a literal.",
    "ref": "| Return the clauses and symbols from a formula. | A symbol is the uncomplemented form of a literal."
  },
  {
    "pred": "Returns the nth lucas number >>> recursive_lucas_number(1) 1 >>> recursive_lucas_number(20) 15127 >>> recursive_lucas_number(0) 2 >>> recursive_",
    "ref": "Returns the nth lucas number >>> recursive_lucas_number(1) 1 >>> recursive_lucas_number(20) 15127 >>> recursive_lucas_number(0) 2 >>> recursive_lucas_number(25) 167761 >>> recursive_lucas_number(-1.5) Traceback (most recent call last): ... TypeError: recursive_lucas_number accepts only integer arguments."
  },
  {
    "pred": "[summary]",
    "ref": "[summary]"
  },
  {
    "pred": "Yield the circular shifts of *iterable*.",
    "ref": "Yield the circular shifts of *iterable*."
  },
  {
    "pred": "Calculate the number of non-bouncy numbers with at most n digits. >>> non_bouncy_exact(1) 9 >>> non_bouncy_exact(6) 7998 >>> non_boun",
    "ref": "Calculate the number of non-bouncy numbers with at most n digits. >>> non_bouncy_exact(1) 9 >>> non_bouncy_exact(6) 7998 >>> non_bouncy_exact(10) 136126"
  },
  {
    "pred": "Yield the distinct combinations of *r* items taken from *iterable*.",
    "ref": "Yield the distinct combinations of *r* items taken from *iterable*."
  },
  {
    "pred": "High-Low threshold detection. If an edge pixel's gradient value is higher than the high threshold value, it is marked as a strong edge pixel. If an edge pixel's gradient value is smaller than the high threshold value and larger than",
    "ref": "High-Low threshold detection. If an edge pixel's gradient value is higher than the high threshold value, it is marked as a strong edge pixel. If an edge pixel's gradient value is smaller than the high threshold value and larger than the low threshold value, it is marked as a weak edge pixel. If an edge pixel's value is smaller than the low threshold value, it will be suppressed."
  },
  {
    "pred": "Apply Electrical Impedance formula, on any two given electrical values, which can be resistance, reactance, and impedance, and then in a Python dict return name/value pair of the zero",
    "ref": "Apply Electrical Impedance formula, on any two given electrical values, which can be resistance, reactance, and impedance, and then in a Python dict return name/value pair of the zero value."
  },
  {
    "pred": "The inverse of :func:`zip`, this function disaggregates the elements of the zipped *iterable*.",
    "ref": "The inverse of :func:`zip`, this function disaggregates the elements of the zipped *iterable*."
  },
  {
    "pred": "Usage examples: >>> astable_duty_cycle(resistance_1=45, resistance_2=45) 66.66666666666666 >>> astable_duty_cycle(resistance_1=3",
    "ref": "Usage examples: >>> astable_duty_cycle(resistance_1=45, resistance_2=45) 66.66666666666666 >>> astable_duty_cycle(resistance_1=356, resistance_2=234) 71.60194174757282 >>> astable_duty_cycle(resistance_1=2, resistance_2=-1) Traceback (most recent call last): ... ValueError: All values must be positive >>> astable_duty_cycle(resistance_1=0, resistance_2=0) Traceback (most recent call last): ... ValueError: All values must be positive"
  },
  {
    "pred": "Returns tuples with exactly length *size*. If *fill* is unset and the iterable is too short to make a window of length *size*, no tuples are returned. See :func:`windowed_iter` for more.",
    "ref": "Returns tuples with exactly length *size*. If *fill* is unset and the iterable is too short to make a window of length *size*, no tuples are returned. See :func:`windowed_iter` for more."
  },
  {
    "pred": "Calculates the speed of sound in a fluid from its density and bulk modulus",
    "ref": "Calculates the speed of sound in a fluid from its density and bulk modulus"
  },
  {
    "pred": "Get image rotation :param img: np.ndarray :param pt1: 3x2 list :param pt2: 3x2 list :param rows: columns image shape :param cols: rows image shape",
    "ref": "Get image rotation :param img: np.ndarray :param pt1: 3x2 list :param pt2: 3x2 list :param rows: columns image shape :param cols: rows image shape :return: np.ndarray"
  },
  {
    "pred": "Pure implementation of sentinel linear search algorithm in Python",
    "ref": "Pure implementation of sentinel linear search algorithm in Python"
  },
  {
    "pred": "Returns two maps of (*types*, *funcs*) from *mod*, optionally ignoring based on the :class:`bool` return value of the *ignore* callable. *mod* can be a string name of a module",
    "ref": "Returns two maps of (*types*, *funcs*) from *mod*, optionally ignoring based on the :class:`bool` return value of the *ignore* callable. *mod* can be a string name of a module in :data:`sys.modules` or the module instance itself."
  },
  {
    "pred": "Yield all arguments passed to the function in the same order in which they were passed. If an argument itself is iterable then iterate over its values.",
    "ref": "Yield all arguments passed to the function in the same order in which they were passed. If an argument itself is iterable then iterate over its values."
  },
  {
    "pred": "Returns the sum of the digits in the factorial of num >>> solution(100) 648 >>> solution(50) 216 >>> solution(10) 27 >>> solution(5) 3 >>> solution(3) 6 >>> solution(",
    "ref": "Returns the sum of the digits in the factorial of num >>> solution(100) 648 >>> solution(50) 216 >>> solution(10) 27 >>> solution(5) 3 >>> solution(3) 6 >>> solution(2) 2 >>> solution(1) 1"
  },
  {
    "pred": "Get images list and annotations list from input dir. Update new images and annotations. Save images and annotations in output dir.",
    "ref": "Get images list and annotations list from input dir. Update new images and annotations. Save images and annotations in output dir."
  },
  {
    "pred": "Return an iterator over the results of ``func(start)``, ``func(start + 1)``, ``func(start + 2)``...",
    "ref": "Return an iterator over the results of ``func(start)``, ``func(start + 1)``, ``func(start + 2)``..."
  },
  {
    "pred": "Return the angle toward to point from (minx, miny)",
    "ref": "Return the angle toward to point from (minx, miny)"
  },
  {
    "pred": "Returns the sum of all even fibonacci sequence elements that are lower or equal to n.",
    "ref": "Returns the sum of all even fibonacci sequence elements that are lower or equal to n."
  },
  {
    "pred": "Calculates the first n (0-indexed) Fibonacci numbers using iteration >>> fib_iterative(0) [0] >>> fib_iterative(1) [0, 1] >>> fib_",
    "ref": "Calculates the first n (0-indexed) Fibonacci numbers using iteration >>> fib_iterative(0) [0] >>> fib_iterative(1) [0, 1] >>> fib_iterative(5) [0, 1, 1, 2, 3, 5] >>> fib_iterative(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> fib_iterative(-1) Traceback (most recent call last): ... ValueError: n is negative"
  },
  {
    "pred": "Examples: >>> radix_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5]",
    "ref": "Examples: >>> radix_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5]"
  },
  {
    "pred": "Finds the maclaurin approximation of sin",
    "ref": "Finds the maclaurin approximation of sin"
  },
  {
    "pred": "Returns the sum of the factorial of digits in n >>> sum_of_digit_factorial(15) 121 >>> sum_of_digit_factorial(0) 1",
    "ref": "Returns the sum of the factorial of digits in n >>> sum_of_digit_factorial(15) 121 >>> sum_of_digit_factorial(0) 1"
  },
  {
    "pred": "Returns the sum of all the primes below n.",
    "ref": "Returns the sum of all the primes below n."
  },
  {
    "pred": "Eliminate d from values[s]; propagate when values or places <= 2. Return values, except return False if a contradiction is detected.",
    "ref": "Eliminate d from values[s]; propagate when values or places <= 2. Return values, except return False if a contradiction is detected."
  },
  {
    "pred": "creating sparse table which saves each nodes 2^i-th parent >>> max_node = 6 >>> parent = [[0, 0, 1, 1, 2, 2, 3]] + [[0] * 7 for _ in range",
    "ref": "creating sparse table which saves each nodes 2^i-th parent >>> max_node = 6 >>> parent = [[0, 0, 1, 1, 2, 2, 3]] + [[0] * 7 for _ in range(19)] >>> parent = create_sparse(max_node=max_node, parent=parent) >>> parent[0] [0, 0, 1, 1, 2, 2, 3] >>> parent[1] [0, 0, 0, 0, 1, 1, 1] >>> parent[2] [0, 0, 0, 0, 0, 0, 0]"
  },
  {
    "pred": "Choose a random pivot for the list. We can use a more sophisticated algorithm here, such as the median-of-medians algorithm.",
    "ref": "Choose a random pivot for the list. We can use a more sophisticated algorithm here, such as the median-of-medians algorithm."
  },
  {
    "pred": "Finds the kth largest element in a list. Should deliver similar results to: ```python def kth_largest_element(arr, position): return sorted(arr)[-position] ```",
    "ref": "Finds the kth largest element in a list. Should deliver similar results to: ```python def kth_largest_element(arr, position): return sorted(arr)[-position] ```"
  },
  {
    "pred": "Returns the number of numbers below number_limit that produce chains with exactly chain_length non repeating elements.",
    "ref": "Returns the number of numbers below number_limit that produce chains with exactly chain_length non repeating elements."
  },
  {
    "pred": "Strips values from the beginning and end of an iterable. Stripped items will match the value of the argument strip_value. Functionality is analogous to that of the method str.strip. Returns a list.",
    "ref": "Strips values from the beginning and end of an iterable. Stripped items will match the value of the argument strip_value. Functionality is analogous to that of the method str.strip. Returns a list."
  },
  {
    "pred": "Returns the next number of the chain by adding the square of each digit to form a new number. For example, if number = 12, next_number() will return 1^2 + 2^2 = 5. Therefore, 5",
    "ref": "Returns the next number of the chain by adding the square of each digit to form a new number. For example, if number = 12, next_number() will return 1^2 + 2^2 = 5. Therefore, 5 is the next number of the chain. >>> next_number(44) 32 >>> next_number(10) 1 >>> next_number(32) 13"
  },
  {
    "pred": "Evaluate how similar the item is with the target by just counting each char in the right position >>> evaluate(\"Helxo Worlx\", \"Hello World\") ('Helxo Worlx', 9.0)",
    "ref": "Evaluate how similar the item is with the target by just counting each char in the right position >>> evaluate(\"Helxo Worlx\", \"Hello World\") ('Helxo Worlx', 9.0)"
  },
  {
    "pred": "Return the largest 1 to 9 pandigital 9-digital number that can be formed as the concatenated product of an integer with (1,2,...,n) where n > 1.",
    "ref": "Return the largest 1 to 9 pandigital 9-digital number that can be formed as the concatenated product of an integer with (1,2,...,n) where n > 1."
  },
  {
    "pred": "Extract the labels into a 1D uint8 numpy array [index].",
    "ref": "Extract the labels into a 1D uint8 numpy array [index]."
  },
  {
    "pred": "This function checks the grid to see if each row, column, and the 3x3 subgrids contain the digit 'n'. It returns False if it is not 'safe' (a duplicate digit is found) else returns True",
    "ref": "This function checks the grid to see if each row, column, and the 3x3 subgrids contain the digit 'n'. It returns False if it is not 'safe' (a duplicate digit is found) else returns True if it is 'safe'"
  },
  {
    "pred": "Function to validate the given credit card number. >>> validate_credit_card_number('4111111111111111') 4111111111111111 is a valid credit card number. True >>> validate_credit_card_number('h",
    "ref": "Function to validate the given credit card number. >>> validate_credit_card_number('4111111111111111') 4111111111111111 is a valid credit card number. True >>> validate_credit_card_number('helloworld$') helloworld$ is an invalid credit card number because it has nonnumerical characters. False >>> validate_credit_card_number('32323') 32323 is an invalid credit card number because of its length. False >>> validate_credit_card_number('32323323233232332323') 32323323233232332323 is an invalid credit card number because of its length. False >>> validate_credit_card_number('36111111111111') 36111111111111 is an invalid credit card number because of its first two digits. False >>> validate_credit_card_number('41111111111111') 41111111111111 is an invalid credit card number because it fails the Luhn check. False"
  },
  {
    "pred": "Constructs the convex hull of a set of 2D points using a brute force algorithm. The algorithm basically considers all combinations of points (i, j) and uses the definition of convexity to determine whether (i, j)",
    "ref": "Constructs the convex hull of a set of 2D points using a brute force algorithm. The algorithm basically considers all combinations of points (i, j) and uses the definition of convexity to determine whether (i, j) is part of the convex hull or not. (i, j) is part of the convex hull if and only iff there are no points on both sides of the line segment connecting the ij, and there is no point k such that k is on either end of the ij."
  },
  {
    "pred": "Call Modular Exponential Function. print(modular_exponential(3, 200, 13))",
    "ref": "Call Modular Exponential Function."
  },
  {
    "pred": "Given a list of integers where every element appears twice except for one, this function returns the element that appears only once using bitwise XOR.",
    "ref": "Given a list of integers where every element appears twice except for one, this function returns the element that appears only once using bitwise XOR."
  },
  {
    "pred": "Adds given file's length in front (using Elias gamma coding) of the compressed string",
    "ref": "Adds given file's length in front (using Elias gamma coding) of the compressed string"
  },
  {
    "pred": "Convenience function for calling :func:`windowed_iter` on *src*, with *size* set to 2.",
    "ref": "Convenience function for calling :func:`windowed_iter` on *src*, with *size* set to 2."
  },
  {
    "pred": "Count the number of set bits in a 32 bit integer >>> get_set_bits_count_using_brian_kernighans_algorithm(25) 3 >>> get_set_bits_count_using_",
    "ref": "Count the number of set bits in a 32 bit integer >>> get_set_bits_count_using_brian_kernighans_algorithm(25) 3 >>> get_set_bits_count_using_brian_kernighans_algorithm(37) 3 >>> get_set_bits_count_using_brian_kernighans_algorithm(21) 3 >>> get_set_bits_count_using_brian_kernighans_algorithm(58) 4 >>> get_set_bits_count_using_brian_kernighans_algorithm(0) 0 >>> get_set_bits_count_using_brian_kernighans_algorithm(256) 1 >>> get_set_bits_count_using_brian_kernighans_algorithm(-1) Traceback (most recent call last): ... ValueError: the value of input must not be negative"
  },
  {
    "pred": "Returns the number of different ways the number m can be written as a sum of at least two positive integers.",
    "ref": "Returns the number of different ways the number m can be written as a sum of at least two positive integers."
  },
  {
    "pred": "brute force approach to find distance between closest pair points",
    "ref": "brute force approach to find distance between closest pair points"
  },
  {
    "pred": "Returns the largest prime factor of a given number n.",
    "ref": "Returns the largest prime factor of a given number n."
  },
  {
    "pred": "Function updates the largest_square_area[0], if recursive call found square with maximum area.",
    "ref": "Function updates the largest_square_area[0], if recursive call found square with maximum area."
  },
  {
    "pred": "Return the number of times that the beam hits the interior wall of the cell before exiting. >>> solution(0.00001,-10) 1 >>> solution(5, 0) 287",
    "ref": "Return the number of times that the beam hits the interior wall of the cell before exiting. >>> solution(0.00001,-10) 1 >>> solution(5, 0) 287"
  },
  {
    "pred": "Calculates the first n (0-indexed) Fibonacci numbers using memoization >>> fib_memoization(0) [0] >>> fib_memoization(1) [0, 1] >>> fib",
    "ref": "Calculates the first n (0-indexed) Fibonacci numbers using memoization >>> fib_memoization(0) [0] >>> fib_memoization(1) [0, 1] >>> fib_memoization(5) [0, 1, 1, 2, 3, 5] >>> fib_memoization(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> fib_iterative(-1) Traceback (most recent call last): ... ValueError: n is negative"
  },
  {
    "pred": "Calculates the work required to move an object from one orbit to another in a gravitational field based on the change in total mechanical energy.",
    "ref": "Calculates the work required to move an object from one orbit to another in a gravitational field based on the change in total mechanical energy."
  },
  {
    "pred": "Check if number is a perfect square.",
    "ref": "Check if number is a perfect square."
  },
  {
    "pred": "The main function, it will simulate the evolution of the highway >>> simulate([[-1, 2, -1, -1, -1, 3]], 2, 0.0, 3) [[-1, 2",
    "ref": "The main function, it will simulate the evolution of the highway >>> simulate([[-1, 2, -1, -1, -1, 3]], 2, 0.0, 3) [[-1, 2, -1, -1, -1, 3], [-1, -1, -1, 2, -1, 0], [1, -1, -1, 0, -1, -1]] >>> simulate([[-1, 2, -1, 3]], 4, 0.0, 3) [[-1, 2, -1, 3], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0]]"
  },
  {
    "pred": "Return ``True`` if exactly ``n`` items in the iterable are ``True`` according to the *predicate* function.",
    "ref": "Return ``True`` if exactly ``n`` items in the iterable are ``True`` according to the *predicate* function."
  },
  {
    "pred": "Implements the ELU activation function. Parameters: vector: the array containing input of elu activation alpha: hyper-parameter return: elu (np.array): The input numpy array after applying elu.",
    "ref": "Implements the ELU activation function. Parameters: vector: the array containing input of elu activation alpha: hyper-parameter return: elu (np.array): The input numpy array after applying elu."
  },
  {
    "pred": "After each command, program prints treap",
    "ref": "After each command, program prints treap"
  },
  {
    "pred": "Determines whether n in base 'base' is a harshad number. Where 'base' ranges from 2 to 36.",
    "ref": "Determines whether n in base 'base' is a harshad number. Where 'base' ranges from 2 to 36."
  },
  {
    "pred": "This function creates a state space tree and calls the safe function until it receives a False Boolean and terminates that branch and backtracks to the next possible solution branch.",
    "ref": "This function creates a state space tree and calls the safe function until it receives a False Boolean and terminates that branch and backtracks to the next possible solution branch."
  },
  {
    "pred": "This method is recursive starting from (i, j) and going in one of four directions: up, down, left, right. If a path is found to destination it returns True otherwise it returns False. Parameters maze:",
    "ref": "This method is recursive starting from (i, j) and going in one of four directions: up, down, left, right. If a path is found to destination it returns True otherwise it returns False. Parameters maze: A two dimensional matrix of zeros and ones. i, j : coordinates of matrix solutions: A two dimensional matrix of solutions. Returns: Boolean if path is found True, Otherwise False."
  },
  {
    "pred": "Example function to calculate Mel Frequency Cepstral Coefficients (MFCCs) from an audio file.",
    "ref": "Example function to calculate Mel Frequency Cepstral Coefficients (MFCCs) from an audio file."
  },
  {
    "pred": "calculate xor of the input values",
    "ref": "calculate xor of the input values"
  },
  {
    "pred": "Compute a polynomial's coefficients from its roots.",
    "ref": "Compute a polynomial's coefficients from its roots."
  },
  {
    "pred": "Recursively draw the Vicsek fractal at the specified position, with the specified length and depth.",
    "ref": "Recursively draw the Vicsek fractal at the specified position, with the specified length and depth."
  },
  {
    "pred": "Wrap an iterator-returning callable to make its iterators thread-safe.",
    "ref": "Wrap an iterator-returning callable to make its iterators thread-safe."
  },
  {
    "pred": "Yield the primes less than n.",
    "ref": "Yield the primes less than n."
  },
  {
    "pred": "Define n count list and loop over delta, y to get the counts, then check which n has count == 1.",
    "ref": "Define n count list and loop over delta, y to get the counts, then check which n has count == 1."
  },
  {
    "pred": "Yield median of values in a sliding window.",
    "ref": "Yield median of values in a sliding window."
  },
  {
    "pred": "Change the shape of a *matrix*.",
    "ref": "Change the shape of a *matrix*."
  },
  {
    "pred": "Evaluate a polynomial f(x) at specified point x and return the value.",
    "ref": "Evaluate a polynomial f(x) at specified point x and return the value."
  },
  {
    "pred": "Calculates a list of totients from 0 to max_one exclusive, using the definition of Euler's product formula.",
    "ref": "Calculates a list of totients from 0 to max_one exclusive, using the definition of Euler's product formula."
  },
  {
    "pred": "Return the number of times a term occurs within a given document. @params: term, the term to search a document for, and document, the document to search within @returns: an integer representing the number of times a term is",
    "ref": "Return the number of times a term occurs within a given document. @params: term, the term to search a document for, and document, the document to search within @returns: an integer representing the number of times a term is found within the document"
  },
  {
    "pred": "Places of whether the absolute value of z_final is greater than the value of escape_radius. Adds the function_label and function_params to the title.",
    "ref": "Plots of whether the absolute value of z_final is greater than the value of escape_radius. Adds the function_label and function_params to the title."
  },
  {
    "pred": "Returns a dictionary with keys as the perimeter of a right angled triangle and value as the number of corresponding triplets. >>> pythagorean_triple(15) Counter({12: 1}) >>> pythag",
    "ref": "Returns a dictionary with keys as the perimeter of a right angled triangle and value as the number of corresponding triplets. >>> pythagorean_triple(15) Counter({12: 1}) >>> pythagorean_triple(40) Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1}) >>> pythagorean_triple(50) Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1, 48: 1})"
  },
  {
    "pred": "Returns the largest prime factor of a given number n.",
    "ref": "Returns the largest prime factor of a given number n."
  },
  {
    "pred": "Constructs a format field string from the field name, spec, and conversion character (``fname``, ``fspec``, ``conv``). See Python String Formatting for more info.",
    "ref": "Constructs a format field string from the field name, spec, and conversion character (``fname``, ``fspec``, ``conv``). See Python String Formatting for more info."
  },
  {
    "pred": "create edge between the nodes",
    "ref": "create edge between the nodes"
  },
  {
    "pred": "Multiply two matrices.",
    "ref": "Multiply two matrices."
  },
  {
    "pred": "An implementation of the Monte Carlo method to find area under a single variable non-negative real-valued continuous function, say f(x), where x lies within a continuous bounded interval, say [min_value,",
    "ref": "An implementation of the Monte Carlo method to find area under a single variable non-negative real-valued continuous function, say f(x), where x lies within a continuous bounded interval, say [min_value, max_value], where min_value and max_value are finite numbers 1. Let x be a uniformly distributed random variable between min_value to max_value 2. Expected value of f(x) = (integrate f(x) from min_value to max_value)/(max_value - min_value) 3. Finding expected value of f(x): a. Repeatedly draw x from uniform distribution b. Evaluate f(x) at each of the drawn x values c. Expected value = average of the function evaluations 4. Estimated value of integral = Expected value * (max_value - min_value) 5. Returns estimated value"
  },
  {
    "pred": "Performs multiplication of a graph's adjacency list representation with a vector.",
    "ref": "Performs multiplication of a graph's adjacency list representation with a vector."
  },
  {
    "pred": "Generate the triangular number at the specified position.",
    "ref": "Generate the triangular number at the specified position."
  },
  {
    "pred": "This function is used to perform avgpooling on the input array of 2D matrix(image) Args: arr: numpy array size: size of pooling matrix stride: the number of pixels shifts over the input matrix Returns: numpy",
    "ref": "This function is used to perform avgpooling on the input array of 2D matrix(image) Args: arr: numpy array size: size of pooling matrix stride: the number of pixels shifts over the input matrix Returns: numpy array of avgpooled matrix Sample Input Output: >>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2) array([[ 3., 5.], [11., 13.]]) >>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1) array([[161., 102.], [114., 69.]])"
  },
  {
    "pred": "Returns a plain-English description of an iterable's :func:`len()`, conditionally pluralized with :func:`cardinalize`, detailed below.",
    "ref": "Returns a plain-English description of an iterable's :func:`len()`, conditionally pluralized with :func:`cardinalize`, detailed below."
  },
  {
    "pred": "Return first *n* items of the *iterable* as a list.",
    "ref": "Return first *n* items of the *iterable* as a list."
  },
  {
    "pred": ":param s: The string that will be used at bwt algorithm :return: the string composed of the last char of each row of the ordered rotations and the index of the original string at ordered rotations list :raises TypeError:",
    "ref": ":param s: The string that will be used at bwt algorithm :return: the string composed of the last char of each row of the ordered rotations and the index of the original string at ordered rotations list :raises TypeError: If the s parameter type is not str :raises ValueError: If the s parameter is empty Examples:"
  },
  {
    "pred": "Take in a 32 bit integer, reverse its bits, return a 32 bit integer result",
    "ref": "Take in a 32 bit integer, reverse its bits, return a 32 bit integer result"
  },
  {
    "pred": "| Return pure symbols and their values to satisfy clause. | Pure symbols are symbols in a formula that exist only in one form, | either complemented or otherwise. | For example, | {{A4, A3 , A5",
    "ref": "| Return pure symbols and their values to satisfy clause. | Pure symbols are symbols in a formula that exist only in one form, | either complemented or otherwise. | For example, | {{A4 , A3 , A5' , A1 , A3'} , {A4} , {A3}} has pure symbols A4, A5' and A1."
  },
  {
    "pred": "Normalize an audio signal by scaling it to have values between -1 and 1.",
    "ref": "Normalize an audio signal by scaling it to have values between -1 and 1."
  },
  {
    "pred": "Some examples",
    "ref": "Some examples"
  },
  {
    "pred": "Optional method: interquatile range input : list of total user in float output : low limit of input in float this method can be used to check whether some data is outlier or not >>> interquartile_range_checker",
    "ref": "Optional method: interquatile range input : list of total user in float output : low limit of input in float this method can be used to check whether some data is outlier or not >>> interquartile_range_checker([1,2,3,4,5,6,7,8,9,10]) 2.8"
  },
  {
    "pred": "Parameters: vector (np.ndarray): A numpy array consisting of real values trainable_parameter: Use to implement various Swish Activation Functions",
    "ref": "Parameters: vector (np.ndarray): A numpy array consisting of real values trainable_parameter: Use to implement various Swish Activation Functions"
  },
  {
    "pred": "A B",
    "ref": "A B / \\ / \\ B C Bl A / \\ --> / / \\ Bl Br UB Br C / UB UB = unbalanced node"
  },
  {
    "pred": ":param collection: some mutable ordered collection with heterogeneous comparable items inside :return: the same collection ordered by ascending",
    "ref": ":param collection: some mutable ordered collection with heterogeneous comparable items inside :return: the same collection ordered by ascending"
  },
  {
    "pred": "Backport of non-windowed running_median() for Python 3.13 and prior.",
    "ref": "Backport of non-windowed running_median() for Python 3.13 and prior."
  },
  {
    "pred": "Run through the list of Letters and build the min heap for the Huffman Tree.",
    "ref": "Run through the list of Letters and build the min heap for the Huffman Tree."
  },
  {
    "pred": "Yield unique elements, preserving order.",
    "ref": "Yield unique elements, preserving order."
  },
  {
    "pred": "Will split the string up into all the values separated by the separator (defaults to spaces)",
    "ref": "Will split the string up into all the values separated by the separator (defaults to spaces)"
  },
  {
    "pred": "Conversion between pressure units. >>> pressure_conversion(4, \"atm\", \"pascal\") 405300 >>> pressure_conversion(1, \"pascal\", \"psi\") 0.000144019819999",
    "ref": "Conversion between pressure units. >>> pressure_conversion(4, \"atm\", \"pascal\") 405300 >>> pressure_conversion(1, \"pascal\", \"psi\") 0.00014401981999999998 >>> pressure_conversion(1, \"bar\", \"atm\") 0.986923 >>> pressure_conversion(3, \"kilopascal\", \"bar\") 0.029999991892499998 >>> pressure_conversion(2, \"megapascal\", \"psi\") 290.074434314 >>> pressure_conversion(4, \"psi\", \"torr\") 206.85984 >>> pressure_conversion(1, \"inHg\", \"atm\") 0.0334211 >>> pressure_conversion(1, \"torr\", \"psi\") 0.019336718261000002 >>> pressure_conversion(4, \"wrongUnit\", \"atm\") Traceback (most recent call last): ... ValueError: Invalid 'from_type' value: 'wrongUnit' Supported values are: atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr"
  },
  {
    "pred": "Converts small, non-negative integers with irregular constructions in English (i.e., numbers under 100) into words.",
    "ref": "Converts small, non-negative integers with irregular constructions in English (i.e., numbers under 100) into words."
  },
  {
    "pred": "Return an integer denoting the importance of a word. This measure of importance is calculated by log10(N/df), where N is the number of documents and df is the Document Frequency. @params : df, the",
    "ref": "Return an integer denoting the importance of a word. This measure of importance is calculated by log10(N/df), where N is the number of documents and df is the Document Frequency. @params : df, the Document Frequency, N, the number of documents in the corpus and smoothing, if True return the idf-smooth @returns : log10(N/df) or 1+log10(N/1+df) @examples : >>> inverse_document_frequency(3, 0) Traceback (most recent call last): ... ValueError: log10(0) is undefined. >>> inverse_document_frequency(1, 3) 0.477 >>> inverse_document_frequency(0, 3) Traceback (most recent call last): ... ZeroDivisionError: df must be > 0 >>> inverse_document_frequency(0, 3,True) 1.477"
  },
  {
    "pred": "Create Pascal's triangle for different number of rows >>> generate_pascal_triangle(0) [] >>> generate_pascal_triangle(1) [[1]] >>> generate_pascal_tri",
    "ref": "Create Pascal's triangle for different number of rows >>> generate_pascal_triangle(0) [] >>> generate_pascal_triangle(1) [[1]] >>> generate_pascal_triangle(2) [[1], [1, 1]] >>> generate_pascal_triangle(3) [[1], [1, 1], [1, 2, 1]] >>> generate_pascal_triangle(4) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] >>> generate_pascal_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> generate_pascal_triangle(-5) Traceback (most recent call last): ... ValueError: The input value of 'num_rows' should be greater than or equal to 0 >>> generate_pascal_triangle(7.89) Traceback (most recent call last): ... TypeError: The input value of 'num_rows' should be 'int'"
  },
  {
    "pred": "Computes the sign perpendicular distance of a 2d point c from a line segment ab. The sign indicates the direction of c relative to ab. A Positive value means c is above ab (to the left), while a",
    "ref": "Computes the sign perpendicular distance of a 2d point c from a line segment ab. The sign indicates the direction of c relative to ab. A Positive value means c is above ab (to the left), while a negative value means c is below ab (to the right). 0 means all three points are on a straight line."
  },
  {
    "pred": "Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi",
    "ref": "Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi"
  },
  {
    "pred": "Computes incrementing Fibonacci numbers starting from 3 until the length of the resulting Fibonacci result is the input value n. Returns the term of the Fibonacci sequence where this occurs.",
    "ref": "Computes incrementing Fibonacci numbers starting from 3 until the length of the resulting Fibonacci result is the input value n. Returns the term of the Fibonacci sequence where this occurs."
  },
  {
    "pred": "Recursive Backtracking Depth First Search Algorithm",
    "ref": "Recursive Backtracking Depth First Search Algorithm"
  },
  {
    "pred": "Finds fibonacci number in index k.",
    "ref": "Finds fibonacci number in index k."
  },
  {
    "pred": "Return the elements from each of the input iterables that aren't in the other input iterables.",
    "ref": "Return the elements from each of the input iterables that aren't in the other input iterables."
  },
  {
    "pred": "This function implements the minimax algorithm, which helps achieve the optimal score for a player in a two-player game by checking all possible moves. If the player is the maximizer, then the score is maximized. If the",
    "ref": "This function implements the minimax algorithm, which helps achieve the optimal score for a player in a two-player game by checking all possible moves. If the player is the maximizer, then the score is maximized. If the player is the minimizer, then the score is minimized."
  },
  {
    "pred": "Treats curve as a collection of linear lines and sums the area of the trapezium shape they form :param fnc: a function which defines a curve :param x_start: left end point to indicate the start",
    "ref": "Treats curve as a collection of linear lines and sums the area of the trapezium shape they form :param fnc: a function which defines a curve :param x_start: left end point to indicate the start of line segment :param x_end: right end point to indicate end of line segment :param steps: an accuracy gauge; more steps increases the accuracy :return: a float representing the length of the curve"
  },
  {
    "pred": "Yield the prime factors of n.",
    "ref": "Yield the prime factors of n."
  },
  {
    "pred": "Take in 1 integer, return a number that is the number of trailing zeros in binary representation of that number.",
    "ref": "Take in 1 integer, return a number that is the number of trailing zeros in binary representation of that number."
  },
  {
    "pred": "Strips values from the beginning of an iterable. Stripped items will match the value of the argument strip_value. Functionality is analogous to that of the method str.lstrip. Returns a generator.",
    "ref": "Strips values from the beginning of an iterable. Stripped items will match the value of the argument strip_value. Functionality is analogous to that of the method str.lstrip. Returns a generator."
  },
  {
    "pred": "checking whether the input series is geometric series or not >>> is_geometric_series([2, 4, 8]) True >>> is_geometric_series([3, 6, 12, 24]) True >>> is_geom",
    "ref": "checking whether the input series is geometric series or not >>> is_geometric_series([2, 4, 8]) True >>> is_geometric_series([3, 6, 12, 24]) True >>> is_geometric_series([1, 2, 3]) False >>> is_geometric_series([0, 0, 3]) False >>> is_geometric_series([]) Traceback (most recent call last): ... ValueError: Input list must be a non empty list >>> is_geometric_series(4) Traceback (most recent call last): ... ValueError: Input series is not valid, valid series - [2, 4, 8]"
  },
  {
    "pred": "Percent-encode a single query string key or value.",
    "ref": "Percent-encode a single query string key or value."
  },
  {
    "pred": "A pure Python implementation of Dutch National Flag sort algorithm. :param data: 3 unique integer values (e.g., 0, 1, 2) in an sequence :return: The same collection in ascending order",
    "ref": "A pure Python implementation of Dutch National Flag sort algorithm. :param data: 3 unique integer values (e.g., 0, 1, 2) in an sequence :return: The same collection in ascending order"
  },
  {
    "pred": "Check if a word can be placed at the given position.",
    "ref": "Check if a word can be placed at the given position."
  },
  {
    "pred": "This is the function to integrate, f(x) = (x - 0)^2 = x^2.",
    "ref": "This is the function to integrate, f(x) = (x - 0)^2 = x^2."
  },
  {
    "pred": "Implements the Softplus activation function.",
    "ref": "Implements the Softplus activation function."
  },
  {
    "pred": "Return a Python Standard Library set that contains i.",
    "ref": "Return a Python Standard Library set that contains i."
  },
  {
    "pred": "Returns the least value of n for which the remainder first exceeds 10^10. >>> solution(1e8) 2371 >>> solution(1e9) 7037",
    "ref": "Returns the least value of n for which the remainder first exceeds 10^10. >>> solution(1e8) 2371 >>> solution(1e9) 7037"
  },
  {
    "pred": "Isolates the decimal part of a number. If digitAmount > 0 round to that decimal place, else print the entire decimal. >>> decimal_isolate(1.53, 0) 0.53 >>> decimal_isolate",
    "ref": "Isolates the decimal part of a number. If digitAmount > 0 round to that decimal place, else print the entire decimal. >>> decimal_isolate(1.53, 0) 0.53 >>> decimal_isolate(35.345, 1) 0.3 >>> decimal_isolate(35.345, 2) 0.34 >>> decimal_isolate(35.345, 3) 0.345 >>> decimal_isolate(-14.789, 3) -0.789 >>> decimal_isolate(0, 2) 0 >>> decimal_isolate(-14.123, 1) -0.1 >>> decimal_isolate(-14.123, 2) -0.12 >>> decimal_isolate(-14.123, 3) -0.123"
  },
  {
    "pred": "Returns the maximum sum of k consecutive elements >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20] >>> k = 4 >>> max_sum_in_array(arr, k)",
    "ref": "Returns the maximum sum of k consecutive elements >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20] >>> k = 4 >>> max_sum_in_array(arr, k) 24 >>> k = 10 >>> max_sum_in_array(arr,k) Traceback (most recent call last): ... ValueError: Invalid Input >>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2] >>> k = 4 >>> max_sum_in_array(arr, k) 27"
  },
  {
    "pred": "Checks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number (i.e., if",
    "ref": "Checks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number (i.e., if the result is true, then the number is indeed prime else it is not)."
  },
  {
    "pred": "find edges of multiple frequent subgraphs",
    "ref": "find edges of multiple frequent subgraphs"
  },
  {
    "pred": ":param src: the source image, which should be a grayscale or color image. :param ksize: the size of the kernel used to compute the Laplacian filter, which can be 1, 3, 5, or",
    "ref": ":param src: the source image, which should be a grayscale or color image. :param ksize: the size of the kernel used to compute the Laplacian filter, which can be 1, 3, 5, or 7."
  },
  {
    "pred": "Evaluate a given expression in prefix notation. Asserts that the given expression is valid.",
    "ref": "Evaluate a given expression in prefix notation. Asserts that the given expression is valid."
  },
  {
    "pred": "A function to print the solution in the form of a 9x9 grid",
    "ref": "A function to print the solution in the form of a 9x9 grid"
  },
  {
    "pred": "Decode the input string using the provided key.",
    "ref": "Decode the input string using the provided key."
  },
  {
    "pred": "Processes the game logic for the given matrix and moves.",
    "ref": "Processes the game logic for the given matrix and moves."
  },
  {
    "pred": "Scalars are bytes, strings, and non-iterables.",
    "ref": "Scalars are bytes, strings, and non-iterables."
  },
  {
    "pred": "Validates that the number of elements in the matrix matches the given size.",
    "ref": "Validates that the number of elements in the matrix matches the given size."
  },
  {
    "pred": "Returns True if number is bouncy, False otherwise >>> check_bouncy(6789) False >>> check_bouncy(-12345) False >>> check_bouncy(0) False >>> check_b",
    "ref": "Returns True if number is bouncy, False otherwise >>> check_bouncy(6789) False >>> check_bouncy(-12345) False >>> check_bouncy(0) False >>> check_bouncy(6.74) Traceback (most recent call last): ... ValueError: check_bouncy() accepts only integer arguments >>> check_bouncy(132475) True >>> check_bouncy(34) False >>> check_bouncy(341) True >>> check_bouncy(47) False >>> check_bouncy(-12.54) Traceback (most recent call last): ... ValueError: check_bouncy() accepts only integer arguments >>> check_bouncy(-6548) True"
  },
  {
    "pred": "Returns a list of nodes value from a whole binary tree in Level Order Traverse. Level Order traverse: Visit nodes of the tree level-by-level. >>> list(level_order(make_tree())) [1,",
    "ref": "Returns a list of nodes value from a whole binary tree in Level Order Traverse. Level Order traverse: Visit nodes of the tree level-by-level. >>> list(level_order(make_tree())) [1, 2, 3, 4, 5]"
  },
  {
    "pred": "Sets the default exception hook :func:`sys.excepthook` to the :func:`tbutils.print_exception` that uses all the ``tbutils`` facilities to provide a consistent output behavior.",
    "ref": "Sets the default exception hook :func:`sys.excepthook` to the :func:`tbutils.print_exception` that uses all the ``tbutils`` facilities to provide a consistent output behavior."
  },
  {
    "pred": "Returns the number of hybrid-integers less than or equal to base^degree",
    "ref": "Returns the number of hybrid-integers less than or equal to base^degree"
  },
  {
    "pred": "Installs a handler which, instead of exiting, attaches a post-mortem pdb console whenever an unhandled exception is encountered.",
    "ref": "Installs a handler which, instead of exiting, attaches a post-mortem pdb console whenever an unhandled exception is encountered."
  },
  {
    "pred": "Implementation of breadth first search using queue.Queue.",
    "ref": "Implementation of breadth first search using queue.Queue."
  },
  {
    "pred": "Return the sum of the factorial of the digits of n. >>> sum_digit_factorials(145) 145 >>> sum_digit_factorials(45361) 871 >>> sum_digit_factor",
    "ref": "Return the sum of the factorial of the digits of n. >>> sum_digit_factorials(145) 145 >>> sum_digit_factorials(45361) 871 >>> sum_digit_factorials(540) 145"
  },
  {
    "pred": "Convert grid to a dict of possible values, {square: digits}, or return False if a contradiction is detected.",
    "ref": "Convert grid to a dict of possible values, {square: digits}, or return False if a contradiction is detected."
  },
  {
    "pred": "Implementation of a start algorithm. world : Object of the world object. start : Object of the cell as start position. stop : Object of the cell as goal position.",
    "ref": "Implementation of a start algorithm. world : Object of the world object. start : Object of the cell as start position. stop : Object of the cell as goal position."
  },
  {
    "pred": "Returns the sum of all the multiples of 3 or 5 below n.",
    "ref": "Returns the sum of all the multiples of 3 or 5 below n."
  },
  {
    "pred": "Copy formatargspec from python 3.7 standard library. Python 3 has deprecated formatargspec and requested that Signature be used instead, however this requires a full reimplementation of formatargspec() in terms of creating Parameter objects and such. Instead of",
    "ref": "Copy formatargspec from python 3.7 standard library. Python 3 has deprecated formatargspec and requested that Signature be used instead, however this requires a full reimplementation of formatargspec() in terms of creating Parameter objects and such. Instead of introducing all the object-creation overhead and having to reinvent from scratch, just copy their compatibility routine."
  },
  {
    "pred": "Slice and combine two strings at a random point. >>> random.seed(42) >>> crossover(\"123456\", \"abcdef\") ('12345f', 'abcde6')",
    "ref": "Slice and combine two strings at a random point. >>> random.seed(42) >>> crossover(\"123456\", \"abcdef\") ('12345f', 'abcde6')"
  },
  {
    "pred": "Given an encrypted message and a possible 3-character key, decrypt the message. If the decrypted message contains a invalid character, i.e. not an ASCII letter, a digit, punctuation or whitespace, then we know the key is",
    "ref": "Given an encrypted message and a possible 3-character key, decrypt the message. If the decrypted message contains a invalid character, i.e. not an ASCII letter, a digit, punctuation or whitespace, then we know the key is incorrect, so return None. >>> try_key([0, 17, 20, 4, 27], (104, 116, 120)) 'hello' >>> try_key([68, 10, 300, 4, 27], (104, 116, 120)) is None True"
  },
  {
    "pred": "Returns the smallest positive number that is evenly divisible (divisible with no remainder) by all of the numbers from 1 to n.",
    "ref": "Returns the smallest positive number that is evenly divisible (divisible with no remainder) by all of the numbers from 1 to n."
  },
  {
    "pred": "Find the floor and ceiling values for a given key in a Binary Search Tree (BST).",
    "ref": "Find the floor and ceiling values for a given key in a Binary Search Tree (BST)."
  },
  {
    "pred": "The complement of :func:`unique()`.",
    "ref": "The complement of :func:`unique()`."
  },
  {
    "pred": "Return the direction toward to the line from via to target from starting",
    "ref": "Return the direction toward to the line from via to target from starting"
  },
  {
    "pred": "Wrapper function to call subroutine called util_color which will either return True or False. If True is returned colored_vertices list is filled with correct colorings",
    "ref": "Wrapper function to call subroutine called util_color which will either return True or False. If True is returned colored_vertices list is filled with correct colorings"
  },
  {
    "pred": "Calculate the distance between two coordinate points >>> distance([0, 0], [3, 4] ) 5.0 >>> distance([0, 0], [-3, 4] ) 5.0 >>> distance([0, 0], [-",
    "ref": "Calculate the distance between two coordinate points >>> distance([0, 0], [3, 4] ) 5.0 >>> distance([0, 0], [-3, 4] ) 5.0 >>> distance([0, 0], [-3, -4] ) 5.0"
  },
  {
    "pred": "Formula for amortization amount per month: A = p * r * (1 + r)^n / ((1 + r)^n - 1) where p is the principal, r is the rate of interest per month",
    "ref": "Formula for amortization amount per month: A = p * r * (1 + r)^n / ((1 + r)^n - 1) where p is the principal, r is the rate of interest per month and n is the number of payments"
  },
  {
    "pred": "A",
    "ref": "A A Br / \\ / \\ / \\ B C LR Br C RR B A / \\ --> / \\ --> / / \\ Bl Br B UB Bl UB C \\ / UB Bl RR = right_rotation LR = left_rotation"
  },
  {
    "pred": "A generalized outer product that applies a binary function to all pairs of items. Returns a 2D matrix with ``len(xs)`` rows and ``len(ys)`` columns. Also accepts ``*args`` and ``**",
    "ref": "A generalized outer product that applies a binary function to all pairs of items. Returns a 2D matrix with ``len(xs)`` rows and ``len(ys)`` columns. Also accepts ``*args`` and ``**kwargs`` that are passed to ``func``."
  },
  {
    "pred": "Simple image transformation using one of two available filter functions: Erosion and Dilation.",
    "ref": "Simple image transformation using one of two available filter functions: Erosion and Dilation."
  },
  {
    "pred": "| Plays FizzBuzz. | Prints Fizz if number is a multiple of ``3``. | Prints Buzz if its a multiple of ``5``. | Prints FizzBuzz if its a",
    "ref": "| Plays FizzBuzz. | Prints Fizz if number is a multiple of ``3``. | Prints Buzz if its a multiple of ``5``. | Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``. | Else Prints The Number Itself."
  },
  {
    "pred": "Let's benchmark our functions side-by-side...",
    "ref": "Let's benchmark our functions side-by-side..."
  },
  {
    "pred": "Returns the sum of all the multiples of 3 or 5 below n.",
    "ref": "Returns the sum of all the multiples of 3 or 5 below n."
  },
  {
    "pred": "Implements the LeakyReLU activation function.",
    "ref": "Implements the LeakyReLU activation function."
  },
  {
    "pred": "Returns the sum of all even fibonacci sequence elements that are lower or equal to n.",
    "ref": "Returns the sum of all even fibonacci sequence elements that are lower or equal to n."
  },
  {
    "pred": "Returns the minimum cuts needed for a palindrome partitioning of string",
    "ref": "Returns the minimum cuts needed for a palindrome partitioning of string"
  },
  {
    "pred": "This function used the above inversion of a to find x = (b*a^(-1))mod n",
    "ref": "This function used the above inversion of a to find x = (b*a^(-1))mod n"
  },
  {
    "pred": "To evaluate the solution, use solution() >>> slow_solution(3) 120 >>> slow_solution(6) 18720 >>> slow_solution(7) 68720",
    "ref": "To evaluate the solution, use solution() >>> slow_solution(3) 120 >>> slow_solution(6) 18720 >>> slow_solution(7) 68720"
  },
  {
    "pred": "Version with one liner",
    "ref": "Version with one liner"
  },
  {
    "pred": "Find all the valid positions a knight can move to from the current position.",
    "ref": "Find all the valid positions a knight can move to from the current position."
  },
  {
    "pred": "Returns the difference between the sum of the squares of the first n natural numbers and the square of the sum.",
    "ref": "Returns the difference between the sum of the squares of the first n natural numbers and the square of the sum."
  },
  {
    "pred": "Solves the problem for n_digits number of digits.",
    "ref": "Solves the problem for n_digits number of digits."
  },
  {
    "pred": "Return a 2-tuple with a list containing the first *n* elements of *iterable*, and an iterator with the same items as *iterable*. This allows you to \"look ahead\" at the items in the iterable without adv",
    "ref": "Return a 2-tuple with a list containing the first *n* elements of *iterable*, and an iterator with the same items as *iterable*. This allows you to \"look ahead\" at the items in the iterable without advancing it."
  },
  {
    "pred": "Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4.",
    "ref": "Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4."
  },
  {
    "pred": "Return overlapping triplets from *iterable*.",
    "ref": "Return overlapping triplets from *iterable*."
  },
  {
    "pred": "# >>> quantum_fourier_transform(2) # {'00': 2500, '01': 2500, '11': 2500, '10': 2500}",
    "ref": "# >>> quantum_fourier_transform(2) # {'00': 2500, '01': 2500, '11': 2500, '10': 2500} # quantum circuit for number_of_qubits = 3: \u250c\u2500\u2500\u2500\u2510 qr_0: \u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500X\u2500 \u2502 \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/2) \u2514\u2500\u2500\u2500\u2518 \u2502 qr_1: \u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/4) \u2502P(\u03c0/2) \u2514\u2500\u2500\u2500\u2518 \u2502 qr_2: \u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500 \u2514\u2500\u2500\u2500\u2518 cr: 3/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Args: n : number of qubits Returns: qiskit.result.counts.Counts: distribute counts."
  },
  {
    "pred": "Print the prime numbers up to n",
    "ref": "Print the prime numbers up to n"
  },
  {
    "pred": "Returns the product of a,b,c which are Pythagorean Triplet that satisfies the following: 1. a < b < c 2. a**2 + b**2 = c**2 3. a +",
    "ref": "Returns the product of a,b,c which are Pythagorean Triplet that satisfies the following: 1. a < b < c 2. a**2 + b**2 = c**2 3. a + b + c = 1000"
  },
  {
    "pred": "Return Distinct edges from edge array of multiple graphs >>> sorted(get_distinct_edge(edge_array)) ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']",
    "ref": "Return Distinct edges from edge array of multiple graphs >>> sorted(get_distinct_edge(edge_array)) ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']"
  },
  {
    "pred": "Return the sigmoid function of a float.",
    "ref": "Return the sigmoid function of a float."
  },
  {
    "pred": "Function implements adler-32 hash. Iterates and evaluates a new value for each character",
    "ref": "Function implements adler-32 hash. Iterates and evaluates a new value for each character"
  },
  {
    "pred": "Take in 2 positive integers. 'number' is the integer to be logically left shifted 'shift_amount' times. i.e. (number << shift_amount) Return the shifted binary representation.",
    "ref": "Take in 2 positive integers. 'number' is the integer to be logically left shifted 'shift_amount' times. i.e. (number << shift_amount) Return the shifted binary representation."
  },
  {
    "pred": "Returns the difference between the sum of the squares of the first n natural numbers and the square of the sum.",
    "ref": "Returns the difference between the sum of the squares of the first n natural numbers and the square of the sum."
  },
  {
    "pred": "Approximates the arc length of a line segment by treating the curve as a sequence of linear lines and summing their lengths :param fnc: a function which defines a curve :param x_start: left end point to indicate",
    "ref": "Approximates the arc length of a line segment by treating the curve as a sequence of linear lines and summing their lengths :param fnc: a function which defines a curve :param x_start: left end point to indicate the start of line segment :param x_end: right end point to indicate end of line segment :param steps: an accuracy gauge; more steps increases accuracy :return: a float representing the length of the curve"
  },
  {
    "pred": "Converts a string to title case, preserving the input as is",
    "ref": "Converts a string to title case, preserving the input as is"
  },
  {
    "pred": "Depth First Search on Graph :param graph: directed graph in dictionary format :param start: starting vertex as a string :returns: the trace of the search >>> input_G = { \"A\": [\"B\", \"C\", \"",
    "ref": "Depth First Search on Graph :param graph: directed graph in dictionary format :param start: starting vertex as a string :returns: the trace of the search >>> input_G = { \"A\": [\"B\", \"C\", \"D\"], \"B\": [\"A\", \"D\", \"E\"], ... \"C\": [\"A\", \"F\"], \"D\": [\"B\", \"D\"], \"E\": [\"B\", \"F\"], ... \"F\": [\"C\", \"E\", \"G\"], \"G\": [\"F\"] } >>> output_G = list({'A', 'B', 'C', 'D', 'E', 'F', 'G'}) >>> all(x in output_G for x in list(depth_first_search(input_G, \"A\"))) True >>> all(x in output_G for x in list(depth_first_search(input_G, \"G\"))) True"
  },
  {
    "pred": "Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm and returns the result as a string",
    "ref": "Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm and returns the result as a string"
  },
  {
    "pred": "Calculate Bell numbers for the sets of lengths from 0 to max_set_length. In other words, calculate first (max_set_length + 1) Bell numbers.",
    "ref": "Calculate Bell numbers for the sets of lengths from 0 to max_set_length. In other words, calculate first (max_set_length + 1) Bell numbers."
  },
  {
    "pred": "Calculate OR of the input values >>> or_gate(0, 0) 0 >>> or_gate(0, 1) 1 >>> or_gate(1, 0) 1 >>> or_gate(1, 1) 1",
    "ref": "Calculate OR of the input values >>> or_gate(0, 0) 0 >>> or_gate(0, 1) 1 >>> or_gate(1, 0) 1 >>> or_gate(1, 1) 1"
  },
  {
    "pred": "Return the first value of the first four consecutive integers to have four distinct prime factors each. >>> solution() 134043",
    "ref": "Return the first value of the first four consecutive integers to have four distinct prime factors each. >>> solution() 134043"
  },
  {
    "pred": "function is f(x) = x^3 - 2x - 5 >>> f(2) -1.0",
    "ref": "function is f(x) = x^3 - 2x - 5 >>> f(2) -1.0"
  },
  {
    "pred": "Yield the items from *iterable* that haven't been seen recently. *n* is the size of the sliding window.",
    "ref": "Yield the items from *iterable* that haven't been seen recently. *n* is the size of the sliding window."
  },
  {
    "pred": "The main function. For list of numbers 'nums' find the subsets with sum equal to 'max_sum'",
    "ref": "The main function. For list of numbers 'nums' find the subsets with sum equal to 'max_sum'"
  },
  {
    "pred": "Calculate the local weights at a given prediction point using the weight matrix for that point",
    "ref": "Calculate the local weights at a given prediction point using the weight matrix for that point"
  },
  {
    "pred": "Checks to see if a number is a prime in O(sqrt(n)).",
    "ref": "Checks to see if a number is a prime in O(sqrt(n))."
  },
  {
    "pred": "Main function to create and simplify a K-Map.",
    "ref": "Main function to create and simplify a K-Map."
  },
  {
    "pred": "Inputs an array of integers representing the heights of bars, and returns the area of the largest rectangle that can be formed",
    "ref": "Inputs an array of integers representing the heights of bars, and returns the area of the largest rectangle that can be formed"
  },
  {
    "pred": "Equivalent to ``list(product(*args))[index]``.",
    "ref": "Equivalent to ``list(product(*args))[index]``."
  },
  {
    "pred": "Returns the sum of all even fibonacci sequence elements that are lower or equal to n.",
    "ref": "Returns the sum of all even fibonacci sequence elements that are lower or equal to n."
  },
  {
    "pred": "Sorts a list in ascending order using the selection sort algorithm.",
    "ref": "Sorts a list in ascending order using the selection sort algorithm."
  },
  {
    "pred": "Display Forbes real-time billionaires in a rich table.",
    "ref": "Display Forbes real-time billionaires in a rich table."
  },
  {
    "pred": "Convert a octal value to its decimal equivalent",
    "ref": "Convert a octal value to its decimal equivalent"
  },
  {
    "pred": "- label_dir <type: str>: Path to label include annotation of images - img_dir <type: str>: Path to folder contain images Return <type: list>: List of images path and labels",
    "ref": "- label_dir <type: str>: Path to label include annotation of images - img_dir <type: str>: Path to folder contain images Return <type: list>: List of images path and labels"
  },
  {
    "pred": "Performs Run Length Decoding >>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]) 'AAAABBBCCDAA' >>>",
    "ref": "Performs Run Length Decoding >>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]) 'AAAABBBCCDAA' >>> run_length_decode([('A', 1)]) 'A' >>> run_length_decode([('A', 2)]) 'AA' >>> run_length_decode([('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]) 'AAADDDDDDFFFCCCAAVVVV'"
  },
  {
    "pred": "A pure Python implementation of circle sort algorithm",
    "ref": "A pure Python implementation of circle sort algorithm"
  },
  {
    "pred": "Find the number of digits in a number. abs() is used for negative numbers",
    "ref": "Find the number of digits in a number. abs() is used for negative numbers"
  },
  {
    "pred": "Go through the number of iterations determined by the argument \"steps\". Be careful with high values (above 5) since the time to calculate increases exponentially. >>> iterate([np.array([0, 0]), np.array",
    "ref": "Go through the number of iterations determined by the argument \"steps\". Be careful with high values (above 5) since the time to calculate increases exponentially. >>> iterate([np.array([0, 0]), np.array([1, 0])], 1) [array([0, 0]), array([0.33333333, 0. ]), array([0.5 , 0.28867513]), array([0.66666667, 0. ]), array([1, 0])]"
  },
  {
    "pred": "Returns the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9.",
    "ref": "Returns the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9."
  },
  {
    "pred": "Implementation of the MSD radix sort algorithm. Only works with positive integers :param list_of_ints: A list of integers :return: Returns the sorted list >>> msd_radix_sort([40, 12, 1",
    "ref": "Implementation of the MSD radix sort algorithm. Only works with positive integers :param list_of_ints: A list of integers :return: Returns the sorted list >>> msd_radix_sort([40, 12, 1, 100, 4]) [1, 4, 12, 40, 100] >>> msd_radix_sort([]) [] >>> msd_radix_sort([123, 345, 123, 80]) [80, 123, 123, 345] >>> msd_radix_sort([1209, 834598, 1, 540402, 45]) [1, 45, 1209, 540402, 834598] >>> msd_radix_sort([-1, 34, 45]) Traceback (most recent call last): ... ValueError: All numbers must be positive"
  },
  {
    "pred": "rotate a point around a certain axis with a certain angle angle can be any integer between 1, 360 and axis can be any one of 'x', 'y', 'z'",
    "ref": "rotate a point around a certain axis with a certain angle angle can be any integer between 1, 360 and axis can be any one of 'x', 'y', 'z'"
  },
  {
    "pred": "Splits an iterable based on a separator. Like :meth:`str.split`, but for all iterables. Returns a list of lists.",
    "ref": "Splits an iterable based on a separator. Like :meth:`str.split`, but for all iterables. Returns a list of lists."
  },
  {
    "pred": "Computes the Fibonacci number for input n by iterating through n numbers and creating an array of ints using the Fibonacci formula. Returns the nth element of the array.",
    "ref": "Computes the Fibonacci number for input n by iterating through n numbers and creating an array of ints using the Fibonacci formula. Returns the nth element of the array."
  },
  {
    "pred": "returns the biggest possible result that can be achieved by removing one digit from the given number",
    "ref": "returns the biggest possible result that can be achieved by removing one digit from the given number"
  },
  {
    "pred": "Computes a^b % c recursively, where a is the base, b is the exponent, and c is the modulus",
    "ref": "Computes a^b % c recursively, where a is the base, b is the exponent, and c is the modulus"
  },
  {
    "pred": "Return number in string scientific notation z.wq x 10\u207f.",
    "ref": "Return number in string scientific notation z.wq x 10\u207f."
  },
  {
    "pred": "Request that user input an integer and tell them if it is Armstrong number.",
    "ref": "Request that user input an integer and tell them if it is Armstrong number."
  },
  {
    "pred": "Return a list of all primes numbers up to max. >>> list(slow_primes(0)) [] >>> list(slow_primes(-1)) [] >>> list(slow_primes(-10))",
    "ref": "Return a list of all primes numbers up to max. >>> list(slow_primes(0)) [] >>> list(slow_primes(-1)) [] >>> list(slow_primes(-10)) [] >>> list(slow_primes(25)) [2, 3, 5, 7, 11, 13, 17, 19, 23] >>> list(slow_primes(11)) [2, 3, 5, 7, 11] >>> list(slow_primes(33)) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31] >>> list(slow_primes(1000))[-1] 997"
  },
  {
    "pred": "Conversion between astronomical length units.",
    "ref": "Conversion between astronomical length units."
  },
  {
    "pred": "Return the nth or the last item of *iterable*, or *default* if *iterable* is empty.",
    "ref": "Return the nth or the last item of *iterable*, or *default* if *iterable* is empty."
  },
  {
    "pred": "Yield all substrings and their positions in *seq*",
    "ref": "Yield all substrings and their positions in *seq*"
  },
  {
    "pred": "Decrypts the ciphertext using the Running Key Cipher.",
    "ref": "Decrypts the ciphertext using the Running Key Cipher."
  },
  {
    "pred": "Find the equilibrium index of an array.",
    "ref": "Find the equilibrium index of an array."
  },
  {
    "pred": "Finds the longest common subsequence between two strings. Also returns the The subsequence found",
    "ref": "Finds the longest common subsequence between two strings. Also returns the The subsequence found"
  },
  {
    "pred": "Benchmark multiple functions, with three different length int values.",
    "ref": "Benchmark multiple functions, with three different length int values."
  },
  {
    "pred": "Return the value found after the forward propagation training.",
    "ref": "Return the value found after the forward propagation training."
  },
  {
    "pred": "Finds the maximum total in a triangle as described by the problem statement above.",
    "ref": "Finds the maximum total in a triangle as described by the problem statement above."
  },
  {
    "pred": "Return the thousands separator for a locale, default to comma.",
    "ref": "Return the thousands separator for a locale, default to comma."
  },
  {
    "pred": "Reverse in-order traversal visits right subtree, root node, left subtree. >>> list(reverse_inorder(make_tree())) [3, 1, 5, 2, 4]",
    "ref": "Reverse in-order traversal visits right subtree, root node, left subtree. >>> list(reverse_inorder(make_tree())) [3, 1, 5, 2, 4]"
  }
]