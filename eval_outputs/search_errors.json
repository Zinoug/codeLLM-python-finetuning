[
  {
    "input": "search code:\nThis function returns True if there is a node that has not iterated.\nChoices:\n0: def find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:\n    \"\"\"\n    find max value in list\n    :param nums: contains elements\n    :param left: index of first element\n    :param right: index of last element\n    :return: max in nums\n\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n    ...     find_max_recursive(nums, 0, len(nums) - 1) == max(nums)\n    True\n    True\n    True\n    True\n    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n    >>> find_max_recursive(nums, 0, len(nums) - 1) == max(nums)\n    True\n    >>> find_max_recursive([], 0, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: find_max_recursive() arg is an empty sequence\n    >>> find_max_recursive(nums, 0, len(nums)) == max(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    >>> find_max_recursive(nums, -len(nums), -1) == max(nums)\n    True\n    >>> find_max_recursive(nums, -len(nums) - 1, -1) == max(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"find_max_recursive() arg is an empty sequence\")\n    if (\n        left >= len(nums)\n        or left < -len(nums)\n        or right >= len(nums)\n        or right < -len(nums)\n    ):\n        raise IndexError(\"list index out of range\")\n    if left == right:\n        return nums[left]\n    mid = (left + right) >> 1  # the middle\n    left_max = find_max_recursive(nums, left, mid)  # find max in range[left, mid]\n    right_max = find_max_recursive(\n        nums, mid + 1, right\n    )  # find max in range[mid + 1, right]\n\n    return left_max if left_max >= right_max else right_max\n1: def luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0\n2: def breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:\n    \"\"\"\n    This function returns True if there is a node that has not iterated.\n\n    Args:\n        graph: Adjacency matrix of graph\n        source: Source\n        sink: Sink\n        parents: Parent list\n\n    Returns:\n        True if there is a node that has not iterated.\n\n    >>> breadth_first_search(graph, 0, 5, [-1, -1, -1, -1, -1, -1])\n    True\n    >>> breadth_first_search(graph, 0, 6, [-1, -1, -1, -1, -1, -1])\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n    visited = [False] * len(graph)  # Mark all nodes as not visited\n    queue = []  # breadth-first search queue\n\n    # Source node\n    queue.append(source)\n    visited[source] = True\n\n    while queue:\n        u = queue.pop(0)  # Pop the front node\n        # Traverse all adjacent nodes of u\n        for ind, node in enumerate(graph[u]):\n            if visited[ind] is False and node > 0:\n                queue.append(ind)\n                visited[ind] = True\n                parents[ind] = u\n    return visited[sink]",
    "gold": "2",
    "pred_raw": "1",
    "pred_digit": "1"
  },
  {
    "input": "search code:\nThis function calculates the waiting time of some processes that have a specified duration time. Return: The waiting time for each process. >>> calculate_waiting_times([5, 10, 15]) [0, 5, 15] >>> calculate_waiting_times([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10] >>> calculate_waiting_times([10, 3]) [0, 10]\nChoices:\n0: def update_image_and_anno(\n    img_list: list, anno_list: list, flip_type: int = 1\n) -> tuple[list, list, list]:\n    \"\"\"\n    - img_list <type: list>: list of all images\n    - anno_list <type: list>: list of all annotations of specific image\n    - flip_type <type: int>: 0 is vertical, 1 is horizontal\n    Return:\n        - new_imgs_list <type: narray>: image after resize\n        - new_annos_lists <type: list>: list of new annotation after scale\n        - path_list <type: list>: list the name of image file\n    \"\"\"\n    new_annos_lists = []\n    path_list = []\n    new_imgs_list = []\n    for idx in range(len(img_list)):\n        new_annos = []\n        path = img_list[idx]\n        path_list.append(path)\n        img_annos = anno_list[idx]\n        img = cv2.imread(path)\n        if flip_type == 1:\n            new_img = cv2.flip(img, flip_type)\n            for bbox in img_annos:\n                x_center_new = 1 - bbox[1]\n                new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])\n        elif flip_type == 0:\n            new_img = cv2.flip(img, flip_type)\n            for bbox in img_annos:\n                y_center_new = 1 - bbox[2]\n                new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])\n        new_annos_lists.append(new_annos)\n        new_imgs_list.append(new_img)\n    return new_imgs_list, new_annos_lists, path_list\n1: def get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:\n    \"\"\"\n    Generate filters for audio processing.\n\n    Args:\n        filter_points: A list of filter points.\n        ftt_size: The size of the FFT.\n\n    Returns:\n        A matrix of filters.\n\n    Examples:\n    >>> get_filters(np.array([0, 20, 51, 95, 161, 256], dtype=int), 512).shape\n    (4, 257)\n    \"\"\"\n    num_filters = len(filter_points) - 2\n    filters = np.zeros((num_filters, int(ftt_size / 2) + 1))\n\n    for n in range(num_filters):\n        start = filter_points[n]\n        mid = filter_points[n + 1]\n        end = filter_points[n + 2]\n\n        # Linearly increase values from 0 to 1\n        filters[n, start:mid] = np.linspace(0, 1, mid - start)\n\n        # Linearly decrease values from 1 to 0\n        filters[n, mid:end] = np.linspace(1, 0, end - mid)\n\n    return filters\n2: def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times",
    "gold": "2",
    "pred_raw": "1",
    "pred_digit": "1"
  },
  {
    "input": "search code:\nReturns a list of *count* chunks, each with *size* elements, generated from iterable *src*. If *src* is not evenly divisible by *size*, the final chunk will have fewer than *size* elements. Provide the *fill* keyword argument to provide a pad value and enable padding, otherwise no padding will take place.\nChoices:\n0: def get_all(type_obj, include_subtypes=True):\n    \"\"\"Get a list containing all instances of a given type.  This will\n    work for the vast majority of types out there.\n\n    >>> class Ratking(object): pass\n    >>> wiki, hak, sport = Ratking(), Ratking(), Ratking()\n    >>> len(get_all(Ratking))\n    3\n\n    However, there are some exceptions. For example, ``get_all(bool)``\n    returns an empty list because ``True`` and ``False`` are\n    themselves built-in and not tracked.\n\n    >>> get_all(bool)\n    []\n\n    Still, it's not hard to see how this functionality can be used to\n    find all instances of a leaking type and track them down further\n    using :func:`gc.get_referrers` and :func:`gc.get_referents`.\n\n    ``get_all()`` is optimized such that getting instances of\n    user-created types is quite fast. Setting *include_subtypes* to\n    ``False`` will further increase performance in cases where\n    instances of subtypes aren't required.\n\n    .. note::\n\n      There are no guarantees about the state of objects returned by\n      ``get_all()``, especially in concurrent environments. For\n      instance, it is possible for an object to be in the middle of\n      executing its ``__init__()`` and be only partially constructed.\n    \"\"\"\n    # TODO: old-style classes\n    if not isinstance(type_obj, type):\n        raise TypeError('expected a type, not %r' % type_obj)\n    try:\n        type_is_tracked = gc.is_tracked(type_obj)\n    except AttributeError:\n        type_is_tracked = False  # Python 2.6 and below don't get the speedup\n    if type_is_tracked:\n        to_check = gc.get_referrers(type_obj)\n    else:\n        to_check = gc.get_objects()\n\n    if include_subtypes:\n        ret = [x for x in to_check if isinstance(x, type_obj)]\n    else:\n        ret = [x for x in to_check if type(x) is type_obj]\n    return ret\n1: def solution(n: int = 10000) -> int:\n    \"\"\"Returns the sum of all the amicable numbers under n.\n\n    >>> solution(10000)\n    31626\n    >>> solution(5000)\n    8442\n    >>> solution(1000)\n    504\n    >>> solution(100)\n    0\n    >>> solution(50)\n    0\n    \"\"\"\n    total = sum(\n        i\n        for i in range(1, n)\n        if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i\n    )\n    return total\n2: def chunked(src, size, count=None, **kw):\n    \"\"\"Returns a list of *count* chunks, each with *size* elements,\n    generated from iterable *src*. If *src* is not evenly divisible by\n    *size*, the final chunk will have fewer than *size* elements.\n    Provide the *fill* keyword argument to provide a pad value and\n    enable padding, otherwise no padding will take place.\n\n    >>> chunked(range(10), 3)\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n    >>> chunked(range(10), 3, fill=None)\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, None, None]]\n    >>> chunked(range(10), 3, count=2)\n    [[0, 1, 2], [3, 4, 5]]\n\n    See :func:`chunked_iter` for more info.\n    \"\"\"\n    chunk_iter = chunked_iter(src, size, **kw)\n    if count is None:\n        return list(chunk_iter)\n    else:\n        return list(itertools.islice(chunk_iter, count))",
    "gold": "2",
    "pred_raw": "1",
    "pred_digit": "1"
  },
  {
    "input": "search code:\nDepth-first iterator over scalars in a tensor.\nChoices:\n0: def perfect(number: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect number.\n\n    A perfect number is a positive integer that is equal to the sum of its proper\n    divisors (excluding itself).\n\n    Args:\n        number: The number to be checked.\n\n    Returns:\n        True if the number is a perfect number otherwise, False.\n    Start from 1 because dividing by 0 will raise ZeroDivisionError.\n    A number at most can be divisible by the half of the number except the number\n    itself. For example, 6 is at most can be divisible by 3 except by 6 itself.\n    Examples:\n    >>> perfect(27)\n    False\n    >>> perfect(28)\n    True\n    >>> perfect(29)\n    False\n    >>> perfect(6)\n    True\n    >>> perfect(12)\n    False\n    >>> perfect(496)\n    True\n    >>> perfect(8128)\n    True\n    >>> perfect(0)\n    False\n    >>> perfect(-1)\n    False\n    >>> perfect(33550336)  # Large perfect number\n    True\n    >>> perfect(33550337)  # Just above a large perfect number\n    False\n    >>> perfect(1)  # Edge case: 1 is not a perfect number\n    False\n    >>> perfect(\"123\")  # String representation of a number\n    Traceback (most recent call last):\n    ...\n    ValueError: number must be an integer\n    >>> perfect(12.34)\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    >>> perfect(\"Hello\")\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        raise ValueError(\"number must be an integer\")\n    if number <= 0:\n        return False\n    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number\n1: def breadth_first_search(graph: dict, start: str) -> list[str]:\n    \"\"\"\n    Implementation of breadth first search using queue.Queue.\n\n    >>> ''.join(breadth_first_search(G, 'A'))\n    'ABCDEF'\n    \"\"\"\n    explored = {start}\n    result = [start]\n    queue: Queue = Queue()\n    queue.put(start)\n    while not queue.empty():\n        v = queue.get()\n        for w in graph[v]:\n            if w not in explored:\n                explored.add(w)\n                result.append(w)\n                queue.put(w)\n    return result\n2: def _flatten_tensor(tensor):\n    \"Depth-first iterator over scalars in a tensor.\"\n    iterator = iter(tensor)\n    while True:\n        try:\n            value = next(iterator)\n        except StopIteration:\n            return iterator\n        iterator = chain((value,), iterator)\n        if _is_scalar(value):\n            return iterator\n        iterator = chain.from_iterable(iterator)",
    "gold": "2",
    "pred_raw": "1",
    "pred_digit": "1"
  },
  {
    "input": "search code:\nCeq = 1/ (1/C1 + 1/C2 + ... + 1/Cn) >>> capacitor_series([5.71389, 12, 3]) 1.6901062252507735 >>> capacitor_series([5.71389, 12, -3]) Traceback (most recent call last): ... ValueError: Capacitor at index 2 has a negative or zero value! >>> capacitor_series([5.71389, 12, 0.000]) Traceback (most recent call last): ... ValueError: Capacitor at index 2 has a negative or zero value!\nChoices:\n0: def print_binary_search_tree(root, key, i, j, parent, is_left):\n    \"\"\"\n    Recursive function to print a BST from a root table.\n\n    >>> key = [3, 8, 9, 10, 17, 21]\n    >>> root = [[0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 3], [0, 0, 2, 3, 3, 3], \\\n                [0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 5]]\n    >>> print_binary_search_tree(root, key, 0, 5, -1, False)\n    8 is the root of the binary search tree.\n    3 is the left child of key 8.\n    10 is the right child of key 8.\n    9 is the left child of key 10.\n    21 is the right child of key 10.\n    17 is the left child of key 21.\n    \"\"\"\n    if i > j or i < 0 or j > len(root) - 1:\n        return\n\n    node = root[i][j]\n    if parent == -1:  # root does not have a parent\n        print(f\"{key[node]} is the root of the binary search tree.\")\n    elif is_left:\n        print(f\"{key[node]} is the left child of key {parent}.\")\n    else:\n        print(f\"{key[node]} is the right child of key {parent}.\")\n\n    print_binary_search_tree(root, key, i, node - 1, key[node], True)\n    print_binary_search_tree(root, key, node + 1, j, key[node], False)\n1: def dijk(g, s):\n    \"\"\"\n    dijk({1: [(2, 7), (3, 9), (6, 14)],\n        2: [(1, 7), (3, 10), (4, 15)],\n        3: [(1, 9), (2, 10), (4, 11), (6, 2)],\n        4: [(2, 15), (3, 11), (5, 6)],\n        5: [(4, 6), (6, 9)],\n        6: [(1, 14), (3, 2), (5, 9)]}, 1)\n    7\n    9\n    11\n    20\n    20\n    \"\"\"\n    dist, known, path = {s: 0}, set(), {s: 0}\n    while True:\n        if len(known) == len(g) - 1:\n            break\n        mini = 100000\n        for key, value in dist:\n            if key not in known and value < mini:\n                mini = value\n                u = key\n        known.add(u)\n        for v in g[u]:\n            if v[0] not in known and dist[u] + v[1] < dist.get(v[0], 100000):\n                dist[v[0]] = dist[u] + v[1]\n                path[v[0]] = u\n    for key, value in dist.items():\n        if key != s:\n            print(value)\n2: def capacitor_series(capacitors: list[float]) -> float:\n    \"\"\"\n    Ceq = 1/ (1/C1 + 1/C2 + ... + 1/Cn)\n    >>> capacitor_series([5.71389, 12, 3])\n    1.6901062252507735\n    >>> capacitor_series([5.71389, 12, -3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitor at index 2 has a negative or zero value!\n    >>> capacitor_series([5.71389, 12, 0.000])\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitor at index 2 has a negative or zero value!\n    \"\"\"\n\n    first_sum = 0.0\n    for index, capacitor in enumerate(capacitors):\n        if capacitor <= 0:\n            msg = f\"Capacitor at index {index} has a negative or zero value!\"\n            raise ValueError(msg)\n        first_sum += 1 / capacitor\n    return 1 / first_sum",
    "gold": "2",
    "pred_raw": "1",
    "pred_digit": "1"
  },
  {
    "input": "search code:\nFunction to validate initial digits of a given credit card number. >>> valid = \"4111111111111111 41111111111111 34 35 37 412345 523456 634567\" >>> all(validate_initial_digits(cc) for cc in valid.split()) True >>> invalid = \"14 25 76 32323 36111111111111\" >>> all(validate_initial_digits(cc) is False for cc in invalid.split()) True\nChoices:\n0: def combination_with_replacement_index(element, iterable):\n    \"\"\"Equivalent to\n    ``list(combinations_with_replacement(iterable, r)).index(element)``\n\n    The subsequences with repetition of *iterable* that are of length *r* can\n    be ordered lexicographically. :func:`combination_with_replacement_index`\n    computes the index of the first *element*, without computing the previous\n    combinations with replacement.\n\n        >>> combination_with_replacement_index('adf', 'abcdefg')\n        20\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations with replacement of *iterable*.\n    \"\"\"\n    element = tuple(element)\n    l = len(element)\n    element = enumerate(element)\n\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = tuple(iterable)\n    for n, x in enumerate(pool):\n        while x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n        if y is None:\n            break\n    else:\n        raise ValueError(\n            'element is not a combination with replacement of iterable'\n        )\n\n    n = len(pool)\n    occupations = [0] * n\n    for p in indexes:\n        occupations[p] += 1\n\n    index = 0\n    cumulative_sum = 0\n    for k in range(1, n):\n        cumulative_sum += occupations[k - 1]\n        j = l + n - 1 - k - cumulative_sum\n        i = n - k\n        if i <= j:\n            index += comb(j, i)\n\n    return index\n1: def validate_initial_digits(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to validate initial digits of a given credit card number.\n    >>> valid = \"4111111111111111 41111111111111 34 35 37 412345 523456 634567\"\n    >>> all(validate_initial_digits(cc) for cc in valid.split())\n    True\n    >>> invalid = \"14 25 76 32323 36111111111111\"\n    >>> all(validate_initial_digits(cc) is False for cc in invalid.split())\n    True\n    \"\"\"\n    return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))\n2: def prime_sieve(num: int) -> list[int]:\n    \"\"\"\n    Returns a list with all prime numbers up to n.\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    >>> prime_sieve(25)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    >>> prime_sieve(10)\n    [2, 3, 5, 7]\n    >>> prime_sieve(9)\n    [2, 3, 5, 7]\n    >>> prime_sieve(2)\n    [2]\n    >>> prime_sieve(1)\n    []\n    \"\"\"\n\n    if num <= 0:\n        msg = f\"{num}: Invalid input, please enter a positive integer.\"\n        raise ValueError(msg)\n\n    sieve = [True] * (num + 1)\n    prime = []\n    start = 2\n    end = int(math.sqrt(num))\n\n    while start <= end:\n        # If start is a prime\n        if sieve[start] is True:\n            prime.append(start)\n\n            # Set multiples of start be False\n            for i in range(start * start, num + 1, start):\n                if sieve[i] is True:\n                    sieve[i] = False\n\n        start += 1\n\n    for j in range(end + 1, num + 1):\n        if sieve[j] is True:\n            prime.append(j)\n\n    return prime",
    "gold": "1",
    "pred_raw": "2",
    "pred_digit": "2"
  },
  {
    "input": "search code:\nReturns a list of nodes value from a whole binary tree in Level Order Traverse. Level Order traverse: Visit nodes of the tree level-by-level. >>> list(level_order(make_tree())) [1, 2, 3, 4, 5]\nChoices:\n0: def my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:\n    \"\"\"\n    :param src: the source image, which should be a grayscale or color image.\n    :param ksize: the size of the kernel used to compute the Laplacian filter,\n                  which can be 1, 3, 5, or 7.\n\n    >>> my_laplacian(src=np.array([]), ksize=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: ksize must be in (1, 3, 5, 7)\n    \"\"\"\n    kernels = {\n        1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),\n        3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),\n        5: np.array(\n            [\n                [0, 0, -1, 0, 0],\n                [0, -1, -2, -1, 0],\n                [-1, -2, 16, -2, -1],\n                [0, -1, -2, -1, 0],\n                [0, 0, -1, 0, 0],\n            ]\n        ),\n        7: np.array(\n            [\n                [0, 0, 0, -1, 0, 0, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, -2, -7, -10, -7, -2, 0],\n                [-1, -3, -10, 68, -10, -3, -1],\n                [0, -2, -7, -10, -7, -2, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, 0, 0, -1, 0, 0, 0],\n            ]\n        ),\n    }\n    if ksize not in kernels:\n        msg = f\"ksize must be in {tuple(kernels)}\"\n        raise ValueError(msg)\n\n    # Apply the Laplacian kernel using convolution\n    return filter2D(\n        src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)\n    )\n1: def level_order(root: Node | None) -> Generator[int]:\n    \"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    >>> list(level_order(make_tree()))\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    if root is None:\n        return\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        yield node.data\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)\n2: def pairwise_iter(src, end=_UNSET):\n    \"\"\"Convenience function for calling :func:`windowed_iter` on *src*,\n    with *size* set to 2.\n\n    >>> list(pairwise_iter(range(5)))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n    >>> list(pairwise_iter([]))\n    []\n\n    Unless *end* is set, the number of pairs is always one less \n    than the number of elements in the iterable passed in, \n    or zero, when *src* is empty.\n\n    With *end* set, a number of pairs equal to the length of *src* is returned,\n    with the last item of the last pair being equal to *end*. \n\n    >>> list(pairwise_iter(range(3), end=None))\n    [(0, 1), (1, 2), (2, None)]    \n\n    This way, *end* values can be useful as sentinels to signal the end\n    of the iterable. For infinite iterators, setting *end* has no effect.\n    \"\"\"\n    return windowed_iter(src, 2, fill=end)",
    "gold": "1",
    "pred_raw": "2",
    "pred_digit": "2"
  },
  {
    "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number num (i.e., if the result is true, then the number is indeed prime else it is not).\nChoices:\n0: def interpolation_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"\n    Searches for an item in a sorted collection by interpolation search algorithm.\n\n    Args:\n        sorted_collection: sorted list of integers\n        item: item value to search\n\n    Returns:\n        int: The index of the found item, or None if the item is not found.\n    Examples:\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([1, 2, 3, 4, 5], 4)\n    3\n    >>> interpolation_search([1, 2, 3, 4, 5], 6) is None\n    True\n    >>> interpolation_search([], 1) is None\n    True\n    >>> interpolation_search([100], 100)\n    0\n    >>> interpolation_search([1, 2, 3, 4, 5], 0) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 7) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([1, 2, 3, 4, 5], 0) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 7) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([5, 5, 5, 5, 5], 3) is None\n    True\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        # avoid divided by 0 during interpolation\n        if sorted_collection[left] == sorted_collection[right]:\n            if sorted_collection[left] == item:\n                return left\n            return None\n\n        point = left + ((item - sorted_collection[left]) * (right - left)) // (\n            sorted_collection[right] - sorted_collection[left]\n        )\n\n        # out of range check\n        if point < 0 or point >= len(sorted_collection):\n            return None\n\n        current_item = sorted_collection[point]\n        if current_item == item:\n            return point\n        if point < left:\n            right = left\n            left = point\n        elif point > right:\n            left = right\n            right = point\n        elif item < current_item:\n            right = point - 1\n        else:\n            left = point + 1\n    return None\n1: def perfect_square(num: int) -> bool:\n    \"\"\"\n    Check if a number is perfect square number or not\n    :param num: the number to be checked\n    :return: True if number is square number, otherwise False\n\n    >>> perfect_square(9)\n    True\n    >>> perfect_square(16)\n    True\n    >>> perfect_square(1)\n    True\n    >>> perfect_square(0)\n    True\n    >>> perfect_square(10)\n    False\n    \"\"\"\n    return math.sqrt(num) * math.sqrt(num) == num\n2: def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number num (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(-10)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "gold": "2",
    "pred_raw": "1",
    "pred_digit": "1"
  },
  {
    "input": "search code:\nPrim's Algorithm.\nChoices:\n0: def geometric_series(\n    nth_term: float,\n    start_term_a: float,\n    common_ratio_r: float,\n) -> list[float]:\n    \"\"\"\n    Pure Python implementation of Geometric Series algorithm\n\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\n    >>> geometric_series(4, 2, -2)\n    [2, -4.0, 8.0, -16.0]\n    >>> geometric_series(4, -2, 2)\n    [-2, -4.0, -8.0, -16.0]\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if not series:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series\n1: def base64_decode(encoded_data: str) -> bytes:\n    \"\"\"Decodes data according to RFC4648.\n\n    This does the reverse operation of base64_encode.\n    We first transform the encoded data back to a binary stream, take off the\n    previously appended binary digits according to the padding, at this point we\n    would have a binary stream whose length is multiple of 8, the last step is\n    to convert every 8 bits to a byte.\n\n    >>> from base64 import b64decode\n    >>> a = \"VGhpcyBwdWxsIHJlcXVlc3QgaXMgcGFydCBvZiBIYWNrdG9iZXJmZXN0MjAh\"\n    >>> b = \"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2NDg=\"\n    >>> c = \"QQ==\"\n    >>> base64_decode(a) == b64decode(a)\n    True\n    >>> base64_decode(b) == b64decode(b)\n    True\n    >>> base64_decode(c) == b64decode(c)\n    True\n    >>> base64_decode(\"abc\")\n    Traceback (most recent call last):\n      ...\n    AssertionError: Incorrect padding\n    \"\"\"\n    # Make sure encoded_data is either a string or a bytes-like object\n    if not isinstance(encoded_data, bytes) and not isinstance(encoded_data, str):\n        msg = (\n            \"argument should be a bytes-like object or ASCII string, \"\n            f\"not '{encoded_data.__class__.__name__}'\"\n        )\n        raise TypeError(msg)\n\n    # In case encoded_data is a bytes-like object, make sure it contains only\n    # ASCII characters so we convert it to a string object\n    if isinstance(encoded_data, bytes):\n        try:\n            encoded_data = encoded_data.decode(\"utf-8\")\n        except UnicodeDecodeError:\n            raise ValueError(\"base64 encoded data should only contain ASCII characters\")\n\n    padding = encoded_data.count(\"=\")\n\n    # Check if the encoded string contains non base64 characters\n    if padding:\n        assert all(char in B64_CHARSET for char in encoded_data[:-padding]), (\n            \"Invalid base64 character(s) found.\"\n        )\n    else:\n        assert all(char in B64_CHARSET for char in encoded_data), (\n            \"Invalid base64 character(s) found.\"\n        )\n\n    # Check the padding\n    assert len(encoded_data) % 4 == 0 and padding < 3, \"Incorrect padding\"\n\n    if padding:\n        # Remove padding if there is one\n        encoded_data = encoded_data[:-padding]\n\n        binary_stream = \"\".join(\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\n        )[: -padding * 2]\n    else:\n        binary_stream = \"\".join(\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\n        )\n\n    data = [\n        int(binary_stream[index : index + 8], 2)\n        for index in range(0, len(binary_stream), 8)\n    ]\n\n    return bytes(data)\n2: def prim(graph: list, root: Vertex) -> list:\n    \"\"\"Prim's Algorithm.\n\n    Runtime:\n        O(mn) with `m` edges and `n` vertices\n\n    Return:\n        List with the edges of a Minimum Spanning Tree\n\n    Usage:\n        prim(graph, graph[0])\n    \"\"\"\n    a = []\n    for u in graph:\n        u.key = math.inf\n        u.pi = None\n    root.key = 0\n    q = graph[:]\n    while q:\n        u = min(q)\n        q.remove(u)\n        for v in u.neighbors:\n            if (v in q) and (u.edges[v.id] < v.key):\n                v.pi = u\n                v.key = u.edges[v.id]\n    for i in range(1, len(graph)):\n        a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))\n    return a",
    "gold": "2",
    "pred_raw": "1",
    "pred_digit": "1"
  },
  {
    "input": "search code:\nEliminate d from values[s]; propagate when values or places <= 2. Return values, except return False if a contradiction is detected.\nChoices:\n0: def bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1\n1: def normalize_array(array: np.ndarray, cap: float = 1) -> np.ndarray:\n    \"\"\"Normalizes a 1D array, between ranges 0-cap.\n\n    Args:\n        array: List containing values to be normalized between cap range.\n        cap: Maximum cap amount for normalization.\n    Returns:\n        return 1D numpy array, corresponding to limited range array\n\n    Examples:\n        >>> normalize_array(np.array([2, 3, 5, 7]))\n        array([0. , 0.2, 0.6, 1. ])\n        >>> normalize_array(np.array([[5], [7], [11], [13]]))\n        array([[0.  ],\n               [0.25],\n               [0.75],\n               [1.  ]])\n    \"\"\"\n    diff = np.max(array) - np.min(array)\n    return (array - np.min(array)) / (1 if diff == 0 else diff) * cap\n2: def eliminate(values, s, d):\n    \"\"\"\n    Eliminate d from values[s]; propagate when values or places <= 2.\n    Return values, except return False if a contradiction is detected.\n    \"\"\"\n    if d not in values[s]:\n        return values  ## Already eliminated\n    values[s] = values[s].replace(d, \"\")\n    ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.\n    if len(values[s]) == 0:\n        return False  ## Contradiction: removed last value\n    elif len(values[s]) == 1:\n        d2 = values[s]\n        if not all(eliminate(values, s2, d2) for s2 in peers[s]):\n            return False\n    ## (2) If a unit u is reduced to only one place for a value d, then put it there.\n    for u in units[s]:\n        dplaces = [s for s in u if d in values[s]]\n        if len(dplaces) == 0:\n            return False  ## Contradiction: no place for this value\n        # d can only be in one place in unit; assign it there\n        elif len(dplaces) == 1 and not assign(values, dplaces[0], d):\n            return False\n    return values",
    "gold": "2",
    "pred_raw": "1",
    "pred_digit": "1"
  },
  {
    "input": "search code:\nThis function can calculate any one of the three (voltage, current, power), fundamental value of electrical system. examples are below: >>> electric_power(voltage=0, current=2, power=5) Result(name='voltage', value=2.5) >>> electric_power(voltage=2, current=2, power=0) Result(name='power', value=4.0) >>> electric_power(voltage=-2, current=3, power=0) Result(name='power', value=6.0) >>> electric_power(voltage=2, current=4, power=2) Traceback (most recent call last): ... ValueError: Exactly one argument must be 0 >>> electric_power(voltage=0, current=0, power=2) Traceback (most recent call last): ... ValueError: Exactly one argument must be 0 >>> electric_power(voltage=0, current=2, power=-4) Traceback (most recent call last): ... ValueError: Power cannot be negative in any electrical/electronics system >>> electric_power(voltage=2.2, current=2.2, power=0) Result(name='power', value=4.84) >>> electric_power(current=0, power=6, voltage=2) Result(name='current', value=3.0)\nChoices:\n0: def open_knight_tour(n: int) -> list[list[int]]:\n    \"\"\"\n    Find the solution for the knight tour problem for a board of size n. Raises\n    ValueError if the tour cannot be performed for the given size.\n\n    >>> open_knight_tour(1)\n    [[1]]\n\n    >>> open_knight_tour(2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Open Knight Tour cannot be performed on a board of size 2\n    \"\"\"\n\n    board = [[0 for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 1\n            if open_knight_tour_helper(board, (i, j), 1):\n                return board\n            board[i][j] = 0\n\n    msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"\n    raise ValueError(msg)\n1: def electric_power(voltage: float, current: float, power: float) -> tuple:\n    \"\"\"\n    This function can calculate any one of the three (voltage, current, power),\n    fundamental value of electrical system.\n    examples are below:\n    >>> electric_power(voltage=0, current=2, power=5)\n    Result(name='voltage', value=2.5)\n    >>> electric_power(voltage=2, current=2, power=0)\n    Result(name='power', value=4.0)\n    >>> electric_power(voltage=-2, current=3, power=0)\n    Result(name='power', value=6.0)\n    >>> electric_power(voltage=2, current=4, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=0, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=2, power=-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Power cannot be negative in any electrical/electronics system\n    >>> electric_power(voltage=2.2, current=2.2, power=0)\n    Result(name='power', value=4.84)\n    >>> electric_power(current=0, power=6, voltage=2)\n    Result(name='current', value=3.0)\n    \"\"\"\n    if (voltage, current, power).count(0) != 1:\n        raise ValueError(\"Exactly one argument must be 0\")\n    elif power < 0:\n        raise ValueError(\n            \"Power cannot be negative in any electrical/electronics system\"\n        )\n    elif voltage == 0:\n        return Result(\"voltage\", power / current)\n    elif current == 0:\n        return Result(\"current\", power / voltage)\n    elif power == 0:\n        return Result(\"power\", float(round(abs(voltage * current), 2)))\n    else:\n        raise AssertionError\n2: def main() -> None:\n    \"\"\"\n    starting point or function of script\n    \"\"\"\n    lower = int(input(\"Enter lower value : \").strip())\n    higher = int(input(\"Enter high value : \").strip())\n    guess = int(input(\"Enter value to guess : \").strip())\n    guess_the_number(lower, higher, guess)",
    "gold": "1",
    "pred_raw": "2",
    "pred_digit": "2"
  },
  {
    "input": "search code:\n\" Return the sum of n terms in a geometric progression. >>> sum_of_geometric_progression(1, 2, 10) 1023.0 >>> sum_of_geometric_progression(1, 10, 5) 11111.0 >>> sum_of_geometric_progression(0, 2, 10) 0.0 >>> sum_of_geometric_progression(1, 0, 10) 1.0 >>> sum_of_geometric_progression(1, 2, 0) -0.0 >>> sum_of_geometric_progression(-1, 2, 10) -1023.0 >>> sum_of_geometric_progression(1, -2, 10) -341.0 >>> sum_of_geometric_progression(1, 2, -10) -0.9990234375\nChoices:\n0: def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result\n1: def mark_ends(iterable):\n    \"\"\"Yield 3-tuples of the form ``(is_first, is_last, item)``.\n\n    >>> list(mark_ends('ABC'))\n    [(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]\n\n    Use this when looping over an iterable to take special action on its first\n    and/or last items:\n\n    >>> iterable = ['Header', 100, 200, 'Footer']\n    >>> total = 0\n    >>> for is_first, is_last, item in mark_ends(iterable):\n    ...     if is_first:\n    ...         continue  # Skip the header\n    ...     if is_last:\n    ...         continue  # Skip the footer\n    ...     total += item\n    >>> print(total)\n    300\n    \"\"\"\n    it = iter(iterable)\n    for a in it:\n        first = True\n        for b in it:\n            yield first, False, a\n            a = b\n            first = False\n        yield first, True, a\n2: def sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)",
    "gold": "2",
    "pred_raw": "1",
    "pred_digit": "1"
  },
  {
    "input": "search code:\nTakes a type and returns an iterator over all class variables throughout the type hierarchy (respecting the MRO).\nChoices:\n0: def map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):\n    \"\"\"Return a dictionary that maps the items in *iterable* to categories\n    defined by *keyfunc*, transforms them with *valuefunc*, and\n    then summarizes them by category with *reducefunc*.\n\n    *valuefunc* defaults to the identity function if it is unspecified.\n    If *reducefunc* is unspecified, no summarization takes place:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> result = map_reduce('abbccc', keyfunc)\n        >>> sorted(result.items())\n        [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    Specifying *valuefunc* transforms the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc)\n        >>> sorted(result.items())\n        [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    Specifying *reducefunc* summarizes the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> reducefunc = sum\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)\n        >>> sorted(result.items())\n        [('A', 1), ('B', 2), ('C', 3)]\n\n    You may want to filter the input iterable before applying the map/reduce\n    procedure:\n\n        >>> all_items = range(30)\n        >>> items = [x for x in all_items if 10 <= x <= 20]  # Filter\n        >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n        >>> categories = map_reduce(items, keyfunc=keyfunc)\n        >>> sorted(categories.items())\n        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n        >>> summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)\n        >>> sorted(summaries.items())\n        [(0, 90), (1, 75)]\n\n    Note that all items in the iterable are gathered into a list before the\n    summarization step, which may require significant storage.\n\n    The returned object is a :obj:`collections.defaultdict` with the\n    ``default_factory`` set to ``None``, such that it behaves like a normal\n    dictionary.\n\n    \"\"\"\n\n    ret = defaultdict(list)\n\n    if valuefunc is None:\n        for item in iterable:\n            key = keyfunc(item)\n            ret[key].append(item)\n\n    else:\n        for item in iterable:\n            key = keyfunc(item)\n            value = valuefunc(item)\n            ret[key].append(value)\n\n    if reducefunc is not None:\n        for key, value_list in ret.items():\n            ret[key] = reducefunc(value_list)\n\n    ret.default_factory = None\n    return ret\n1: def mro_items(type_obj):\n    \"\"\"Takes a type and returns an iterator over all class variables\n    throughout the type hierarchy (respecting the MRO).\n\n    >>> sorted(set([k for k, v in mro_items(int) if not k.startswith('__') and 'bytes' not in k and not callable(v)]))\n    ['denominator', 'imag', 'numerator', 'real']\n    \"\"\"\n    # TODO: handle slots?\n    return itertools.chain.from_iterable(ct.__dict__.items()\n                                         for ct in type_obj.__mro__)\n2: def score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch",
    "gold": "1",
    "pred_raw": "2",
    "pred_digit": "2"
  },
  {
    "input": "search code:\nConstructs a top-down dynamic programming solution for the rod-cutting problem via memoization.\nChoices:\n0: def top_down_cut_rod(n: int, prices: list):\n    \"\"\"\n    Constructs a top-down dynamic programming solution for the rod-cutting\n    problem via memoization. This function serves as a wrapper for\n    ``_top_down_cut_rod_recursive``\n\n    Runtime: O(n^2)\n\n    Arguments\n    ---------\n\n    * `n`: int, the length of the rod\n    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n      price for a rod of length ``i``\n\n    .. note::\n      For convenience and because Python's lists using ``0``-indexing, ``length(max_rev)\n      = n + 1``, to accommodate for the revenue obtainable from a rod of length ``0``.\n\n    Returns\n    -------\n\n    The maximum revenue obtainable for a rod of length `n` given the list of prices\n    for each piece.\n\n    Examples\n    --------\n\n    >>> top_down_cut_rod(4, [1, 5, 8, 9])\n    10\n    >>> top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n    30\n    \"\"\"\n    _enforce_args(n, prices)\n    max_rev = [float(\"-inf\") for _ in range(n + 1)]\n    return _top_down_cut_rod_recursive(n, prices, max_rev)\n1: def quote_query_part(text, full_quote=True):\n    \"\"\"\n    Percent-encode a single query string key or value.\n    \"\"\"\n    if full_quote:\n        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')\n        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])\n    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t\n                     for t in text])\n2: def _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):\n    \"\"\"\n    Constructs a top-down dynamic programming solution for the rod-cutting problem\n    via memoization.\n\n    Runtime: O(n^2)\n\n    Arguments\n    ---------\n\n    * `n`: int, the length of the rod\n    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n      price for a rod of length ``i``\n    * `max_rev`: list, the computed maximum revenue for a piece of rod.\n      ``max_rev[i]`` is the maximum revenue obtainable for a rod of length ``i``\n\n    Returns\n    -------\n\n    The maximum revenue obtainable for a rod of length `n` given the list of prices\n    for each piece.\n    \"\"\"\n    if max_rev[n] >= 0:\n        return max_rev[n]\n    elif n == 0:\n        return 0\n    else:\n        max_revenue = float(\"-inf\")\n        for i in range(1, n + 1):\n            max_revenue = max(\n                max_revenue,\n                prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),\n            )\n\n        max_rev[n] = max_revenue\n\n    return max_rev[n]",
    "gold": "2",
    "pred_raw": "0",
    "pred_digit": "0"
  }
]